<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/26/hello-world/"/>
      <url>/2023/12/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h3><blockquote><p>21世纪是以数字化、网络化、信息化为重要特征的信息时代，作为信息的最大载体和传输媒介，网络已成为这个信息时代的核心基础</p></blockquote><h3 id="1-2-计算机网络的定义与分类"><a href="#1-2-计算机网络的定义与分类" class="headerlink" title="1.2 计算机网络的定义与分类"></a>1.2 计算机网络的定义与分类</h3><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p>简单定义：==硬件==（独立和连接）+==软件==（协议）+==目的==（共享和通信）</p><blockquote><p>==<strong>计算机网络就是以传输信息为基本目的，用通信线路和通信设备将多个计算机连接起来的计算机系统的集合</strong>==</p></blockquote><h4 id="1-2-2-分类"><a href="#1-2-2-分类" class="headerlink" title="1.2.2 分类"></a>1.2.2 分类</h4><blockquote><p>按网络覆盖范围进行分类</p></blockquote><ol><li>局域网（Local Area Network,<code>LAN</code>，一个实验室、一幢楼、一个校园）</li><li>城域网（Metropolitan Area Network,<code>MAN</code>，几个街区甚至整个城市，5-50 km）</li><li>广域网（Wide Area Network,<code>WAN</code>，覆盖一个国家或地区甚至几个洲，也称为<strong>远程网</strong>）</li><li>个人区域网（Personal Area Network,<code>PAN</code>，10 m以内）</li></ol><blockquote><p>按网络的使用者进行分类</p></blockquote><ol><li>公用网（所有愿意缴纳费用的人都能使用）</li><li>专用网（专门为本单位的特殊业务工作建造的，例如，军队、铁路、电力等系统）</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.TZiqFW.png" alt="计算机网络分类" title='计算机网络的分类' /></p><h3 id="1-3-互联网概述"><a href="#1-3-互联网概述" class="headerlink" title="1.3 互联网概述"></a>1.3 互联网概述</h3><h4 id="1-3-1-网络的网络"><a href="#1-3-1-网络的网络" class="headerlink" title="1.3.1 网络的网络"></a>1.3.1 网络的网络</h4><ol><li>网络</li></ol><blockquote><p>==网络==由==若干节点==（Node）和连接这些节点的==链路==(Link)组成</p><p>节点：可以是计算机、集线器、交换机、路由器</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224626941.png" title="网络" style="zoom:80%;" /></p><ol><li>互连网络（internet，通用名词，注意和 Internet互联网 区分）</li></ol><blockquote><p>将网络用路由器连接起来就成了互连网络，因此互连网络是==网络的网络==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224534363.png" title="互连网络就是网络的网络" style="zoom:80%;" /></p><blockquote><p>总结：==<strong>网络把许多计算机连接在一起，而互联网络则把许多网络连接在一起</strong>==</p></blockquote><ol><li>互联网（Internet，也称 因特网）</li></ol><blockquote><p>当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，采用TCP/IP协议作为通信规则，前身是美国的阿帕网（ARPANet）</p></blockquote><ol><li>边缘部分：用户直接使用的</li><li>核心部分：为边缘部分提供服务的</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224804841.png" title="woc,O" style="zoom: 67%;" /></p><h4 id="1-3-2-互联网结构发展的三个阶段"><a href="#1-3-2-互联网结构发展的三个阶段" class="headerlink" title="1.3.2 互联网结构发展的三个阶段"></a>1.3.2 互联网结构发展的三个阶段</h4><ol><li>第一阶段：从单个网络ARPANET向互连网络发展</li><li>第二阶段：逐步建成三级结构的互联网</li><li>第三阶段：逐渐形成多层次的ISP结构的互联网</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225143618.png" title="ISP结构的互联网" style="zoom: 67%;"/></p><h3 id="1-4-电路交换和分组交换"><a href="#1-4-电路交换和分组交换" class="headerlink" title="1.4 电路交换和分组交换"></a>1.4 电路交换和分组交换</h3><h4 id="1-4-1-电路交换"><a href="#1-4-1-电路交换" class="headerlink" title="1.4.1 电路交换"></a>1.4.1 电路交换</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225354835.png" alt="电路交换"></p><blockquote><p>这种必须经过</p><ol><li><p><code>建立连接</code>（分配通信资源）</p></li><li><p><code>通信</code>（一直占用通信资源）</p></li><li><p><code>释放连接</code>（归还通信资源）</p></li></ol><p>三个步骤的交换方式称为==电路交换==</p><p>电路交换：电路交换是指在通信开始之前，建立一条专用的物理连接，然后在通信过程中一直占用这条连接，直到通信结束。在这个过程中，数据被分成固定大小的数据包，每个数据包都被分配一个专用的物理通路。</p><p>优点：传输==速度快==</p><p>缺点：连接建立需要时间，且连接一旦建立就无法被其他通信使用（==效率很低==）</p></blockquote><h4 id="1-4-2-报文交换"><a href="#1-4-2-报文交换" class="headerlink" title="1.4.2 报文交换"></a>1.4.2 报文交换</h4><blockquote><p>整个报文传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p></blockquote><h4 id="1-4-3-分组交换"><a href="#1-4-3-分组交换" class="headerlink" title="1.4.3 分组交换"></a>1.4.3 分组交换</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225503293.png" alt="分组交换" style="zoom: 80%;" /></p><blockquote><p>我们通常把要发送的整块数据称为一个==报文==（Message）</p><p>发送报文之前，先将报文划分为一个个更小的等长的数据段，在数据段前面加上==首部==（又称为==包头==）就构成了==分组==（又称为==包==）</p><p>分组交换：分组交换是指==将报文分成较小的数据包==，每个数据包都带有<strong>目标地址</strong>和<strong>源地址</strong>等信息，然后通过网络传输。在传输过程中，每个数据包都独立传输，可以通过不同的路径到达目的地，由于每个分组交换机都是先存储下来再转发出去，因此该方法被称为<span style='color:rgb(255, 107, 107);font-weight:bold'>存储转发</span>方式</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.hVntPh.png" alt="交换方式对比"></p><h3 id="1-5-计算机网络的主要性能指标"><a href="#1-5-计算机网络的主要性能指标" class="headerlink" title="1.5 计算机网络的主要性能指标"></a>1.5 计算机网络的主要性能指标</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1. 速率"></a>1. 速率</h4><blockquote><ol><li><p>==数据的传输速率==，也称为==数据率==、==比特率== 1字节(byte)=8比特(bit)</p></li><li><p>单位是 <code>bit/s 或 bps</code> ,比特是数据量的单位，是一个==二进制数字==(0或1)</p></li><li>一般来说，<script type="math/tex">k = 10^{3},K = 2^{10}</script>,但有时又不严格区分，稍微注意一下</li></ol></blockquote><p><img src='https://gitee.com/clibin/image-bed/raw/master/CopyQ.aGEcPX.png' alt='速率'></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2. 带宽"></a>2. 带宽</h4><ol><li><p>带宽本来是指某个==信号具有的频带宽度==，表示通信线路允许通过的信号频带范围,单位为赫兹</p></li><li><p>计算机网络中，带宽表示网络某通道传输能力，即==最高数据率==,单位为==比特每秒==（bit/s）</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.UEfjHW.png" alt='带宽'/></p></li></ol><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3. 吞吐量"></a>3. 吞吐量</h4><blockquote><p>也称为==吞吐率==，表示单位时间内通过某个网络（或信道、接口）的数据量</p></blockquote><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><blockquote><p>时延是指==数据从网络的一端传送到另外一端所需要的时间==，也称为==延迟==或==迟延==</p><p>网络中的时延通常由以下几个不同的部分组成：</p><ol><li><p>==发送时延：主机或路由器将整个分组的所有比特发送到通信线路上所需要的时间==</p><script type="math/tex; mode=display">发送时延 = \frac{分组长度}{发送速率}</script></li><li><p>==传播时延：是电磁波在信道中传播一定距离所花费的时间==</p><script type="math/tex; mode=display">传播时延 = \frac{信道长度}{电磁波在信道上的传播速度}</script></li><li><p>处理时延：主机或路由器在收到分组时处理分组花费的时间（一般不方便计算）</p></li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.hzERwE.png" alt='时延'/></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261920366.png" alt="时延"></p><h4 id="5-时延带宽积-往返时间-利用率-丢包率"><a href="#5-时延带宽积-往返时间-利用率-丢包率" class="headerlink" title="5. 时延带宽积 往返时间 利用率 丢包率"></a>5. 时延带宽积 往返时间 利用率 丢包率</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.XBpSgv.png" alt="" style="zoom:;" /></p><h3 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h3><h4 id="1-6-1-网络协议"><a href="#1-6-1-网络协议" class="headerlink" title="1.6.1 网络协议"></a>1.6.1 网络协议</h4><p>网络协议主要由以下三要素组成：</p><ol><li>==语法：数据与控制信息的结构或格式==（例如，地址字段多长以及它在分组的什么位置）</li><li>==语义：各个控制信息的具体含义==（需要发出何种控制信息、完成何种动作及做出何种响应）</li><li>==同步：事件实现的顺序和时间的详细说明==（数据何时发出以及以什么速率发出）</li></ol><h4 id="1-6-2-常见的计算机网络分层体系结构"><a href="#1-6-2-常见的计算机网络分层体系结构" class="headerlink" title="1.6.2 常见的计算机网络分层体系结构"></a>1.6.2 常见的计算机网络分层体系结构</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.uQqXEZ.png" alt="常见的计算机网络分层体系结构"></p><h4 id="1-6-3-具有五层协议的原理体系结构"><a href="#1-6-3-具有五层协议的原理体系结构" class="headerlink" title="1.6.3 具有五层协议的原理体系结构"></a>1.6.3 具有五层协议的原理体系结构</h4><blockquote><p>我们学习的是具有五层协议的原理体系结构</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.EvnJQE.png" alt="原理体系结构"></p><h4 id="1-6-4-实体、协议和服务"><a href="#1-6-4-实体、协议和服务" class="headerlink" title="1.6.4 实体、协议和服务"></a>1.6.4 实体、协议和服务</h4><blockquote><p><strong>==协议是水平的,服务是垂直的==</strong></p><ol><li>实体：任何可发送或接收信息的硬件或软件进程</li><li>协议：==<strong>控制两个或多个对等实体之间通信的规则的集合</strong>==</li><li>==<strong>下层通过层级接口向上层提供服务，下面的协议对上面的实体是”透明“的</strong>==</li><li>透明：某个实际存在的事物看起来好像不存在一样</li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.ZGZDeQ.png" alt="实体、协议和服务"></p><p><img src="https://cdn.processon.com/62913fa9e4b0c71a3a81421f?e=1653689786&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-WUsRKcHkAR_OnyY966rAE8wIOw=" alt="TCP/IP参考模型中的协议"></p><h4 id="1-6-5-相关习题"><a href="#1-6-5-相关习题" class="headerlink" title="1.6.5 相关习题"></a>1.6.5 相关习题</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261924466.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261924745.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261925145.png" alt=""></p><h4 id="1-6-6-相关资料链接"><a href="#1-6-6-相关资料链接" class="headerlink" title="1.6.6 相关资料链接"></a>1.6.6 相关资料链接</h4><ol><li><a href="https://www.kdocs.cn/view/l/cqzI95zH7t6v">第1章 概述（思维导图）</a></li></ol><hr><h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h2><blockquote><p>==<strong>任务：怎样在连接各种计算机的传输媒体上传输数据比特流</strong>==（使数据链路层感觉不到各种传输媒体之间的差异，只需要使用物理层服务就能传输比特流，不必关心具体怎么实现）</p></blockquote><h3 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261930116.png" alt="物理层的基本概念"></p><h3 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h3><h4 id="2-2-1-数据通信的基础知识"><a href="#2-2-1-数据通信的基础知识" class="headerlink" title="2.2.1 数据通信的基础知识"></a>2.2.1 数据通信的基础知识</h4><h4 id="2-2-2-编码与调制"><a href="#2-2-2-编码与调制" class="headerlink" title="2.2.2 编码与调制"></a>2.2.2 编码与调制</h4><ol><li><p>定义</p><ul><li>==模拟信号==：消息的参数的取值是连续的</li><li><p>==数字信号==：消息的参数的取值是离散的</p></li><li><p>==编码==：将数字数据转换成数字信号的过程</p></li><li>==调制==：将数字数据转换成模拟信号的过程</li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262020595.png" alt="编码与调制"></p><ol><li>常用编码方式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262040597.png" alt="常用编码方式"></p><ol><li>基本的调制方法</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262047837.png" alt="基本的调制方法"></p><ol><li><strong>==相位调制==</strong></li></ol><blockquote><p><strong>8相位调制</strong>表示8种状态，只需要<strong>3个比特</strong>(二进制，$2^3=8$)即可,所以<strong>1个码元可以承载3个比特</strong>，<strong>==数据传输率 = 3*波特率==</strong>，以此类推</p></blockquote><h4 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262054137.png" alt="信号失真"></p><blockquote><p>==<strong>奈式准则</strong>==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262059898.png" alt="奈式准则"></p><blockquote><p><strong>==香农公式==</strong></p><script type="math/tex; mode=display">c = W \cdot \log_{2}(1 + \frac{S}{N})</script><p>==知道信噪比(dB)求S/N假设信噪比为30dB==</p><ol><li><p>30 = 10 x lg(S/N), </p></li><li><p>lg(S/N) = 3,</p></li><li><p>S/N = 30</p></li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262102013.png" alt="香农公式"></p><blockquote><ol><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想==提高信息的传输速率==就必须采用==多元制==（更好的调制方法）和努力==提高信道中的信噪比==</li><li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地==接近香农公式给出的传输速率极限==</li></ol></blockquote><h4 id="2-2-4-传输方式"><a href="#2-2-4-传输方式" class="headerlink" title="2.2.4 传输方式"></a>2.2.4 传输方式</h4><ol><li>并行传输和串行传输</li></ol><blockquote><ul><li>并行传输速度是串行传输的==n倍==，但是<span color='rgb(1,2,3)'>成本高</span>==所以长距离传输使用串行传输==</li><li>远距离传输使用串行传输，计算机内部使用并行传输</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262005937.png" alt="并行传输和串行传输"></p><ol><li>异步传输和同步传输</li></ol><blockquote><p>异步传输==字节之间异步==，但是要添加==开始码==和==停止码==作为引导</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262010168.png" alt="异步传输和同步传输"  /></p><ol><li>单工、半双工和全双工通信</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262014965.png" alt="单工、半双工和全双工通信"></p><h3 id="2-3-物理层下的传输媒体（了解即可）"><a href="#2-3-物理层下的传输媒体（了解即可）" class="headerlink" title="2.3 物理层下的传输媒体（了解即可）"></a>2.3 物理层下的传输媒体（了解即可）</h3><h4 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h4><ol><li><strong>同轴电缆</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261938546.png" alt="同轴电缆"></p><ol><li><strong>双绞线</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261942966.png" alt="双绞线"></p><ol><li><strong>光纤</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261946552.png" alt="光纤"></p><h4 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h4><ol><li><strong>微波</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261954118.png" alt="微波"></p><ol><li>其他无线电波</li><li>红外线和可见光</li></ol><h3 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h3><blockquote><p>复用：当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术==在一条物理线路上建立多条通信信道==来共享传输媒体的带宽。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231027222210209.png" alt="信道复用" style="zoom:80%;" /></p><h4 id="2-4-1-频分复用"><a href="#2-4-1-频分复用" class="headerlink" title="2.4.1 频分复用"></a>2.4.1 频分复用</h4><blockquote><p><strong>频分复用</strong>(Frequency-division multiplexing,<code>FDM</code>):==将多路基带信号调制到不同频率载波==上，再进行==叠加形成一个复合信号==,接收端的分用器通过滤波将各路信号滤出，将合成的复合信号恢复成原始的多路信号。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310272254062.png" style="zoom: 67%;" /></p><h4 id="2-4-2-时分复用"><a href="#2-4-2-时分复用" class="headerlink" title="2.4.2 时分复用"></a>2.4.2 时分复用</h4><blockquote><p>时分复用(Time Division Multiplexing,<code>TDM</code>)：将传输线路的带宽资源==按时间轮流分配==给不同的用户，用户只能在分配的时间里使用线路传输数据（类似于==时间片轮转==）</p><p>存在的不足：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。（如果A暂时不使用信道，其他用户正常使用，时分复用还是会给A分配时间，而且这段时间内其他用户也不能使用）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310272254453.png" alt="时分复用" style="zoom: 67%;" /></p><blockquote><p>统计时分复用(statistical time division multiplexing,<code>STDM</code>):==动态地按需分配==共用信道的时隙，只将需要传送数据的终端接入共用信道，可以提高信道的利用率</p><p>帧与帧之间留有空隙用来存储用户的地址信息，因为不是固定的分配给某个用户</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310281701023.png" alt="STDM"></p><h4 id="2-4-3-波分复用"><a href="#2-4-3-波分复用" class="headerlink" title="2.4.3 波分复用"></a>2.4.3 波分复用</h4><blockquote><p>波分复用(Wavelength Division Multiplexing,<code>WDM</code>)就是==光的频分复用==。使用一根光纤来同时传输多个光载波信号。现在已能做到在一根光纤上复用几十路或更多路数的光载波信号。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310282020333.png" alt="波分复用"></p><h4 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h4><blockquote><ul><li>码分复用(Code Division Multiplexing,<code>CDM</code>)一种共享信道的方法。</li><li>由于该技术主要用于无线多址接入（本书中我们不严格区分多址与复用）人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。</li><li><p>每一个用户可以在同样的时间使用同样的频带进行通信。==各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰==。</p></li><li><p>最初用于军事，因为这种系统发送的信号==有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现==</p></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310282039043.png" alt="码分复用"></p><blockquote><p>规格化内积：将码片序列先写成+1和-1的向量</p><p>例如：==码片序列为（1101）&gt;&gt;&gt; 向量为(+1,+1,-1,+1)==</p><p>向量相乘/向量个数 = 内积</p><ul><li><strong>内积为1  &gt;&gt;&gt; 发送信号1</strong> ==发送的是自己的码片序列==</li><li><strong>内积为0  &gt;&gt;&gt; 未发送信号</strong> ==未发送数据==</li><li><strong>内积为-1 &gt;&gt;&gt; 发送信号0</strong> ==发送的是自己的码片序列的二进制反码==</li></ul></blockquote><h3 id="2-5-相关习题和资料"><a href="#2-5-相关习题和资料" class="headerlink" title="2.5 相关习题和资料"></a>2.5 相关习题和资料</h3><ol><li><a href="https://www.kdocs.cn/view/l/cfixYkxNJ7Ep">第2章 物理层 习题</a></li><li><a href="https://www.kdocs.cn/view/l/ckmnMjp5UQvK">第2章 物理层（思维导图）</a></li></ol><hr><h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h2><blockquote><p><strong>==任务：解决数据包在一个网络或一段链路上传输的问题==</strong></p></blockquote><h3 id="3-1-数据链路和帧"><a href="#3-1-数据链路和帧" class="headerlink" title="3.1 数据链路和帧"></a>3.1 数据链路和帧</h3><blockquote><ul><li>==链路==（Link）是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</li><li>==数据链路==（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把==实现这些协议的硬件和软件加到链路==上，就构成了数据链路</li><li>计算机中的==网络适配器==（俗称网卡）和其相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能</li><li>==帧==（Frame）是数据链路层的协议数据单元</li></ul></blockquote><h3 id="3-2-封装成帧和透明传输"><a href="#3-2-封装成帧和透明传输" class="headerlink" title="3.2 封装成帧和透明传输"></a>3.2 封装成帧和透明传输</h3><h4 id="3-2-1-封装成帧"><a href="#3-2-1-封装成帧" class="headerlink" title="3.2.1 封装成帧"></a>3.2.1 封装成帧</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310291347647.png" alt="封装成帧"></p><h4 id="3-2-2-透明传输问题"><a href="#3-2-2-透明传输问题" class="headerlink" title="3.2.2 透明传输问题"></a>3.2.2 透明传输问题</h4><blockquote><p><strong>==2. 透明传输问题出现原因==</strong>：上层应用交付的数据单元中可能==含有和帧定界符相同的数据==而被接收端误认为帧定界符从而导致错误。</p><p>如果不解决上述问题，则数据链路层就会==对上层交付的PDU的内容有所限制==，即==PDU中不能包含帧定界符==。显然，这样的数据链路层没有什么应用价值。</p><p>==<strong>透明传输</strong>==：数据链路层对上层交付的PDU的内容==没有任何限制==，就好像数据链路层不存在一样</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310291859630.png" alt="透明传输问题" style="zoom: 67%;" /></p><h4 id="3-2-3-解决透明传输问题"><a href="#3-2-3-解决透明传输问题" class="headerlink" title="3.2.3 解决透明传输问题"></a>3.2.3 解决透明传输问题</h4><ol><li><strong>==字符填充==(字节填充)</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231029190744213.png" alt="字符填充"></p><ol><li><strong>==零比特填充==</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231029192326597.png" alt="零比特填充"></p><h3 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h3><blockquote><ol><li><p>==<strong>比特差错</strong>==：比特在传输过程中可能会产生差错，0可能变为1,1可能变为0，这叫比特差错，也称为<strong>==误码==</strong></p></li><li><p><strong>==误码率==</strong>：传输==错误的==比特数与所传输比特==总数==的比率称为误码率</p></li><li>使用==差错检测码==来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</li></ol></blockquote><h4 id="3-3-1-使用-循环冗余检验CRC"><a href="#3-3-1-使用-循环冗余检验CRC" class="headerlink" title="3.3.1 使用==循环冗余检验CRC=="></a>3.3.1 使用==循环冗余检验<code>CRC</code>==</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101192256040.png" alt="CRC"></p><h4 id="3-3-2-示例"><a href="#3-3-2-示例" class="headerlink" title="3.3.2 示例"></a>3.3.2 示例</h4><ol><li>发送方</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101193502184.png" alt="CRC"></p><ol><li>接收方</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101193959244.png" alt=""></p><h4 id="3-3-3-总结"><a href="#3-3-3-总结" class="headerlink" title="3.3.3 总结"></a><strong>3.3.3 总结</strong></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101194313756.png" alt=""></p><h3 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h3><h4 id="3-4-1-可靠传输的概念"><a href="#3-4-1-可靠传输的概念" class="headerlink" title="3.4.1 可靠传输的概念"></a>3.4.1 可靠传输的概念</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101194720144.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101195208168.png" alt=""></p><h3 id="3-5-可靠传输的实现机制"><a href="#3-5-可靠传输的实现机制" class="headerlink" title="3.5 可靠传输的实现机制"></a>3.5 可靠传输的实现机制</h3><h4 id="3-5-1-停止-等待协议-SW"><a href="#3-5-1-停止-等待协议-SW" class="headerlink" title="3.5.1 停止-等待协议(SW)"></a>3.5.1 停止-等待协议(SW)</h4><ol><li>基本原理</li></ol><blockquote><p>发送一个数据分组<code>DATA0</code>然后等待接收方发来确认信息<code>ACK0</code>后再传输下一个数据分组<code>DATA1</code> ，如果==超时未接收到==接收方发送的确认信息<code>ACK0</code>或者接==收到否认信息==<code>NAK</code>就重新发送上一个分组数据分组,数据分组和确认信息的编号都是用来区分和上一个分组或信息是否相同</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101204223808.png" alt="SW"></p><ol><li>停止等待协议的信道利用率</li></ol><blockquote><script type="math/tex; mode=display">利用率 = \frac{数据发送时延}{数据发送时延+2个传播时延+确认信息发送时延}</script><p>确认信息的发送时延一般忽略不计</p><p><strong>总结：当往返时间远大于数据帧的发送时延时，信道利用率很低，如果出现超时重传，信道利用率更低</strong>（卫星链路）</p></blockquote><h4 id="3-5-2-回退N帧协议（GBN）"><a href="#3-5-2-回退N帧协议（GBN）" class="headerlink" title="3.5.2 回退N帧协议（GBN）"></a>3.5.2 回退N帧协议（GBN）</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101215803331.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101211215263.png" alt=""></p><h4 id="3-5-3-选择重传协议（SR）"><a href="#3-5-3-选择重传协议（SR）" class="headerlink" title="3.5.3 选择重传协议（SR）"></a>3.5.3 选择重传协议（SR）</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101212500499.png" alt=""></p><h3 id="3-6-点对点协议-PPP"><a href="#3-6-点对点协议-PPP" class="headerlink" title="3.6 点对点协议(PPP)"></a>3.6 点对点协议(<code>PPP</code>)</h3><ol><li>概述</li></ol><blockquote><p>==点对点协议==（Point-to-Point Protocol，PPP）是目前使用最广泛的点对点数据链路层协议</p><ol><li>==网络控制协议NCPs==</li><li>封装成帧</li><li>==链路控制协议LCP==</li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101213541707.png" alt="PPP"></p><ol><li>PPP的==帧格式==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101221019454.png" alt=""></p><ol><li>PPP的==透明传输==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103154439848.png" alt=""></p><ol><li>PPP的==状态图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101221315932.png" alt=""></p><h3 id="3-7-媒体接入控制问题"><a href="#3-7-媒体接入控制问题" class="headerlink" title="3.7 媒体接入控制问题"></a>3.7 媒体接入控制问题</h3><h4 id="3-7-1-媒体接入控制-多址接入-问题"><a href="#3-7-1-媒体接入控制-多址接入-问题" class="headerlink" title="3.7.1 媒体接入控制/多址接入 问题"></a>3.7.1 媒体接入控制/多址接入 问题</h4><blockquote><p>如何协调多个发送站点和接收站点对一个共享传输媒体的占用（==多个媒体同时发送信号导致冲突的问题==）</p></blockquote><h4 id="3-7-2-静态划分信道"><a href="#3-7-2-静态划分信道" class="headerlink" title="3.7.2 静态划分信道"></a>3.7.2 静态划分信道</h4><blockquote><ul><li>频分多址</li><li>时分多址</li><li>码分多址</li></ul><p>==<strong>这种固定划分信道的方法非常不灵活，通常在物理层中使用，而不是数据链路层</strong>==</p></blockquote><h4 id="3-7-3-CSMA-CD协议"><a href="#3-7-3-CSMA-CD协议" class="headerlink" title="3.7.3 CSMA/CD协议"></a>3.7.3 <code>CSMA/CD</code>协议</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103161532858.png" alt=""></p><ol><li>==帧发送流程图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162311360.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163826951.png" alt=""></p><ol><li><strong>==争用期==  2τ ，即端到端传播时延的2倍</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162720907.png" alt=""></p><ol><li>==最小帧长==<br>&gt;<blockquote><p>   <strong>最小帧长 = 争用期 x 数据传输速率</strong></p><script type="math/tex; mode=display">   l = 2τ * 数据传输速率</script></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162936995.png" alt=""></p><ol><li>==动态退避==：发生碰撞后进行重传，随着重传次数增加，退避时间也会逐渐增加，减小了碰撞的概率</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163318636.png" alt="image-20231103163318636"></p><ol><li>==帧接收流程图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163952585.png" alt=""></p><h4 id="3-7-4-CSMA-CA协议"><a href="#3-7-4-CSMA-CA协议" class="headerlink" title="3.7.4 CSMA/CA协议"></a>3.7.4 <code>CSMA/CA</code>协议</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202311062053040.png" alt=""></p><h3 id="3-8-MAC、IP地址、ARP协议"><a href="#3-8-MAC、IP地址、ARP协议" class="headerlink" title="3.8 MAC、IP地址、ARP协议"></a>3.8 <code>MAC</code>、<code>IP</code>地址、<code>ARP</code>协议</h3><h4 id="3-8-1-MAC地址"><a href="#3-8-1-MAC地址" class="headerlink" title="3.8.1 MAC地址"></a>3.8.1 <code>MAC</code>地址</h4><ol><li><strong>MAC地址</strong>是==对网络上各接口的唯一标识==，而不是对网络上各设备的唯一标识（路由器有多个接口，所以有多个MAC地址）</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109211711863.png" alt=""></p><ol><li>MAC地址格式<br>&gt;<blockquote><p>广播MAC地址为<strong>==FF-FF-FF-FF-FF-FF==</strong></p></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109212131157.png" alt=""></p><ol><li>MAC帧有三种：==单播、广播、多播==</li></ol><blockquote><p>单播帧：==一对一==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109213737953.png" alt=""></p><blockquote><p>广播帧：==一对全体==</p><p>广播地址：<code>FF-FF-FF-FF-FF-FF</code></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109214347270.png" alt=""></p><blockquote><p>多播帧：==一对多==</p><p>多播地址：==第二个数是奇数代表是多播地址==</p></blockquote><p><img src="https://cdn.processon.com/62942804e4b055af8b78ba06?e=1653880340&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:UhUsF4fqZnqyZWpsN-hM0r93O4Y=" alt=""></p><h4 id="3-8-2-IP地址"><a href="#3-8-2-IP地址" class="headerlink" title="3.8.2 IP地址"></a>3.8.2 <code>IP</code>地址</h4><blockquote><p>（网络层再详细介绍）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109220004217.png" alt=""></p><h4 id="3-8-3-ARP协议"><a href="#3-8-3-ARP协议" class="headerlink" title="3.8.3 ARP协议"></a>3.8.3 <code>ARP</code>协议</h4><blockquote><p>主机中保存了一个高速缓存表，==记录了IP和MAC的对应关系==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221234731.png" style="zoom: 67%;" /></p><blockquote><p>ARP协议动态获取MAC地址</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221003126.png" alt=""></p><blockquote><p><strong>总结：<code>ARP</code>协议只能逐链路（相邻）使用，不能跨网络使用</strong></p></blockquote><h3 id="3-9-集线器和交换机的区别"><a href="#3-9-集线器和交换机的区别" class="headerlink" title="3.9 集线器和交换机的区别"></a>3.9 集线器和交换机的区别</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109222104719.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109222736241.png" alt=""></p><h3 id="3-10-透明网桥的生成树协议STP"><a href="#3-10-透明网桥的生成树协议STP" class="headerlink" title="3.10 透明网桥的生成树协议STP"></a>3.10 透明网桥的生成树协议<code>STP</code></h3><blockquote><ul><li>为了提高以太网的==可靠性==，有时需要在两个以太网之间使用多个透明网桥来提供==冗余链路==</li><li>为了避免广播帧在环路中永久兜圈，透明网桥使用生成树协议<code>Spanning Tree Protocol</code>，可以在增加冗余链路提高网络可靠性的同时，又避免环路带来的问题</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231111200010935.png" alt=""></p><h3 id="3-11-虚拟局域网VLAN"><a href="#3-11-虚拟局域网VLAN" class="headerlink" title="3.11 虚拟局域网VLAN"></a>3.11 虚拟局域网<code>VLAN</code></h3><blockquote><p>虚拟局域网（<code>Virtual Local Area Network</code>，VLAN）是一种将局域网内的站点划分成与物理位置无关的逻辑组的技术，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求</p><p>==广播风暴==：<strong>广播风暴会浪费网络资源和各主机的CPU资源</strong></p><ul><li>可以使用路由器切割广播域，防止广播风暴，但是==成本较高==</li><li><p>使用vlan技术划分广播域</p></li><li><p><code>A</code>发送广播帧，<code>Access</code>接口接收并<code>打标签</code>,<code>PVID</code>和<code>VID</code>相同的Access端口可以接收该帧，进行==去标签转发==</p></li><li><p><code>Trunk</code>端口的<code>PVID</code>如果等于该帧的<code>VID</code>，也会==先去标签转发，然后再打标签==，否则直接转发</p></li><li><strong>Trunk端口是连接两个交换机的</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231111193532792.png" alt=""></p><h3 id="4-思维导图和习题"><a href="#4-思维导图和习题" class="headerlink" title="4. 思维导图和习题"></a>4. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgV0rfS0qZEA">第3章 数据链路层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ciOEeLV6ffuJ">第3章 数据链路层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cnRBS8NFgTll">第3章 数据链路层（思维导图）-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cl60fYfO1qZe">第3章 数据链路层 习题（第1部分）</a></p><p><a href="https://www.kdocs.cn/view/l/cenjHDfYLe95">第3章 数据链路层 习题（第2部分）</a></p><hr><h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote><p>网络层的主要任务：==将分组从源主机经过多个网络和多段链路传输到目的主机==，可以将该任务划分为==分组转发==和==路由选择==两种重要的功能</p></blockquote><h3 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h3><h4 id="4-2-1-面向连接的虚电路服务"><a href="#4-2-1-面向连接的虚电路服务" class="headerlink" title="4.2.1 面向连接的虚电路服务"></a>4.2.1 面向连接的虚电路服务</h4><blockquote><ul><li><strong>虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而==不是真正建立了一条物理连接==</strong></li><li><strong>分组的首部仅在连接建立阶段使用完整的目的主机地址，之后每个分组的首部只需要携带一条==虚电路编号==即可</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112213851481.png" alt=""></p><h4 id="4-2-2-无连接的数据报服务"><a href="#4-2-2-无连接的数据报服务" class="headerlink" title="4.2.2 无连接的数据报服务"></a>4.2.2 无连接的数据报服务</h4><blockquote><ul><li><code>TCP/IP</code>使用的就是这种==简单灵活的==、==无连接的==、==不可靠的==数据报服务</li><li><strong>核心思想：==可靠通信应由用户主机来保证==</strong></li><li><strong>由于网络自身不提供端到端的可靠传输服务，这就使得网络中的路由器可以做得比较简单，==大大降低了网络造价==</strong></li><li><strong>这种设计思想的==运行方式灵活==、能够适应多种应用。因特网能够发展到今日的规模，充分证明了当初采取这种设计思想的==正确性==</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112220730923.png" alt=""></p><h4 id="4-2-3-IP地址"><a href="#4-2-3-IP地址" class="headerlink" title="4.2.3 IP地址"></a>4.2.3 IP地址</h4><blockquote><p><strong>概念</strong></p></blockquote><ul><li>网际协议（<code>Internet Protocol</code>，<code>IP</code>）是<code>TCP/IP</code>体系结构网际层中的核心协议</li><li><code>IPv4</code>地址就是给因特网(Internet)上的每一台主机（或路由器）的每一个==接口==分配一个在全世界范围内是唯一的==32比特==的标识符</li></ul><h4 id="4-2-4-分类编址的IP"><a href="#4-2-4-分类编址的IP" class="headerlink" title="4.2.4 分类编址的IP"></a>4.2.4 分类编址的<code>IP</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112223308951.png" alt=""></p><h4 id="4-2-5-划分子网的IP"><a href="#4-2-5-划分子网的IP" class="headerlink" title="4.2.5 划分子网的IP"></a>4.2.5 划分子网的<code>IP</code></h4><blockquote><p><strong>分类编址方法不够灵活且容易造成==大量地址浪费==，划分子网编址方法对其进行改进（“打补丁”）</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113184551320.png" style="zoom:80%;" /></p><blockquote><p>划分子网案例</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113185650959.png" style="zoom:67%;" /></p><h4 id="4-2-6-无分类编制-的IP"><a href="#4-2-6-无分类编制-的IP" class="headerlink" title="4.2.6 ==无分类编制==的IP"></a>4.2.6 ==无分类编制==的<code>IP</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113190642722.png" style="zoom:67%;" /></p><blockquote><p>==无分类域间路由选择==（<code>C</code>lassless <code>I</code>nter-<code>D</code>omain <code>R</code>outing，<code>CIDR</code> ）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113190939322.png" style="zoom:67%;" /></p><blockquote><p><strong>练习</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113193113576.png" alt=""></p><blockquote><p><strong>==路由聚合==</strong></p><p><strong>找出共同前缀，其余位取0</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113193616181.png" style="zoom:67%;" /></p><h3 id="4-3-IP数据报的发送和转发过程"><a href="#4-3-IP数据报的发送和转发过程" class="headerlink" title="4.3 IP数据报的发送和转发过程"></a>4.3 IP数据报的发送和转发过程</h3><blockquote><p><strong>IP数据报的==发送==和==转发==过程</strong></p><ul><li><p><strong>主机发送IP数据报</strong></p><ul><li>==判断目的主机是否与自己在同一个网络：==<ul><li>若在同一个网络，则属于==直接交付==，直接发送给目的主机</li><li>若不在同一个网络，则属于==间接交付==，传输给主机所在网络的默认网关(路由器)，==由默认网关帮忙转发==)</li></ul></li></ul></li><li><p><strong>路由器转发IP数据报</strong></p><ul><li>==检查IP数据报首部是否出错：==<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>==根据IP数据报的目的地址在路由表中查找匹配的条目：==<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该IP数据报并通告源主机；</li></ul></li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/010ac0446c7c01e405dd1b7baf38d50a.png" alt=""></p><blockquote><p>==路由器不转发广播IP数据报==，即路由器隔离广播域，如果因特网中数量巨大的路由器收到广播IP数据报后都进行转发，则会==造成巨大的广播风暴，严重浪费因特网资源==</p><ul><li>==中继器==和==集线器==工作在==物理层==，<strong>既不隔离冲突域也不隔离广播域</strong></li><li>==网桥==和==交换机==(多端口网桥)工作在==数据链路层==，<strong>可以隔离冲突域，不能隔离广播域</strong></li><li>==路由器==工作在==网络层==，<strong>既隔离冲突域，也隔离广播域</strong></li></ul></blockquote><h3 id="4-4-静态路由配置"><a href="#4-4-静态路由配置" class="headerlink" title="4.4 静态路由配置"></a>4.4 静态路由配置</h3><h4 id="1-静态路由的配置"><a href="#1-静态路由的配置" class="headerlink" title="1. 静态路由的配置"></a>1. 静态路由的配置</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231117222851885.png" style="zoom:67%;" /></p><h4 id="2-默认路由"><a href="#2-默认路由" class="headerlink" title="2. 默认路由"></a>2. 默认路由</h4><ol><li><p>默认路由：默认路由条目中的目的网络<code>0.0.0.0/0</code>，其中<code>0.0.0.0</code>表示任意网络，而网络前缀“/0”（相应的地址掩码为<code>0.0.0.0</code>）是==最短的网络前缀==</p></li><li><p>特定主机路由：特定主机路由条目中的目的网络<code>192.168.2.1/32</code>，其中<code>192.168.2.1</code>是特定主机的IP地址，而网络前缀“/32”（相应地址掩码为<code>255.255.255.255</code>）是==最长的网络前缀==</p></li><li>路由器在查找转发表转发IP数据报时，遵循“最长前缀匹配”的原则，因此==默认路由匹配优先级最低，特定主机路由条目的匹配优先级最高==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231117223841323.png" style="zoom:67%;" /></p><h4 id="3-路由环路"><a href="#3-路由环路" class="headerlink" title="3. 路由环路"></a>3. 路由环路</h4><ul><li>错误配置静态路由有可能导致==路由环路==问题</li><li>为了==防止IP数据报在环路中永久兜圈==，在IP数据报首部设有==生存时间TTL==，TTL为0时会被丢弃</li></ul><p><strong>路由环路问题产生原因：</strong></p><ol><li>路由配置错误</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118125828914.png" style="zoom:67%;" /></p><ol><li>聚合了不存在的IP地址</li></ol><blockquote><p>需要给不存在的IP地址配置黑洞路由，防止IP数据报转发到其他路由器</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118133214440.png" style="zoom:67%;" /></p><ol><li>网络故障</li></ol><blockquote><p>可以在网络发生故障时==添加一条针对该IP的黑洞路由==，待网络正常后又将其设置为失效状态</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118134111043.png" style="zoom: 67%;" /></p><h3 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5 路由选择协议"></a>4.5 路由选择协议</h3><ol><li>路由选择分为两类</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">==静态路由选择==</th><th style="text-align:left">==动态路由选择==</th></tr></thead><tbody><tr><td style="text-align:left">采用==人工配置==的方式给路由器添加网络路由、默认路由和特定主机路由等路由条目</td><td style="text-align:left">路由器通过路由选择协议==自动获取==路由信息</td></tr><tr><td style="text-align:left">静态路由选择==简单、开销小==，但==不能及时适应网络状态（流量、拓扑等）的变化==</td><td style="text-align:left">动态路由选择比较==复杂、开销比较大==，但==能较好地适应网络状态的变化==</td></tr><tr><td style="text-align:left">静态路由选择一般只在==小规模网络==中采用</td><td style="text-align:left">动态路由选择适用于==大规模网络==</td></tr></tbody></table></div><ol><li>因特网采用==分层次==的路由选择协议</li></ol><p>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：</p><ul><li>自适应：因特网采用==动态路由==选择，能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互，==共同完成路由信息的获取和更新==。</li><li>分层次：将整个因特网划分为许多较小的==自治系统==(<code>Autonomous System,AS</code>)，在自治系统内部和外部采用不同类别的路由选择协议，分别进行路由选择</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118150928383.png" style="zoom:67%;" /></p><h3 id="4-6-RIP"><a href="#4-6-RIP" class="headerlink" title="4.6 RIP"></a>4.6 <code>RIP</code></h3><p>路由信息协议（<code>Routing Information Protocol，RIP</code>）是内部网关协议中最先得到广泛使用的协议之一</p><ol><li>相关概念</li></ol><ul><li><p>RIP使用==跳数==（<code>Hop Count</code>）作为度量（<code>Metric</code>）来衡量到达目的网络的距离</p><ul><li><p>RIP将==路由器到直连网络的距离定义为1==</p></li><li><p>RIP将路由器到非直连网络的距离定义为==所经过的路由器数加1==</p></li><li>RIP允许一条路径最多只能包含15个路由器，==距离等于16时相当于不可达==,因此RIP只适用于==小型互<br>联网==</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118140619521.png" style="zoom: 50%;" /></p><ol><li><p>RIP认为好的路由就是“距离短”的路由，也就是所==通过路由器数量最少的路由==,和传输速率和物理距离等无关</p></li><li><p>RIP的==3个重要特点==</p></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118141136250.png" style="zoom: 67%;" /></p><ol><li><p><strong>==RIP的工作原理==</strong></p><ol><li>基本流程</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118141750507.png" style="zoom:67%;" /></p><ol><li><strong>==RIP路由条目的更新规则==</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118142447662.png" style="zoom:80%;" /></p><ol><li><p>==<strong>坏消息传播的慢</strong>==</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118220443883.png" alt=""></p></li></ol></li><li><p>RIP的优缺点</p></li></ol><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>实现==简单==，路由器==开销小==</td><td>RIP限制了==最大RIP距离为<code>15</code>==这就限制了使用RIP的自治系统AS的规模</td></tr><tr><td>如果一个路由器发现了RIP距离更短的路由，那么这种更新信息就传播得很快，即“==好消息传播得快==”</td><td>相邻路由器之间交换的路由信息是路由器中的完整路由表，因而==随着网络规模的扩大，开销也随之增大==</td></tr><tr><td></td><td>“==<strong>坏消息传播得慢</strong>==”，使更新过程的收敛时间过长。因此，对于规模较大的自治系统AS，应当使用<code>OSPF</code>协议</td></tr></tbody></table></div><h3 id="4-7-OSPF"><a href="#4-7-OSPF" class="headerlink" title="4.7 OSPF"></a>4.7 <code>OSPF</code></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><p>开放最短路径优先（<code>Open Shortest Path First，OSPF</code>）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的</p><ul><li>“==开放==”表明<code>OSPF</code>协议不是受某一厂商控制，而是公开发表的</li><li>“==最短路径优先==”是因为使用了Dijkstra提出的==最短路径算法==(<code>Shortest Path First,SPF</code>)</li></ul></blockquote><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><blockquote><ul><li><code>OSPF</code>是==基于<strong>链路状态</strong>==的，而不像<code>RIP</code>是基于距离向量的</li><li><code>OSPF</code>基于链路状态并采用最短路径算法计算路由，==从算法上保证了不会产生路由环路==</li><li><code>OSPF</code>==不限制网络规模，更新效率高，收敛速度快==</li></ul></blockquote><h4 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3. 相关概念"></a>3. 相关概念</h4><ol><li><p>链路状态（<code>Link State，LS</code>）是指本路由器都和哪些路由器相邻，以及相应链路的“代价（cost）”，类似RIP中的距离</p><blockquote><p>“代价”用来表示费用、距离、时延和带宽等，这些都由网络管理人员来决定</p></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118223059765.png" style="zoom:80%;" alt='举例-思科路由器的代价计算标准' /></p><ol><li><strong>==<code>OSPF</code>路由器邻居关系的建立和维护==</strong><ul><li><strong>如果在死亡倒计时为0时还未收到邻居的问候分组，则认为该邻居不可达，</strong></li><li><strong>在接受到邻居的问候分组后，刷新死亡倒计时为40s</strong></li><li><strong>路由器每10s会向邻居发送问候分组</strong></li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118223958856.png" style="zoom:67%;" /></p><ol><li>==<strong>链路状态数据库</strong>==(<code>Link State Database，LSDB</code>)</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118224728007.png" alt=""></p><blockquote><p>使用<code>OSPF</code>的各路由器，基于链路状态数据库LSDB进行最短路径优先计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表(==根据链路状态数据库得出全局带权有向图，使用Dijkstra算法得出个路由器的最短路径==)</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118225157334.png" alt=""></p><ol><li><strong><code>OSPF</code>的五种分组类型</strong><ul><li>类型1，==问候(<code>Hello</code>)分组==：用来发现和维护邻居路由器的可达性。</li><li>类型2，==数据库描述(<code>Database Description</code>)分组==：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>类型3，==链路状态请求(<code>Link State Request</code>)分组==：向邻居路由器请求发送某些链路状态项目的详细信息。</li><li>类型4，==链路状态更新(<code>Link State Update</code>)分组==：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</li><li>类型5，==链路状态确认(<code>Link State Acknowledgment</code>)分组==：这是对链路状态更新分组的确认分组。</li></ul></li></ol><h4 id="4-基本工作原理"><a href="#4-基本工作原理" class="headerlink" title="4. 基本工作原理"></a>4. 基本工作原理</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119152547862.png" style="zoom:67%;" /></p><blockquote><p>采用划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做能==使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模更大的自治系统AS==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119152848527.png" style="zoom:67%;" /></p><h3 id="4-8-BGP"><a href="#4-8-BGP" class="headerlink" title="4.8  BGP"></a>4.8  <code>BGP</code></h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><ul><li><strong>边界网关协议</strong>（<code>Border Gateway Protocol，BGP</code>）属于==外部网关协议==<code>EGP</code>这个类别，用于自治系统<code>AS</code>之间的路由选择协议</li><li>由于在不同AS内度量路由的“代价”（距离、带宽、费用等）可能不同，因此==对于AS之间的路由选择，使用统一的“代价”作为度量来寻找最佳路由是不行的==</li><li>AS之间的路由选择还必须考虑相关策略（政治、经济、安全等）</li></ul><p><strong>总结：<code>BGP</code>只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119154933166.png" style="zoom: 80%;" /></p><blockquote><ul><li><p>在配置BGP时，每个AS的管理员要选择至少一个路由器作为该AS的“==BGP发言人==”</p></li><li><p>一般来说，两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是==BGP边界路由器==</p></li><li>使用<code>TCP</code>连接交换路由信息的两个BGP发言人，彼此称为对方的==邻站==（neighbor）或==对等站==（peer）</li><li>BGP发言人除了运行BGP协议外，还必须运行自己所在AS所使用的内部网关协议IGP，例如RIP或OSPF</li><li>BGP发言人交换网络可达性的信息，也就是==要到达某个网络所要经过的一系列自治系统==</li><li>当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就==根据所采用的策略==，从收到的路由信息中==找出到达各自治系统的较好的路由==，也就是==构造出树形结构且不存在环路的自治系统连通图==</li></ul></blockquote><h4 id="2-四种报文"><a href="#2-四种报文" class="headerlink" title="2. 四种报文"></a>2. 四种报文</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119155610676.png"  /></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119160021206.png"  /></p><h3 id="4-9-IPv4数据报的首部格式"><a href="#4-9-IPv4数据报的首部格式" class="headerlink" title="4.9 IPv4数据报的首部格式"></a>4.9 IPv4数据报的首部格式</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119161128658.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:center">版本</th><th>长度为==4==个比特，用来表示IP协议的版本，==通信双方使用的IP协议的版本必须一致==，目前广泛使用的IP协议的版本号为4（即IPv4）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>首部长度</strong></td><td>长度为==4==个比特，该字段的取值==以4字节为单位==，用来表示IPV4数据报的首部长度。<br/>最小取值为二进制的0101，即十进制的5，再乘以4字节单位，==表示IPv4数据报首部只有20字节固定部分==<br />最大取值为二进制的1111，即十进制的15，再乘以4字节单位，==表示IPV4数据报首部包含20字节固定部分和最大40字节可变部分==</td></tr><tr><td style="text-align:center"><strong>总长度</strong></td><td>长度为==16==个比特，该字段的取值==以字节为单位==，用来==表示IPv4数据报的长度==（==首部长度+数据载荷长度==）<br />最大取值为二进制的16个比特1，即十进制的65535（很少传输这么长的IPv4数据报）</td></tr><tr><td style="text-align:center"><strong>标识</strong></td><td>长度为==16==个比特，==属于同一个IPv4数据报的各分片数据报应该具有相同的标识==</td></tr><tr><td style="text-align:center"><strong>标志</strong></td><td>最低位(<code>More Fragment,MF</code>)<br/>    MF=1表示本分片后面还有分片<br/>    MF=0表示本分片后面没有分片<br/>中间位(<code>Don&#39;t Fragment,DF</code>)<br/>    DF=1表示不允许分片<br/>    DF=0表示允许分片<br/>最高位为保留位，必须设置为0</td></tr><tr><td style="text-align:center"><strong>片偏移</strong></td><td>长度为==16==个比特，该字段的取值，==以8字节为单位==，用来指出分片IPv4数据报的==数据载荷偏移其在原IPv4数据报的位置有多远，只能为整数，否则必须调整前一个分片长度==</td></tr><tr><td style="text-align:center"><strong>生存时间</strong></td><td>长度为==8==个比特，最大取值为二进制的11111111，即十进制的255。该字段的取值最初以秒为单位。因此，IPv4数据报的最大生存时间最初为255秒。路由器转发IPv4数据报时，将其首部中该字段的值减去该数据报在路由器上所耗费的时间，若结果不为0就转发，否则就丢弃<br />生存时间字段==后来改为以“跳数”为单位，路由器收到待转发的IPv4数据报时，将其首部中的该字段的值减1，若结果不为0就转发，否则就丢弃==</td></tr><tr><td style="text-align:center"><strong>协议</strong></td><td>长度为8个比特，用来==指明IPv4数据报的数据载荷是何种协议数据单元PDU==<br /><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119165547509.png" alt=""></td></tr><tr><td style="text-align:center"><strong>首部检验和</strong></td><td>长度为==16==个比特，用于==检测IPv4数据报在传输过程中其首部是否出现了差错==<br />IPv4数据报==每经过一个路由器==，其首部中的某些字段的值（例如生存时间TTL、标志以及片偏移等）都可能发生变化，因此路由器都要==重新计算一下首部检验和==</td></tr><tr><td style="text-align:center"><strong>源IP地址和目的IP地址</strong></td><td>长度都为==32==个比特，用来填写发送（接收）IPv4数据报的源（目的）主机的IPv4地址</td></tr></tbody></table></div><blockquote><p><code>MTU</code>：==最大传送单元，超过最大传送单元的长度的IP数据报必须分片==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119164911210.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119171554203.png" alt=""></p><h3 id="4-10-ICMP"><a href="#4-10-ICMP" class="headerlink" title="4.10 ICMP"></a>4.10 <code>ICMP</code></h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><ul><li>为了更有效地转发IP数据报以及提高IP数据报交付成功的机会，TCP/IP体系结构的网际层使用了网际控制报文协议（<code>Internet Control Message Protocol，ICMP</code>）</li><li>主机或路由器使用ICMP来发送==差错报告报文==和==询问报文==</li><li>ICMP报文被==封装在IP数据报中作为数据载荷==发送</li></ul></blockquote><h4 id="2-ICMP报文数据类型"><a href="#2-ICMP报文数据类型" class="headerlink" title="2. ICMP报文数据类型"></a>2. ICMP报文数据类型</h4><ul><li><p><strong>差错报告报文</strong>：用来==向主机或路由器报告差错情况==</p><ul><li><p><strong>终点不可达</strong>：==当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文==，具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119222854859.png" alt=""></p></li><li><p><strong>源点抑制</strong>：==当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文==，使源点知道应当把IP数据报的发送速率放慢</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119222400135.png"  /></p></li><li><p><strong>超时</strong>：</p><ul><li>当路由器收到一个目的IP地址不是自己的IP数据报时，会将其首部中生存时间TTL字段的值减1。若结果不为0，则路由器将该数据报转发出去；==若结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文==</li><li>另外，当终点在预先规定的时间内==未能收到一个数据报的全部数据报分片==时，就把已收到的数据报片都==丢弃==，也会==向源点发送时间超过（超时）报文==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120194354557.png"  /></p></li><li><p><strong>参数问题</strong>：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段的值发现首部在传送过程中出现了误码，就丢弃该数据报，并向发送该数据报的源点发送参数问题报文</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120194840526.png" alt=""></p></li><li><p><strong>改变路由（重定向）</strong>：路由器把==改变路由报文==发送给主机，让主机知道下次==应将IP数据报发送给另外的路由器==，这样可以==通过更好的路由到达目的主机==</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120195049808.png" alt=""></p></li></ul></li><li><p><strong>以下情况==不应发送ICMP差错报告报文==</strong>：</p><ul><li>对==ICMP差错报告报文==不再发送ICMP差错报告报文</li><li>对第一个分片的IP数据报片的所有==后续数据报片==都不发送ICMP差错报告报文</li><li>对==具有多播地址的IP数据报==都不发送ICMP差错报告报文</li><li>对具有==特殊地址==（例如<code>127.0.0.0</code>或<code>0.0.0.0</code>）的IP数据报不发送CMP差错报告报文。</li></ul></li><li><p><strong>询问报文</strong>：用来==向主机或路由器询问情况==</p><ul><li><p><strong>回送请求和回答</strong>：</p><p>由主机或路由器向一个特定的目的主机或路由器发出。收到此报文的主机或路由器必须给发送该报文的源主机或路由器发送ICMP回送回答报文。这种询问报文==用来测试目的站是否可达以及了解其有关状态==</p></li><li><p><strong>时间戳请求和回答</strong>：</p><p>用来请求某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32比特的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。这种询问报文==用来进行时钟同步和测量时间==</p></li></ul></li></ul><h4 id="3-ICMP的典型应用"><a href="#3-ICMP的典型应用" class="headerlink" title="3. ICMP的典型应用"></a>3. ICMP的典型应用</h4><h5 id="1-PING"><a href="#1-PING" class="headerlink" title="1. PING"></a>1. <code>PING</code></h5><blockquote><p>分组网间探测（Packet InterNet Groper，<code>PING</code>）</p><p>在命令行中==使用ping命令用来测试主机或路由器之间的连通性==</p><ul><li>PING是TCP/IP体系结构的==应用层直接使用网际层ICMP==的一个例子，它并不使用运输层的TCP或UDP</li><li>PING应用所使用的ICMP报文类型为==回送请求和回答==</li></ul></blockquote><h5 id="2-traceroute"><a href="#2-traceroute" class="headerlink" title="2. traceroute"></a>2. <code>traceroute</code></h5><blockquote><p>跟踪路由应用traceroute，==用于探测IP数据报从源主机到达目的主机要经过哪些路由器==</p><p>在不同操作系统中，traceroute应用的命令和实现机制有所不同：</p><ul><li>在UNIX版本中，具体命令为<code>traceroute</code>，其==在运输层使用UDP协议==，==在网络层使用ICMP报文类型只有差错报告报文==</li><li>在Windows版本中，具体命令为<code>tracert</code>，其==应用层直接使用网际层的ICMP协议，所使用的ICMP报文类型有回送请求和回答报文以及差错报告报文==</li></ul><p><strong>==原理==</strong>：==设置IP数据报TTL为1，经过第一个路由器时，TTL减为0，IP数据报被丢弃，路由器向源主机发送超时差错报告报文，这样就知道了经过的第一个路由器的IP地址，以此类推依次设置TTL为2,3,4，……，直到接收到目的主机的回送请求回答报文==</p></blockquote><h3 id="4-11-VPN"><a href="#4-11-VPN" class="headerlink" title="4.11 VPN"></a>4.11 <code>VPN</code></h3><blockquote><p>==虚拟专用网==(<code>Virtual Private Network,VPN</code>)：<strong>利用公用的==因特网==作为本机构各==专用网之间的通信载体==，这样形成的网络又称为虚拟专用网</strong></p></blockquote><p><strong>专用地址</strong>：</p><ul><li><code>10.0.0.0-10.255.255.255</code>(CIDR地址块10/8)</li><li><code>172.16.0.0-172.31.255.255</code>(ClDR地址块172.16/12)</li><li><code>192.168.0.0-192.168.255.255</code>(CIDR地址块192.168/16)</li></ul><blockquote><p>很显然，全世界可能有很多不同机构的专用网具有相同的专用IP地址，但这并不会引起麻烦，因为==这些专用地址仅在机构内部使用==</p><p><strong>注意</strong>：在因特网中的所有路由器，==对目的地址是专用地址的IP数据报一律不进行转发==，这需要由因特网服务提供者ISP对其拥有的因特网路由器进行设置来实现（需要自己对路由器额外配置）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120204244180.png" alt=""></p><h3 id="4-12-NAT"><a href="#4-12-NAT" class="headerlink" title="4.12 NAT"></a>4.12 <code>NAT</code></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><ul><li><p><strong>背景</strong>：尽管因特网采用了无分类编址方法来减缓IPv4地址空间耗尽的速度，但由于==因特网用户数量的急剧增长==，特别是==大量小型办公室==和==家庭网络==接入因特网的需求不断增加，I==Pv4地址空间即将耗尽的危险然仍没有解除==（实际上，因特网号码分配管理局IANN于2011年2月3日宣布，IPv4地址已经分配完毕）</p></li><li><p><strong>==网络地址转换==</strong>（<code>Network Address Translation，NAT</code>）技术于1994年被提出，==用来缓解IPv4地址空间即将耗尽的问题==</p><ul><li>NAT能==使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源==</li><li>这种方法需要在专用网络连接到因特网的路由器上==安装NAT软件==。装有NAT软件的路由器称为==NAT路由器==，它==至少要有一个有效的外部全球地址IPG==。这样，所有使用内部专用地址的主机在和外部因特网通信时，都要==在NAT路由器上将其内部专用地址转换成IPG==</li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120210441321.png" alt=""></p><h4 id="2-NAPT"><a href="#2-NAPT" class="headerlink" title="2. NAPT"></a>2. <code>NAPT</code></h4><blockquote><p><strong>==网络地址与端口号转换方法==</strong>:将NAT和运输层端口号结合使用，称为网络地址与端口号转换（<code>Network Address and Port Translation，NAPT</code>）</p><ul><li>由于目前绝大多数基于TCP/IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，==为了更加有效地利用NAT路由器中的全球IP地址==，现在常==将NAT转换和运输层端口号结合使用==<ul><li>这样就可以使内部专用网中使用专用地址的==大量主机，共用NAT路由器上的1个全球IP地址==，因而可以同时与因特网中的不同主机进行通信</li><li>现在很多家用路由器将家中各种智能设备（手机、平板、笔记本电脑、台式电脑、物联网设备等）接入因特网，这种路由器实际上就是一个==NAPT路由器==，但往往并不运行路由选择协议</li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120211722902.png" alt=""></p><blockquote><p>==由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护==</p></blockquote><h3 id="5-思维导图和习题"><a href="#5-思维导图和习题" class="headerlink" title="5. 思维导图和习题"></a>5. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/ceLxGZ0br8Gy">第4章 网络层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cu2tek1gzIPq">第4章 网络层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cjXVALCjxr0X">第4章 网络层（思维导图）-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cbSlBNdR8CSr">第4章 网络层（思维导图）-4 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ccu9ATsOpoZf">第4章 网络层 习题(第1部分)</a></p><p><a href="https://www.kdocs.cn/view/l/cqBldcygudFg">第4章 网络层 习题(第2部分)</a></p><hr><h2 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>第2~4章依次介绍了计算机网络体系结构中的==物理层==、==数据链路层==和==网络层==，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了==主机到主机的通信==</li><li>然而在计算机网络中实际进行==通信的真正实体，是位于通信两端主机中的进程==</li><li>如何==<strong>为运行在不同主机上的应用进程提供直接的逻辑通信服务</strong>==，就是==运输层的主要任务==，运输层协议又称为端到端协议</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124190055469.png" alt=""></p><h3 id="2-端口号，复用和分用"><a href="#2-端口号，复用和分用" class="headerlink" title="2. 端口号，复用和分用"></a>2. 端口号，复用和分用</h3><h4 id="1-运输层端口号"><a href="#1-运输层端口号" class="headerlink" title="1. 运输层端口号"></a>1. 运输层端口号</h4><ul><li>运行在计算机上的进程是使用==进程标识符==(<code>P</code>rocess <code>ld</code>entification,<code>PID</code>)来标识的。<ul><li>然而，因特网上的计算机并不是使用统一的操作系统，而==不同操作系统==(Windows、Linux、.MacOS)<br>又==使用不同格式的进程标识符==</li><li>为了使运行不同操作系统的计算机的应用进程之间能够基于网络进行通信，就必须==使用统一的方法<br>对TCPP体系的应用进程进行标识==</li></ul></li><li><code>TCP/IP</code>体系结构的运输层使用端口号来标识和区分应用层的不同应用进程。端口号的==长度为6比特，取<br>值范围是0~65535==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124191009578.png" style="zoom:100%;" /></p><blockquote><p>==<strong>端口号只具有本地意义，即端口号只是为了标识本计算机网络协议栈应用层中的各应用进程。在因特网中，不同计算机中的相同端口号是没有关系的，即相互独立。另外，<code>TCP</code>和<code>UDP</code>端口号之间也是没有关系的</strong>==</p></blockquote><h4 id="2-发送方的复用和接收方的分用"><a href="#2-发送方的复用和接收方的分用" class="headerlink" title="2. 发送方的复用和接收方的分用"></a>2. 发送方的复用和接收方的分用</h4><ol><li><strong>复用（Multiplexing）：</strong><ul><li><strong>定义：</strong> 复用是指==将多个应用程序的数据流合并到一个共享的通信通道上==</li><li><strong>TCP中的复用：</strong> 在TCP中，复用通过源端口号来实现。TCP连接的两端使用IP地址和端口号来唯一标识。源端口号表示发送端的应用程序，目的端口号表示接收端的应用程序。这样，在单个TCP连接中，多个应用程序的数据可以共享同一个物理通信通道</li><li><strong>UDP中的复用：</strong> 在UDP中，复用同样通过源端口号来实现。UDP报文的源端口号用于标识发送端的应用程序，目的端口号用于标识接收端的应用程序</li></ul></li><li><strong>分用（Demultiplexing）：</strong><ul><li><strong>定义：</strong> 分用是指==根据数据流中的标识信息将合并的数据流分发给正确的应用程序==</li><li><strong>TCP中的分用：</strong> 在TCP中，分用通过目的端口号来实现。接收端根据目的端口号将接收到的数据分发给相应的应用程序。这样，TCP层能够将数据正确地传递给目标应用程序</li><li><strong>UDP中的分用：</strong> 在UDP中，同样通过目的端口号来实现分用。接收端通过目的端口号确定应该将数据交付给哪个应用程序</li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124192346522.png" alt=""></p><blockquote><p>==常见协议的分类==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124192909256.png" alt=""></p><p><strong><a href='https://www.bilibili.com/video/BV1c4411d7jb?t=353.6&p=58'>运输层端口号应用举例</a></strong></p><h3 id="3-TCP和UDP的对比"><a href="#3-TCP和UDP的对比" class="headerlink" title="3.  TCP和UDP的对比"></a>3.  <code>TCP</code>和<code>UDP</code>的对比</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124195001220.png" alt=""></p><p><strong>==注意==</strong>：</p><ul><li>TCP面向连接是==逻辑连接，并非真实物理连接==</li><li>==TCP面向字节流，UDP面向应用报文==（只是给数据报添加一个UDP首部）</li><li>TCP只支持单播，UDP支持单播、多播和广播</li><li>==TCP提供可靠服务，UDP提供不可靠服务==</li></ul><h3 id="4-TCP的流量控制"><a href="#4-TCP的流量控制" class="headerlink" title="4. TCP的流量控制"></a>4. TCP的<strong>流量控制</strong></h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><p>TCP为应用程序提供了==流量控制==（<code>Flow Control</code>）机制，以解决因==发送方发送数据太快而导致接收方来不及接收，造成接收方的接收缓存溢出==的问题</p><p><strong>流量控制的基本方法：</strong>==接收方根据自己的接收能力（接收缓存的可用空间大小）控制发送方的发送速率==</p></blockquote><h4 id="2-流量控制方法"><a href="#2-流量控制方法" class="headerlink" title="2. 流量控制方法"></a>2. <a href='https://www.bilibili.com/video/BV1c4411d7jb?t=44.1&p=60'>流量控制方法</a></h4><ol><li><strong>流程</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124203621190.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124205122410.png" alt=""></p><ol><li><p>例题</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124210146804.png" alt=""></p></li></ol><h3 id="5-TCP的拥塞-se-控制"><a href="#5-TCP的拥塞-se-控制" class="headerlink" title="5. TCP的拥塞(se)控制"></a>5. TCP的<strong>拥塞(se)控制</strong></h3><h4 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124211432668.png" /></p><h4 id="2-4种拥塞控制方法"><a href="#2-4种拥塞控制方法" class="headerlink" title="2. 4种拥塞控制方法"></a>2. 4种拥塞控制方法</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124212653543.png" alt=""></p><h5 id="1-慢开始、拥塞避免"><a href="#1-慢开始、拥塞避免" class="headerlink" title="==1. 慢开始、拥塞避免=="></a>==1. 慢开始、拥塞避免==</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124213905436.png" alt=""></p><h5 id="2-快重传、快恢复"><a href="#2-快重传、快恢复" class="headerlink" title="==2. 快重传、快恢复=="></a>==2. 快重传、快恢复==</h5><blockquote><p>快重传算法和快恢复算法（==改进TCP性能==，1990年Reno版本）</p></blockquote><ol><li>问题</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124214535400.png" alt=""></p><ol><li><p><strong>==快重传==</strong></p><ul><li><strong>采用快重传算法可以让发送方尽早知道发生了==个别TCP报文段的丢失==</strong></li><li>“快重传”是指<strong>使发送方尽快（尽早）进行重传，而不是等重传计时器超时再重传</strong><ul><li>这就要求==接收方不要==等待自己发送数据时才进行==捎带确认==，而是==要立即发送确认==，即使收到了==失序的报文段==也要==立即==发出对已收到的报文段的==重复确认==</li><li>==发送方==一旦==收到3个连续的重复确认==，就将相应的报文段==立即重传==，而不是等该报文段的重传计时器超时再重传</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124215953819.png" alt=""></p></li><li><p>==<strong>快恢复</strong>==</p></li></ol><blockquote><p>与快重传算法配合使用的是<strong>快恢复算法</strong>，==发送方==一旦==收到3个重复确认==，就知道现在==只是丢失了个别的报文段==，于是==不启动慢开始算法，<strong>而是执行快恢复算法</strong>==</p><ul><li><strong>快恢复算法：</strong>==发送方将慢开始门限ssthresh的值和拥塞窗口cwnd的值<strong>都调整为当前cwnd值的一半</strong>，并开始执行拥塞避免算法==</li><li>也有的快恢复实现是把快恢复开始时的cwnd值再增大一些，即cwnd=新ssthresh+3</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125205520540.png" alt=""></p><h3 id="6-TCP超时重传时间的选择"><a href="#6-TCP超时重传时间的选择" class="headerlink" title="6. TCP超时重传时间的选择"></a>6. TCP超时重传时间的选择</h3><blockquote><p><strong>==TCP超时重传时间RTO的选择==是TCP==最复杂==的问题之一</strong></p><p>问题：</p><ul><li>==超时重传时间设置过小==，在确认报文段发送给接收方的过程中，发送方重传数据报文，==增大了网络负荷==</li><li>==超时重传时间设置过大==，需要重传数据报文时，推迟时间太长，==网络空闲时间大，降低了传输效率==</li><li>超时重传时间<code>RTO</code>应略大于往返时间<code>RTT</code></li></ul></blockquote><h4 id="RTO的选择"><a href="#RTO的选择" class="headerlink" title="==RTO的选择=="></a><strong>==RTO的选择==</strong></h4><h5 id="1-RTTs的计算"><a href="#1-RTTs的计算" class="headerlink" title="1. RTTs的计算"></a>1. RTTs的计算</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125211946213.png" alt=""></p><h5 id="2-RRTd和RTO的计算"><a href="#2-RRTd和RTO的计算" class="headerlink" title="2. RRTd和RTO的计算"></a>2. RRTd和RTO的计算</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125212210328.png" alt=""></p><h4 id="发生超时重传时无法测准RTT"><a href="#发生超时重传时无法测准RTT" class="headerlink" title="发生超时重传时无法测准RTT"></a>发生超时重传时无法测准RTT</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125212838059.png" alt=""></p><blockquote><p><strong>通过上述两个例子可以看出：当发送方出现超时重传后，收到确认报文段时是无法判断出该确认到底是对原数据报文段的确认还是对重传数据报文段的确认，也就是无法准确测量出RTT，进而无法正确计算RTO</strong></p></blockquote><h5 id="Karn算法及修正"><a href="#Karn算法及修正" class="headerlink" title="Karn算法及修正"></a>Karn算法及修正</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125213341384.png" alt=""></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125213649193.png" alt=""></p><h3 id="7-TCP可靠传输的实现"><a href="#7-TCP可靠传输的实现" class="headerlink" title="7.TCP可靠传输的实现"></a>7.TCP可靠传输的实现</h3><ul><li><strong>TCP的窗口以字节为单位</strong></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126212908308.png" alt=""></p><ul><li>发送方<ul><li>发送窗口内的已发送数据如果迟迟未收到确认，会发生==超时重传==</li><li>只有处于发送窗口内的数据才能发送</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126213314315.png" alt=""></p><ul><li>接收方<ul><li>接收方==<strong>只能对按序收到的数据中的最高序号给出累计确认</strong>==，3次重复确认会导致发送方==<strong>快重传</strong>==</li><li><strong>序号落入接收窗口内的数据是允许接收的数据</strong></li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126213800870.png" alt=""></p><ul><li><strong>==总结==</strong></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126214833403.png" alt=""></p><h3 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8. TCP的运输连接管理"></a>8. TCP的运输连接管理</h3><h4 id="1-TCP连接的建立"><a href="#1-TCP连接的建立" class="headerlink" title="1. TCP连接的建立"></a>1. TCP连接的建立</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203192027726.png" alt=""></p><blockquote><p>TCP双方连接的建立要解决的三个问题</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203192339624.png" alt=""></p><h4 id="2-三报文握手"><a href="#2-三报文握手" class="headerlink" title="2. 三报文握手"></a>2. 三报文握手</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203193842118 .png" alt=""></p><blockquote><p><strong>思考：第三次确认==是否多余==，==能不能两报文握手？==</strong></p><p>答案：不能，如下图所示</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203194753830.png" alt=""></p><h4 id="3-四报文挥手"><a href="#3-四报文挥手" class="headerlink" title="3. 四报文挥手"></a>3. 四报文挥手</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203195725711.png" alt=""></p><blockquote><p><strong>思考：为什么客户端发送完最后一个确认报文段后不立刻关闭而是等待2个MSL时间后才关闭？</strong></p><p>答案：如图所示</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203200428799.png" alt=""></p><blockquote><p>==TCP保活计时器的作用==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203201004403.png" alt=""></p><h3 id="9-TCP报文段首部格式"><a href="#9-TCP报文段首部格式" class="headerlink" title="9. TCP报文段首部格式"></a>9. TCP报文段首部格式</h3><blockquote><p>参阅思维导图 1</p></blockquote><h3 id="10-思维导图和习题"><a href="#10-思维导图和习题" class="headerlink" title="10. 思维导图和习题"></a>10. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgoja6Lpohhj">第5章 运输层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/chkSS9vn9Zgd">第5章 运输层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cpaRQtp0G6Ou">第5章 运输层 习题 (kdocs.cn)</a></p><hr><h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>应用层是计算机网络体系结构的==<strong>最顶层</strong>==，是==<strong>设计和建立计算机网络的最终目的</strong>==，也是计算机网络中发展最快的部分<ul><li>早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）</li><li>20世纪90年代将因特网带入千家万户的万维网WWW</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台</li></ul></li></ul><h3 id="2-客户服务器和对等方式"><a href="#2-客户服务器和对等方式" class="headerlink" title="2. 客户服务器和对等方式"></a>2. 客户服务器和对等方式</h3><h4 id="1-C-S方式"><a href="#1-C-S方式" class="headerlink" title="1. C/S方式"></a>1. <code>C/S</code>方式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210526922.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210406504.png" alt=""></p><h4 id="2-P2P方式"><a href="#2-P2P方式" class="headerlink" title="2. P2P方式"></a>2. <code>P2P</code>方式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210957388.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210908603.png" alt=""></p><h3 id="3-DHCP"><a href="#3-DHCP" class="headerlink" title="3. DHCP"></a>3. <code>DHCP</code></h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><p>动态主机配置协议（<code>D</code>ynamic <code>h</code>ost <code>c</code>onfiguration <code>p</code>rotocol）</p><p>作用：</p><ul><li><code>DHCP</code>可为计算机==自动配置网络参数==，包括：<ul><li>IP地址</li><li>子网掩码</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul></blockquote><h4 id="2-DHCP基本工作过程"><a href="#2-DHCP基本工作过程" class="headerlink" title="2. DHCP基本工作过程"></a>2. <code>DHCP</code>基本工作过程</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203212822735.png" alt=""></p><h4 id="3-DHCP中继代理"><a href="#3-DHCP中继代理" class="headerlink" title="3. DHCP中继代理"></a>3. <code>DHCP</code>中继代理</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203213528827.png" alt=""></p><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4. DNS"></a>4. <code>DNS</code></h3><blockquote><p><strong>域名系统</strong>（<code>D</code>omain <code>N</code>ame <code>S</code>ystem,<code>DNS</code>）</p></blockquote><h4 id="1-域名系统的作用"><a href="#1-域名系统的作用" class="headerlink" title="1. 域名系统的作用"></a>1. 域名系统的作用</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204215706663.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204215946064.png" alt=""></p><h4 id="2-因特网的域名结构"><a href="#2-因特网的域名结构" class="headerlink" title="2. 因特网的域名结构"></a>2. 因特网的域名结构</h4><blockquote><p>因特网采用<strong>==层次树状结构的域名结构==</strong></p></blockquote><h5 id="1-域名规范"><a href="#1-域名规范" class="headerlink" title="1. 域名规范"></a>1. 域名规范</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204220316573.png" alt=""></p><h5 id="2-不同国家的域名"><a href="#2-不同国家的域名" class="headerlink" title="2. 不同国家的域名"></a>2. 不同国家的域名</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204220844413.png" alt=""></p><h5 id="3-因特网的域名空间"><a href="#3-因特网的域名空间" class="headerlink" title="3. 因特网的域名空间"></a>3. 因特网的域名空间</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221139510.png" alt=""></p><h4 id="3-域名服务器"><a href="#3-域名服务器" class="headerlink" title="3. 域名服务器"></a>3. 域名服务器</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221502337.png" alt=""></p><h4 id="4-域名解析"><a href="#4-域名解析" class="headerlink" title="4. 域名解析"></a>4. 域名解析</h4><h5 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1. 递归查询"></a>1. 递归查询</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221840693.png" alt=""></p><h5 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2. 迭代查询"></a>2. 迭代查询</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222346748.png" alt=""></p><h5 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3. 高速缓存"></a>3. 高速缓存</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222807218.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222817296.png" alt=""></p><h3 id="5-FTP"><a href="#5-FTP" class="headerlink" title="5. FTP"></a>5. <code>FTP</code></h3><blockquote><p><strong>文件传送协议</strong>（<code>F</code>ile <code>T</code>ransfer <code>P</code>rotocol，<code>FTP</code>）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204223526085.png" alt=""></p><blockquote><p><strong>基本工作原理</strong></p></blockquote><ol><li>主动模式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204224108197.png" alt=""></p><ol><li>被动模式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204224211222.png" alt=""></p><h3 id="6-电子邮件"><a href="#6-电子邮件" class="headerlink" title="6. 电子邮件"></a>6. 电子邮件</h3><h4 id="1-E-mail"><a href="#1-E-mail" class="headerlink" title="1. E-mail"></a>1. <code>E-mail</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090041032.png" alt=""></p><h4 id="2-电子邮件系统的组成"><a href="#2-电子邮件系统的组成" class="headerlink" title="2. 电子邮件系统的组成"></a>2. 电子邮件系统的组成</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090359331.png" alt=""></p><h4 id="3-邮件发送和接收过程"><a href="#3-邮件发送和接收过程" class="headerlink" title="3. 邮件发送和接收过程"></a>3. 邮件发送和接收过程</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090654917.png" alt=""></p><h4 id="4-SMTP"><a href="#4-SMTP" class="headerlink" title="4. SMTP"></a>4. <code>SMTP</code></h4><blockquote><p>简单邮件传送协议（Simple Mail Transfer Protocol，<code>SMTP</code>）的基本工作过程</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091401858.png" alt=""></p><h4 id="5-电子邮件的信息格式"><a href="#5-电子邮件的信息格式" class="headerlink" title="5. 电子邮件的信息格式"></a>5. 电子邮件的信息格式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091646693.png" alt=""></p><h4 id="6-MIME"><a href="#6-MIME" class="headerlink" title="6. MIME"></a>6. <code>MIME</code></h4><blockquote><p><strong>多用途因特网邮件扩展</strong> (Multipurpose Internet Mail Extensions，<code>MIME</code>)</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091958949.png" alt=""></p><blockquote><p><strong><code>MIME</code>对邮件内容中的非ASCII字符转换成ASCII字符</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205092205673.png" alt=""></p><h4 id="7-常用邮件读取协议"><a href="#7-常用邮件读取协议" class="headerlink" title="7. 常用邮件读取协议"></a>7. 常用邮件读取协议</h4><blockquote><p><strong>邮局协议</strong>（Post Office Protocol，<code>POP</code>）</p><p><strong>因特网邮件访问协议</strong>（Internet Message Access Protocol，<code>IMAP</code>）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205092629754.png" alt=""></p><h4 id="8-基于万维网的电子邮件"><a href="#8-基于万维网的电子邮件" class="headerlink" title="8. 基于万维网的电子邮件"></a>8. 基于万维网的电子邮件</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205093140031.png" alt=""></p><h3 id="7-万维网"><a href="#7-万维网" class="headerlink" title="7. 万维网"></a>7. 万维网</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><ul><li><strong>==万维网==</strong>（World Wide Web，<code>WWW</code>）==并非某种特殊的计算机网络==。它是一个大规模的、联机式的信息储藏所，是==运行在因特网上的一个分布式应用==</li><li>万维网利用网页之间的==超链接==将不同网站的网页链接成一张逻辑上的信息网</li><li>万维网是欧洲粒子物理实验室的==Tim Berners-Lee==最初于1989年3月提出的</li></ul></blockquote><h4 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. <code>URL</code></h4><blockquote><p>==统一资源定位符==（<code>U</code>niform <code>R</code>esource <code>L</code>ocator）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205094301978.png" alt="image-20231205094301978"></p><h4 id="3-万维网文档"><a href="#3-万维网文档" class="headerlink" title="3. 万维网文档"></a>3. 万维网文档</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205094813054.png" alt=""></p><h4 id="4-HTTP"><a href="#4-HTTP" class="headerlink" title="4. HTTP"></a>4. <code>HTTP</code></h4><h5 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1. 概述"></a>1. 概述</h5><blockquote><p><strong>==超文本传输协议==</strong><code>HTTP</code>(HyperText Transfer Protocol)</p><p>HTTP定义了<strong>浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205095412658.png" alt=""></p><h5 id="2-报文格式"><a href="#2-报文格式" class="headerlink" title="2. 报文格式"></a>2. 报文格式</h5><ul><li>==请求报文格式==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205095830137.png" alt=""></p><ul><li>==响应报文格式==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205100113338.png" alt=""></p><h4 id="5-Cookie"><a href="#5-Cookie" class="headerlink" title="5. Cookie"></a>5. <code>Cookie</code></h4><ul><li>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种==无状态==的协议。这样可以简化服务器的设计</li><li>现在，用户可以通过万维网进行各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</li><li>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是说，==Cookie是一种对无状态的HTTP进行状态化的技术==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205103323858.png" alt=""></p><h4 id="6-万维网缓存与代理服务器"><a href="#6-万维网缓存与代理服务器" class="headerlink" title="6. 万维网缓存与代理服务器"></a>6. 万维网缓存与代理服务器</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205103638305.png" alt=""></p><h4 id="7-思维导图和相关习题"><a href="#7-思维导图和相关习题" class="headerlink" title="7. 思维导图和相关习题"></a>7. 思维导图和相关习题</h4><p><a href="https://www.kdocs.cn/view/l/cle5dxMBHZIH">第6章 应用层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cabHsokbKiNO">第6章 应用层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cv9vfzDopPvi">第6章 应用层 习题 (kdocs.cn)</a></p><hr><h2 id="计算机网络相关术语"><a href="#计算机网络相关术语" class="headerlink" title="计算机网络相关术语"></a><em>计算机网络相关术语</em></h2><p><strong>ACK</strong> (Acknowledgement) 确认</p><p><strong>ADSL</strong> (Asymmetric Digital Subscriber Line) 非对称数字用户线</p><p><strong>AP</strong> (Access Point) 接入点</p><p><strong>AP</strong> (Application) 应用程序</p><p><strong>API</strong> (Application Programming Interface) 应用编程接口</p><p><strong>APNIC</strong> (Asia Pacific Network Information Centre) 亚太网络信息中心</p><p><strong>ARIN</strong> (American Registry for Internet Numbers) 美国因特网号码注册机构</p><p><strong>==ARP (Address Resolution Protocol) 地址解析协议==</strong></p><p><strong>ARPA</strong> (Advanced Research Projects Agency) 美国国防部远景研究规划局 (高级研究计划署) </p><p><strong>ARQ</strong> (Automatic Repeat-request) 自动重传请求</p><p><strong>AS</strong> (autonomous system) 自制系统</p><p>==<strong>BGP</strong> (Border Gateway Protocol ) 边界网关协议==</p><p><strong>BOOTP</strong> (Bootstrap Protocol) 引导程序协议</p><p><strong>BSA</strong> (Basic Service Area) 基本服务区</p><p><strong>BT</strong> (Bit Torrent) 一种P2P程序</p><p><strong>CA</strong> (Certificate Authority) 认证中心</p><p><strong>CA</strong> (Collision Avoidance) 碰撞避免</p><p><strong>CATV</strong> ( Community Antenna Television) 有线电视</p><p>==<strong>CDM</strong> (Code Division Multiplexing) 码分复用==</p><p>==<strong>CDMA</strong> (Code Division Multiple Access) 码分多址==</p><p><strong>CGI</strong>  (Common Gateway Interface) 通用网关接口</p><p>==<strong>CIDR</strong> (Classless Inter-Domain Routing) 无分类域间路由选择==</p><p>==<strong>CRC</strong> (Cyclical Redundancy Check) 循环冗余校验==</p><p>==<strong>CSMA/CD</strong> (Carrier Sense Multiple Access/Collision Detect) 载波监听 多址接入/碰撞检测==</p><p><strong>CSMA/CA</strong> (Carrier Sense Multiple Access with Collision Avoidance)  载波监听多点接入/冲突避免</p><p><strong>CTS</strong> (Clear To Send) 允许发送</p><p><strong>DACS</strong> (Digital Access and Cross-connect System) 数字交接系统</p><p><strong>==DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议==</strong></p><p><strong>DiffServ (Differentiated Services) 区分服务</strong></p><p><strong>DLCI</strong> (Data Link Connection Identifier) 数据链路连接标识符</p><p><strong>DMT</strong> (Discrete Multi-Tone) 离散多音 (调制) </p><p>==<strong>DNS</strong> (Domain Name System) 域名系统==</p><p><strong>DoS</strong> (Denial of Service) 拒绝服务</p><p><strong>DS</strong> (Distribution System) 分配系统</p><p><strong>DSL</strong> (Digital Subscriber Line) 数字用户线</p><p><strong>DSLAM</strong> ( DSL Access Multiplexer) 数字用户线接入复用器</p><p><strong>DSSS</strong> (Direct Sequence Spread Spectrum) 直接序列扩频</p><p><strong>EFM</strong> (Ethernet in the First Mile ) 第一英里的以太网</p><p><strong>EFPHB</strong> (Expedited Forwarding Per-Hop Behavior) 迅速转发每跳行为</p><p><strong>EGP</strong> (Exterior Gateway Protocol) 外部网关协议</p><p><strong>EIA</strong> (Electronic Industries Association) 美国电子工业协会</p><p><strong>FCS</strong> (Frame Check Sequence) 帧检验序列</p><p><strong>FDDI</strong> (fiber-distributed data interface) 光纤分布式数据接口</p><p>==<strong>FDM</strong> (Frequency-division multiplexing) 频分复用==</p><p><strong>FEC</strong> (Forwarding Equivalence Class) 转发等价类</p><p><strong>FFD</strong> (Full-Function Device) 全功能设备</p><p><strong>FHSS</strong> (Frequency-Hopping Spread Spectrum) 跳频扩频</p><p><strong>FIFO</strong> (First In First Out) 先进先出</p><p><strong>FQ</strong> (Fair Queuing) 公平排队</p><p>==<strong>FTP (File Transfer Protocol) 文件传输协议</strong>==</p><p><strong>GIF</strong> (Graphics System for Mobile) 全球移动通信系统，GSM体制</p><p><strong>HDLC</strong> ( High-Level Data Link Control) 高级数据链路控制</p><p><strong>HDSL</strong> (High-speed DSL) 高速数字用户线</p><p><strong>HSSG</strong> (High Speed Study Group) 高速研究组</p><p><strong>HTML</strong> (Hyper Text Markup Language) 超文本标记语言</p><p><strong>==HTTP (Hyper Text Transfer Protocol) 超文本传送协议==</strong></p><p><strong>IAB</strong> (Internet Architecture Board) 因特网体系结构委员</p><p><strong>IANA</strong> (Internet Assigned Numbers Authority) 因特网赋号管理局</p><p><strong>==ICMP (Internet Control Message Protocol) 网际控制报文协议==</strong></p><p><strong>IEEE</strong> (Institute of Electrical and Electronic Engineering) (美国) 电气和电子工程师学会</p><p><strong>IFS</strong> (Inter Frame Space) 帧间间隔</p><p><strong>IGMP</strong> (Internet Group Management Protocol) 网际组管理协议</p><p><strong>IGP</strong> (Interior Gateway Protocol) 内部网关协议</p><p><strong>IM</strong> (Instant Messaging) 及时传信</p><p><strong>==IMAP ( Internet Message Access Protocol) 因特网报文存取协议==</strong></p><p><strong>IntServ</strong> (Integrated Services) 综合服务</p><p><strong>==IP (Internet Protocol) 网际协议==</strong></p><p><strong>IPCP</strong> (IP Control Protocol) IP控制协议</p><p><strong>IPng</strong> (IP Next Protocol) 下一代IP</p><p><strong>IPsec</strong> (IP security) IP安全协议</p><p><strong>ISDN</strong> (Internet Services Digital Network) 综合业务数字网</p><p><strong>ISO</strong> (International Organization for Standardization ) 国际标准化组织</p><p><strong>ISOC</strong> (Internet Society) 因特网协会</p><p><strong>ISP</strong> (Internet Service Provider) 因特网服务提供者</p><p>==<strong>LAN</strong> (Local Area Network) 局域网==</p><p><strong>LCP</strong> (Link Control Protocol) 链路控制协议</p><p><strong>LDP</strong> (Label Distribution Protocol) 标记分配协议</p><p><strong>LLC</strong>(Logical Link Control) 逻辑链路控制</p><p><strong>LSR</strong>(Label Switched Router) 标记交换路由器</p><p><strong>MAC</strong>(Medium Access Control) 媒体接入控制</p><p><strong>MACA</strong>(Multiple Access with Collision Avoidance)具有碰撞避免的多点接入</p><p>==<strong>MAN</strong>(Metropolitan Area Network) 城域网==</p><p><strong>MBONE</strong>(Multicast Backbone On the InterNet) 多播主干网</p><p><strong>MCU</strong>(Multipoint Control Unit) 多点控制单元</p><p><strong>MD</strong>(Message Digest) 报文摘要</p><p><strong>MF</strong>(More Fragment) 还有分片</p><p><strong>MRU</strong>(Maximum Receive Unit) 最大接收单元</p><p><strong>MSS</strong>(Maximum Segment Size) 最长报文段</p><p><strong>MTU</strong>(Maximum Transfer Unit) 最大传送单元</p><p><strong>NAP</strong>(Network Access Point)　网络接入点</p><p>==<strong>NAT</strong>(Network Address Translation) 网络地址转换==</p><p><strong>NAV</strong>(Network Allocation Vector) 网络分配向量</p><p><strong>NCP</strong>(Network Control Protocol) 网络控制协议</p><p><strong>NFS</strong>(Network File System) 网络文件系统</p><p><strong>NOC</strong>(Network Operations Center) 网络运行中心</p><p><strong>NSAP</strong>(Network Service Access Point) 网络层服务访问点</p><p><strong>NSF</strong>(National Service Foundation) (美国)国家科学基金会</p><p><strong>OFDM</strong>(Orthogonal Frequency Division Multiplexing) 正交频分复用</p><p><strong>OSI/RM</strong> (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型</p><p>==<strong>OSPF(Open Shortest Path First) 开放最短通路优先</strong>==</p><p>==<strong>P2P</strong>(Peer-to-Peer) 对等方式==</p><p>==<strong>PAN</strong>(Personal Area Network) 个人区域网==</p><p><strong>PAP</strong>(Password Authentication Protocol) 口令鉴别协议</p><p><strong>PCA</strong>(Policy Certification Authority) 政策认证中心</p><p><strong>PCF</strong>(Point Coordination Function) 点协调功能</p><p><strong>PCM</strong>(Pulse Code Modulation) 脉码调制</p><p><strong>PEM</strong>(Privacy Enhanced Mail) 因特网的正式邮件加密标准</p><p><strong>PGP</strong>(Pretty Good Privacy) 一种电子邮件的机密标准</p><p><strong>PHB</strong>(Per-Hop Behavior) 每跳行为</p><p><strong>PIFS</strong>(Point Coordination Function IFS) 点协调功能帧间间隔</p><p><strong>PK</strong>(public key) 公钥，公开密钥</p><p><strong>PoP</strong>(Point of Presence) 汇接点</p><p>==<strong>POP</strong>(Post Office Protocol) 邮局协议==</p><p><strong>==PPP（Point-to-Point Protocol） 点对点协议==</strong></p><p><strong>PPPoE</strong>(Point-to-Point Protocol over Ethernet) 以太网上的点对点协议</p><p><strong>QAM</strong>(Quadrature Amplitude Modulation) 正交幅度调制</p><p><strong>QoS</strong>(Quality of Service)　服务质量</p><p><strong>QPSK</strong>(Quarternary Phase Shift Keying)正交相移键控</p><p><strong>RARP</strong>(Reverse Address Resolution Protocol)逆地址解析协议</p><p><strong>RFD</strong>(Reduced-Function Device)精简功能设备</p><p><strong>RG</strong>(Research Group)研究组</p><p><strong>==RIP(Routing Information Protocol)路由信息协议==</strong></p><p><strong>RIPE</strong>(法文表示的European IP Network)欧洲的IP 网络</p><p><strong>RTP</strong>(Real-Time Transfer Protocol)实时传送协议</p><p><strong>RTSP</strong>(Real-Time Streaming Protocol)实时流式协议</p><p>==<strong>RTT</strong>(Round-Trip Time)往返时间==</p><p><strong>SA</strong>(Security Association)安全关联</p><p><strong>SACK</strong>(Selective ACK)选择确认</p><p><strong>SAP</strong>(Service Access Point)服务访问点</p><p><strong>SCTP</strong>(Stream Control Transmission Protocol)流控制传输协议</p><p><strong>SDH</strong>(Synchronous Digital Hierarchy)同步数字系列</p><p><strong>SMI</strong>(Structure of Management Information)管理信息结构</p><p><strong>==SMTP(Simple Mail Transfer Protocol)简单邮件传送协议==</strong></p><p><strong>SNA</strong>(System Network Architecture)系统网络体系结构</p><p><strong>SNMP</strong>(Simple Network Management Protocol)简单网络管理协议</p><p><strong>SOH</strong>(Start Of Header)首部开始</p><p><strong>SONET</strong>(Synchronous Optical Network)同步光纤网</p><p><strong>STDM</strong>(Statistic TDM)统计时分复用</p><p><strong>STM</strong>(Synchronous Transfer Module)同步传递模块</p><p><strong>STS</strong>(Synchronous Transport Signal)同步传送信号</p><p><strong>TAG</strong>(TAG Switching)标记交换</p><p><strong>TCB</strong>(Transmission Control Block)传输控制程序块</p><p><strong>==TCP(Transmission Control Protocol)传输控制协议==</strong></p><p>==<strong>TDM</strong>(Time Division Multiplexing)时分复用==</p><p><strong>TELNET</strong>(TELetype NETwork)电传机网络，一种因特网的应用程序</p><p><strong>TFTP</strong>(Trivial File Transfer Protocol)简单文件传送协议</p><p><strong>TIA</strong>(Telecommunications Industries Association)电信行业协会</p><p><strong>TLD</strong>(Top Level Domain)顶级域名</p><p><strong>TLI</strong>(Transport Layer Interface)运输层接口</p><p><strong>TLS</strong>(Transport Layer Security)运输层安全协议</p><p><strong>TLV</strong>(Type-Length-Value)类型-长度-值</p><p><strong>TPDU</strong>(Transport Protocol Data Unit)运输协议数据单元</p><p><strong>==UDP(User Datagram Protocol)用户数据报协议==</strong></p><p>==<strong>URL</strong>(Uniform Resource Locator)统一资源定位符==</p><p><strong>UTP</strong>(Unshield Twisted Pair)无屏蔽双绞线</p><p><strong>UWB</strong>(Ultra-Wide Band)超宽带</p><p><strong>VC</strong>(Virtual Circuit)虚电路</p><p><strong>VDSL</strong>(Very high speed DSL)甚高数字用户线</p><p>==<strong>VLAN</strong>(Virtual LAN)虚拟局域网==</p><p>==<strong>VPN</strong>(Virtual Private Network) 虚拟专用网==</p><p>==<strong>WAN</strong>(Wide Area Network) 广域网==</p><p><strong>WDM</strong>(Wavelength Division Multiplexing) 波分复用</p><p><strong>WG</strong>(Working Group)　工作组</p><p><strong>Ｗi-Fi</strong>(Wireless-Fidelity) 无线保真度（无限局域网的同义词）</p><p><strong>WLAN</strong>(Wireless Local Area Network) 无线局域网</p><p><strong>WMAN</strong>(Wireless Metrpolitan Area Network) 无线个城域网</p><p><strong>WPAN</strong>(wireless Personal Area Network) 无线个人区域网</p><p><strong>WSN</strong>(Wireless Sensor Network)　无线传感器网络</p><p>==<strong>WWW</strong>(World Wide Web) 万维网==</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus</title>
      <link href="/2023/08/31/mybatis-plus/"/>
      <url>/2023/08/31/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上==只做增强不做改变==，为简化开发、提高效率而生。</p></blockquote><p><img src="https://www.baomidou.com/img/relationship-with-mybatis.png" alt=""></p><h2 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h2><h3 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h3><blockquote><p>导入mybatis-plus依赖,包含了mybatis，==不用额外再导入mybatis依赖==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-创建Mapper"><a href="#1-2-创建Mapper" class="headerlink" title="1.2 创建Mapper"></a>1.2 创建Mapper</h3><blockquote><p>为了简化单表CRUD，mp已经提供了对于单表的CRUD操作的接口<code>BaseMapper</code>,直接继承BaseMapper接口即可直接使用</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202309122231328.png" alt=""></p><h3 id="1-3-测试CRUD"><a href="#1-3-测试CRUD" class="headerlink" title="1.3 测试CRUD"></a>1.3 测试CRUD</h3><blockquote><p>测试BaseMapper中对单表CRUD操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//user.setId(5L);</span></span><br><span class="line">    user.setUsername(<span class="string">&quot;ikun23&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">    user.setBalance(<span class="number">200</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>,<span class="string">&quot;英语老师&quot;</span>,<span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">5L</span>);</span><br><span class="line">    user.setBalance(<span class="number">3</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>,<span class="string">&quot;英语老师&quot;</span>,<span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(userMapper.deleteById(<span class="number">5L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：只要继承了<code>BaseMapper</code>，就能直接对单表进行CRUD操作！</p></blockquote><h2 id="2-常见注解"><a href="#2-常见注解" class="headerlink" title="2.常见注解"></a>2.常见注解</h2><blockquote><p><strong>问题</strong>：在刚刚的测试中，我们直接调用BaseMapper中的方法就能对表增删改查，在继承<code>BaseMapper</code>的时候我们只是指定了一个泛型<code>&lt;User&gt;</code>,并没有指定是哪张表，那么==mybatis-plus怎么知道我们要操作的是user表呢？它又是怎么知道这张表中的所有字段名呢？==</p><p>解答：其实mp遵从==约定大于配置==的思想,mp从<code>User</code>类推导出数据库中表名为<code>user</code>，然后根据User类中的所有变量名从==驼峰命名==转成==下划线==作为数据库的字段名，从而在调用方法时可以自动生成正确的sql语句。</p><p>如果我们在创建User类和user表的时候遵从驼峰命名和下划线命名，那么我们不需要做额外的配置，如果类名和表名、属性名和字段名直接不是简单的转换，那么我们就不得不使用一些相应的注解来声明表的信息</p></blockquote><h3 id="2-1-TableName"><a href="#2-1-TableName" class="headerlink" title="2.1 @TableName"></a>2.1 <a href="https://www.baomidou.com/pages/223848/#tablename">@TableName</a></h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-TableId"><a href="#2-2-TableId" class="headerlink" title="2.2  @TableId"></a>2.2 <a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableId.java"> @TableId</a></h3><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>==IdType.NONE==</td><td>指定主键类型</td></tr></tbody></table></div><p><code>IdType</code>支持的类型有：</p><div class="table-container"><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td><del>ID_WORKER</del></td><td>分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td><del>UUID</del></td><td>32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td><del>ID_WORKER_STR</del></td><td>分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table></div><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="2-3-TableField"><a href="#2-3-TableField" class="headerlink" title="2.3 @TableField"></a>2.3 <a href="https://www.baomidou.com/pages/223848/#tablefield">@TableField</a></h3><ul><li>描述：字段注解（非主键）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常见配置"><a href="#3-常见配置" class="headerlink" title="3.常见配置"></a>3.常见配置</h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：<br><a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">使用配置 | MyBatis-Plus</a></p><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span><span class="comment">#别名扫描包</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure><p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure><p>可以看到默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。</p><p>使用<code>@MapperScan</code>注解标识mapper类所在目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.clb.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>配置了==@MapperScan==注解后，mapper类中无需添加==@Mapper==注解</p></blockquote><hr><h2 id="4-核心功能"><a href="#4-核心功能" class="headerlink" title="==4.核心功能=="></a><strong>==4.核心功能==</strong></h2><h3 id="4-1-条件构造器"><a href="#4-1-条件构造器" class="headerlink" title="4.1 条件构造器"></a>4.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117068580-3abcd2bb-fbf8-4430-8f2a-dcf130f05f70.png#averageHue=%23faf4ef&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=312&amp;id=ua83b74d8&amp;originHeight=387&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74950&amp;status=done&amp;style=none&amp;taskId=uf547d320-6fa6-4d9c-a531-25573a538a5&amp;title=&amp;width=697.008381017849" alt="image.png"><br>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117775304-84915c47-d2d9-49f4-90fb-99270d9353c7.png#averageHue=%23f7faf2&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=407&amp;id=uf66fc47c&amp;originHeight=504&amp;originWidth=1212&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=60824&amp;status=done&amp;style=none&amp;taskId=u14c0b946-02c2-4631-bd09-d2459214134&amp;title=&amp;width=977.7478678167049" alt="image.png"></p><p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117979051-e388959d-86ba-4aa9-9d57-cd9fd84fc00f.png#averageHue=%23f9f8f6&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=651&amp;id=ua30f8ba3&amp;originHeight=807&amp;originWidth=836&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=103972&amp;status=done&amp;style=none&amp;taskId=u4c610b14-da63-46ae-8a13-08672c8643e&amp;title=&amp;width=674.4201464478261" alt="image.png"><br>而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688118137162-ffcf1fe3-57cb-46ef-b069-9d576e9f0184.png#averageHue=%23e2c889&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=127&amp;id=ue7075211&amp;originHeight=158&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=23389&amp;status=done&amp;style=none&amp;taskId=ua0264d53-8522-4608-97e1-d30b91f878c&amp;title=&amp;width=662.3193064995996" alt="image.png"><br>而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688118200333-0c97025d-1bd9-4f3b-a486-7e6a1cf3604d.png#averageHue=%23e5ca91&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=126&amp;id=uad24f810&amp;originHeight=156&amp;originWidth=825&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=22371&amp;status=done&amp;style=none&amp;taskId=uacb8416a-d529-44e1-9a64-84c0ac60765&amp;title=&amp;width=665.54619715246" alt="image.png"></p><p>接下来，我们就来看看如何利用<code>Wrapper</code>实现复杂查询。</p><h4 id="4-1-1-QueryWrapper"><a href="#4-1-1-QueryWrapper" class="headerlink" title="4.1.1 QueryWrapper"></a>4.1.1 QueryWrapper</h4><p>修改、删除、查询都可以使用QueryWrapper构建查询条件</p><p><strong>查询：</strong>查询名字带有o，且存款大于等于1000的人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,username,info,balance </span><br><span class="line">from user</span><br><span class="line">where username like %o% and balance &gt;= 1000;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//构建查询条件</span></span><br><span class="line">    wrapper.select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-UpdateWrapper"><a href="#4-1-2-UpdateWrapper" class="headerlink" title="4.1.2 UpdateWrapper"></a>4.1.2 UpdateWrapper</h4><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。<br>例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对于的SQL应该是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line"><span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-LambdaQueryWrapper"><a href="#4-1-3-LambdaQueryWrapper" class="headerlink" title="4.1.3 LambdaQueryWrapper"></a>4.1.3 LambdaQueryWrapper</h4><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，可能会出现字符串写错的现象，因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,username,info,balance </span><br><span class="line">from user</span><br><span class="line">where username like %o% and balance &gt;= 1000;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//构建查询条件</span></span><br><span class="line">    <span class="comment">//由原来的字符串变成getter函数对象获取类属性</span></span><br><span class="line">    wrapper.select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">        .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4);</span><br></pre></td></tr></table></figure><h3 id="4-2-自定义SQL"><a href="#4-2-自定义SQL" class="headerlink" title="4.2 自定义SQL"></a>4.2 自定义SQL</h3><h4 id="4-2-1-基本使用"><a href="#4-2-1-基本使用" class="headerlink" title="4.2.1 基本使用"></a>4.2.1 基本使用</h4><p>在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688133292238-a0f07be7-b115-4970-95d0-2f36bf68cc19.png#averageHue=%23f8fbf6&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=362&amp;id=u502de218&amp;originHeight=449&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=98085&amp;status=done&amp;style=none&amp;taskId=u903bfb55-ce92-4788-af0e-33eeeabe260&amp;title=&amp;width=860.773081650515" alt="image.png"><br>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。<br>这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。</p><p>所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml或注解编写SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4)</span><br></pre></td></tr></table></figure><p><code>update user set balance = balance - 200</code>使用注解完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将wrapper作为ew，并使用ew.customSqlSegment取出条件是固定写法</span></span><br><span class="line"><span class="meta">@Update(&quot;update tb_user set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBalanceByWrapper</span><span class="params">(<span class="meta">@Param(&quot;amount&quot;)</span> <span class="type">int</span> amount, <span class="meta">@Param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p><code>where id in(1,2,4)</code> 使用自定义sql完成,将wrapper作为参数传入自定义的方法中<code>$&#123;ew.customSqlSegment&#125;</code> ==&gt;<code>where id in (1,2,4)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCustomSql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.in(User::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    userMapper.updateBalanceByWrapper(amount, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-多表联查"><a href="#4-2-2-多表联查" class="headerlink" title="4.2.2 多表联查"></a>4.2.2 多表联查</h4><p>理论上来将MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。<br>例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户<br>要是自己基于mybatis实现SQL，大概是这样的：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user u</span><br><span class="line">    INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">    WHERE u.id</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    AND a.city = #&#123;city&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。<br>查询条件这样来构建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在UserMapper中自定义方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==总结:where条件可以使用wrapper构建，然后作为参数传递==</p></blockquote><h3 id="4-3-Service接口"><a href="#4-3-Service接口" class="headerlink" title="4.3 Service接口"></a>4.3 Service接口</h3><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br>通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul><h4 id="4-3-1-CRUD"><a href="#4-3-1-CRUD" class="headerlink" title="4.3.1.CRUD"></a>4.3.1.CRUD</h4><p>我们先俩看下基本的CRUD接口。<br><strong>新增</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688175852334-462e40db-e880-4131-adaa-5fc14360ff73.png#averageHue=%23f9f8f5&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=235&amp;id=u06631bbd&amp;originHeight=291&amp;originWidth=890&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=35948&amp;status=done&amp;style=none&amp;taskId=u045be908-a24b-4312-b024-0a2376b2e00&amp;title=&amp;width=717.9831702614417" alt="image.png"></p><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><p><strong>删除：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176052341-b6c0528d-bb35-452d-9087-ea5ee2708bd4.png#averageHue=%23f9f7f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=330&amp;id=u1802c257&amp;originHeight=409&amp;originWidth=913&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=55434&amp;status=done&amp;style=none&amp;taskId=ubf745089-f151-433a-bf03-10a0e0907ce&amp;title=&amp;width=736.5377915153891" alt="image.png"></p><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><code>~~removeBatchByIds~~</code>：暂不支持</li></ul><p><strong>修改：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176292104-2d148912-019b-46c2-8537-54b9b1274abd.png#averageHue=%23faf6f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=358&amp;id=ub3a7a979&amp;originHeight=444&amp;originWidth=931&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61438&amp;status=done&amp;style=none&amp;taskId=u17eb7110-22a9-42b9-b021-bdef1484f11&amp;title=&amp;width=751.0587994532609" alt="image.png"></p><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><p><strong>Get：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176734766-5df895e7-950a-4050-aa14-996ba9f6efc7.png#averageHue=%23f9f3f1&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=232&amp;id=uc50ce3bb&amp;originHeight=287&amp;originWidth=897&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=35993&amp;status=done&amp;style=none&amp;taskId=u965dedf4-cadf-4370-be0b-1b4dfbae494&amp;title=&amp;width=723.6302289039475" alt="image.png"></p><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176798210-d60284da-3862-422b-9621-2eec6b77c7ee.png#averageHue=%23f9f5f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=303&amp;id=udd4bc117&amp;originHeight=375&amp;originWidth=919&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=48612&amp;status=done&amp;style=none&amp;taskId=uc743900e-ec3f-40c3-84b0-054169510ba&amp;title=&amp;width=741.3781274946797" alt="image.png"></p><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176988135-5c605f58-87f5-42de-8613-ba3e7f7c36b4.png#averageHue=%23dbc789&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=108&amp;id=u366b7592&amp;originHeight=134&amp;originWidth=775&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=13537&amp;status=done&amp;style=none&amp;taskId=u18328f20-d548-4a65-b93f-be7bbc9ca96&amp;title=&amp;width=625.2100639917048" alt="image.png"></p><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>：<br>当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689651515691-7a4ff31d-e73e-443e-a088-62af40589fa5.png#averageHue=%23f4f4f1&amp;clientId=u82e37f7f-41b7-4&amp;from=paste&amp;height=111&amp;id=ue40936a2&amp;originHeight=124&amp;originWidth=529&amp;originalType=binary&amp;ratio=1.115625023841858&amp;rotation=0&amp;showTitle=false&amp;size=11331&amp;status=done&amp;style=none&amp;taskId=u07515801-2ee5-4a97-9377-685cbb7dfbf&amp;title=&amp;width=474.17365933429153" alt="image.png"></p><h4 id="4-3-2-基本用法"><a href="#4-3-2-基本用法" class="headerlink" title="4.3.2 基本用法"></a>4.3.2 基本用法</h4><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了，如下图(<strong>绿色为接口，蓝色为实现类</strong>)</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202309131733746.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义接口继承IService接口，需要指定泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义实现类继承ServiceImpl，实现自定义接口，需要指定对应的Mapper和泛型，对应的Mapper需要继承BaseMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//user.setId(5L);</span></span><br><span class="line">    user.setUsername(<span class="string">&quot;kun_&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>, <span class="string">&quot;英语老师&quot;</span>, <span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    user.setStatus(UserStatus.NORMAL);</span><br><span class="line">    userService.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userService.list(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().select(User::getUsername, User::getBalance).le(User::getBalance, <span class="number">999</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-批量新增"><a href="#4-3-3-批量新增" class="headerlink" title="4.3.3 批量新增"></a>4.3.3 批量新增</h4><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。<br>首先我们测试逐条插入数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">buildUser</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;&quot;</span> + (<span class="number">18688190000L</span> + i));</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(user.getCreateTime());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688182456300-08cbaea5-afd5-44e2-9e55-868595671548.png#averageHue=%23f6f8f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=244&amp;id=u1934bf0f&amp;originHeight=303&amp;originWidth=1525&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107948&amp;status=done&amp;style=none&amp;taskId=ua11c6515-de40-48dc-8d87-8a2dd7f255b&amp;title=&amp;width=1230.2520614030323" alt="image.png"><br>可以看到速度非常慢。</p><p>然后再试试MybatisPlus的批处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备10万条数据</span></span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        list.add(buildUser(i));</span><br><span class="line">        <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行最终耗时如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688182059553-db1fa9e1-3b14-47a3-be33-f7f0e7805cea.png#averageHue=%23f6f8f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=246&amp;id=udd2b6e84&amp;originHeight=305&amp;originWidth=1528&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107606&amp;status=done&amp;style=none&amp;taskId=ue141c82d-fd21-4e29-a2b5-284f261341f&amp;title=&amp;width=1232.6722293926775" alt="image.png"><br>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p><p>不过，我们简单查看一下<code>MybatisPlus</code>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Preparing: INSERT INTO <span class="title function_">user</span> <span class="params">( username, password, phone, info, balance, create_time, update_time )</span> VALUES ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br></pre></td></tr></table></figure><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><p>该怎么做呢？</p><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：<br><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">cj-conn-prop_rewriteBatchedStatements</a><br>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p><p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688183132724-a20e7a12-396d-49b6-943b-3c26357a9b92.png#averageHue=%23f6f9f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=273&amp;id=ue336017d&amp;originHeight=338&amp;originWidth=1450&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=112189&amp;status=done&amp;style=none&amp;taskId=ub2301dcf-ab09-4346-8378-f324485339d&amp;title=&amp;width=1169.7478616618994" alt="image.png"></p><p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688194832130-aecf5c68-30f2-4925-862a-fdb15f4f4614.png#averageHue=%23f5f8f4&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=515&amp;id=u39f69fec&amp;originHeight=639&amp;originWidth=1509&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=157560&amp;status=done&amp;style=none&amp;taskId=uc973871c-05ff-42b0-9e86-297efa8cf5d&amp;title=&amp;width=1217.3444987915905" alt="image.png"><br>最终，SQL被重写了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688194899752-20700857-a5d3-4d14-bff0-6351fbf68a5b.png#averageHue=%23f4f4f3&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=662&amp;id=ub69cdd4a&amp;originHeight=820&amp;originWidth=1438&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=81949&amp;status=done&amp;style=none&amp;taskId=u8db236a7-b1a5-4f0d-b1e9-6c8974cec1e&amp;title=&amp;width=1160.0671897033183" alt="image.png"></p><blockquote><p>总结:</p><ol><li><p>插入大量数据的时候，使用<code>saveBatch</code>批量插入一定数量的数据而不是在循环里面一条一条插入数据<code>save</code></p></li><li><p>mysql配置文件中开启批处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp？rewriteBatchedStatements=true</span> <span class="comment">#rewriteBatchedStatements=true 开启批处理</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-3-4-Lambda"><a href="#4-3-4-Lambda" class="headerlink" title="4.3.4 Lambda"></a>4.3.4 Lambda</h4><p>Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p><p>基于Lambda查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询1个</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">rose</span> <span class="operator">=</span> userService.lambdaQuery()</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">            .one(); <span class="comment">// .one()查询1个</span></span><br><span class="line">    System.out.println(<span class="string">&quot;rose = &quot;</span> + rose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.查询多个</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .list(); <span class="comment">// .list()查询集合</span></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.count统计</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userService.lambdaQuery()</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .count(); <span class="comment">// .count()则计数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现lambdaQuery方法中除了可以构建条件，而且根据链式编程的最后一个方法来判断最终的返回结果，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p>lambdaQuery还支持动态条件查询。比如下面这个需求：</p><blockquote><p>定义一个方法，接收参数为username、status、minBalance、maxBalance，参数可以为空。</p><ul><li>如果username参数不为空，则采用模糊查询;</li><li>如果status参数不为空，则采用精确匹配；</li><li>如果minBalance参数不为空，则余额必须大于minBalance</li><li>如果maxBalance参数不为空，则余额必须小于maxBalance</li></ul></blockquote><p>这个需求就是典型的动态查询，在业务开发中经常碰到，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryUser</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = queryUser(<span class="string">&quot;o&quot;</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUser</span><span class="params">(String username, Integer status, Integer minBalance, Integer maxBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span> , User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Lambda更新：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, <span class="number">800</span>) <span class="comment">// set balance = 800</span></span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Jack&quot;</span>) <span class="comment">// where username = &quot;Jack&quot;</span></span><br><span class="line">            .update(); <span class="comment">// 执行Update</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lambdaUpdate()</code>方法后基于链式编程，可以添加<code>set</code>条件和<code>where</code>条件。但最后一定要跟上<code>update()</code>，否则语句不会执行。</p><p>lambdaUpdate()同样支持动态条件，例如下面的需求：</p><blockquote><p>基于IService中的lambdaUpdate()方法实现一个更新方法，满足下列需求：</p><ul><li>参数为balance、id、username</li><li>id或username至少一个不为空，根据id或username精确匹配用户</li><li>将匹配到的用户余额修改为balance</li><li>如果balance为0，则将用户status修改为冻结状态</li></ul></blockquote><p>实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    updateBalance(<span class="number">0L</span>, <span class="number">1L</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBalance</span><span class="params">(Long balance, Long id, String username)</span>&#123;</span><br><span class="line">    userService.lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, balance)</span><br><span class="line">            .set(balance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>)</span><br><span class="line">            .eq(id != <span class="literal">null</span>, User::getId, id)</span><br><span class="line">            .eq(username != <span class="literal">null</span>, User::getId, username)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-静态工具"><a href="#4-4-静态工具" class="headerlink" title="4.4.静态工具"></a>4.4.静态工具</h3><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688195216843-3b5850bb-92f9-4eb8-a41d-db93d9606e5d.png#averageHue=%23fbf9f8&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=725&amp;id=u51b23a1d&amp;originHeight=899&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107357&amp;status=done&amp;style=none&amp;taskId=u2b03fdcc-1631-4557-a076-94311862860&amp;title=&amp;width=829.3108977851259" alt="image.png"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Db.getById(<span class="number">1L</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 利用Db实现复杂条件查询</span></span><br><span class="line">    List&lt;User&gt; list = Db.lambdaQuery(User.class)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">            .list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-拓展功能"><a href="#5-拓展功能" class="headerlink" title="5.拓展功能"></a>5.拓展功能</h2><h3 id="5-1-代码生成插件"><a href="#5-1-代码生成插件" class="headerlink" title="5.1 代码生成插件"></a>5.1 代码生成插件</h3><ol><li>安装插件</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688091751297-6918cbf6-d2c2-4ae1-a88e-05b53deeb007.png#averageHue=%23f6f5f5&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=618&amp;id=u6048bc70&amp;originHeight=766&amp;originWidth=1507&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107031&amp;status=done&amp;style=none&amp;taskId=u820e9b5e-098b-47f6-8ff5-fd30fe3b308&amp;title=&amp;width=1215.7310534651604" alt="image.png"></p><ol><li>配置数据库</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196733527-e4bc1921-cc23-4f8c-92f9-b917ec261523.png#averageHue=%23d9ceb7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=190&amp;id=u1be4369c&amp;originHeight=236&amp;originWidth=1221&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=37503&amp;status=done&amp;style=none&amp;taskId=u6232584f-51f8-4184-8a55-86890ee8ade&amp;title=&amp;width=985.0083717856409" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196793381-60acee0a-500e-4b4d-8b3b-aa4cd3af80c8.png#averageHue=%23f4f4f4&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=317&amp;id=u4cc24dc2&amp;originHeight=393&amp;originWidth=629&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=17584&amp;status=done&amp;style=none&amp;taskId=ud0ec4100-04a0-443a-bc58-9a65002e9fe&amp;title=&amp;width=507.4285551622998" alt="image.png"></p><ol><li><p>生成代码</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196861061-152ee240-f56d-47a3-9c74-7fc67a82dd17.png#averageHue=%23d7cbb2&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=153&amp;id=u30692977&amp;originHeight=190&amp;originWidth=1109&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=31203&amp;status=done&amp;style=none&amp;taskId=u8299bd93-3309-486f-bd92-3804ced967f&amp;title=&amp;width=894.6554335055492" alt="image.png"></p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688197265415-9a6942d2-b53f-4788-aa90-d2308690c8c6.png#averageHue=%23f3e9e8&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=489&amp;id=u319836cf&amp;originHeight=606&amp;originWidth=1376&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=129466&amp;status=done&amp;style=none&amp;taskId=u0e1d05ee-af06-445f-9ad7-8769e084e36&amp;title=&amp;width=1110.050384583982" alt="image.png"></p><h3 id="5-2-逻辑删除"><a href="#5-2-逻辑删除" class="headerlink" title="5.2 逻辑删除"></a>5.2 逻辑删除</h3><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。<br>:::warning<br><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。<br>:::</p><p>例如，我们给<code>address</code>表添加一个逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address</span><br><span class="line"><span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后给<code>Address</code>实体添加<code>deleted</code>字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688202948723-552f1db1-84ad-4b78-99ee-28ac6f2f5159.png#averageHue=%23f6f8f3&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=389&amp;id=ua4217141&amp;originHeight=482&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=53297&amp;status=done&amp;style=none&amp;taskId=u2aa3f980-e287-47b8-8b36-3ccbc249d3a&amp;title=&amp;width=690.5545997121282" alt="image.png"></p><p>接下来，我们要在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><p>测试：<br>首先，我们执行一个删除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688203124731-99a02bc4-df99-4bcf-a38d-4ebf0e82bf6b.png#averageHue=%23f9fcf7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=312&amp;id=uc2faa0ed&amp;originHeight=387&amp;originWidth=1347&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=141086&amp;status=done&amp;style=none&amp;taskId=u07bf156e-f27f-452a-ad3d-64f60e95502&amp;title=&amp;width=1086.6554273507438" alt="image.png"></p><p>查询一下试试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688203269018-391c8134-3442-43a8-893f-08f562155ae7.png#averageHue=%23f9fcf7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=452&amp;id=uedd32412&amp;originHeight=560&amp;originWidth=1328&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=233822&amp;status=done&amp;style=none&amp;taskId=ub7380c63-d002-4cad-a704-6bf18ff3948&amp;title=&amp;width=1071.3276967496568" alt="image.png"></p><p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p><p>:::warning<br><strong>注意</strong>：<br>逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。<br>:::</p><h3 id="5-3-通用枚举"><a href="#5-3-通用枚举" class="headerlink" title="5.3 通用枚举"></a>5.3 通用枚举</h3><p>User类中有一个用户状态字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688205450700-35d2bce8-ec2d-42f2-8977-bd7ebf101afd.png#averageHue=%23f5f7f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=349&amp;id=u29e826cf&amp;originHeight=432&amp;originWidth=688&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=47157&amp;status=done&amp;style=none&amp;taskId=u2b1c794b-d20f-478d-aeff-87d6913e1f2&amp;title=&amp;width=555.025192291991" alt="image.png"><br>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p><p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h4 id="5-3-1-定义枚举"><a href="#5-3-1-定义枚举" class="headerlink" title="5.3.1.定义枚举"></a>5.3.1.定义枚举</h4><p>我们定义一个用户状态的枚举：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688206435536-1e0ebd0f-4185-4e4b-8dc8-8b2dab235f44.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=403&amp;id=uf7e016c3&amp;originHeight=499&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=53038&amp;status=done&amp;style=none&amp;taskId=u5e55ee20-4f76-4516-b0f2-c1a81d103fc&amp;title=&amp;width=738.1512368418192" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把<code>User</code>类中的<code>status</code>字段改为<code>UserStatus</code> 类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688207388430-424b3be8-4c08-4c31-aa73-7b41e271a760.png#averageHue=%23f6f7f2&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=340&amp;id=ua014304a&amp;originHeight=422&amp;originWidth=714&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=47282&amp;status=done&amp;style=none&amp;taskId=u2e238813-09bf-4ab7-8ddf-8c8f581014c&amp;title=&amp;width=575.9999815355836" alt="image.png"></p><p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。<br><code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688206653554-4bc9d7a3-3c39-4981-a8ba-6f06ba7df734.png#averageHue=%23f8fbf6&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=418&amp;id=ua72da7b8&amp;originHeight=518&amp;originWidth=635&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=67892&amp;status=done&amp;style=none&amp;taskId=ua1ac546f-70cf-4525-a941-afce46f09a2&amp;title=&amp;width=512.2688911415904" alt="image.png"></p><h4 id="5-3-2-配置枚举处理器"><a href="#5-3-2-配置枚举处理器" class="headerlink" title="5.3.2.配置枚举处理器"></a>5.3.2.配置枚举处理器</h4><p>在application.yaml文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3.测试"></a>5.3.3.测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = userService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688207514989-da3d683d-641b-4a05-8330-ec1818604dd4.png#averageHue=%23f7faf3&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=272&amp;id=u5c65f589&amp;originHeight=337&amp;originWidth=758&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=70020&amp;status=done&amp;style=none&amp;taskId=ub88fd551-ea20-4385-9696-bc4800cc4d4&amp;title=&amp;width=611.4957787170481" alt="image.png"></p><h3 id="5-4-字段类型处理器"><a href="#5-4-字段类型处理器" class="headerlink" title="5.4 字段类型处理器"></a>5.4 字段类型处理器</h3><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688212092835-57dab221-e046-48f4-907a-d3bf18fc2a30.png#averageHue=%23f7f6f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=245&amp;id=u3dcab959&amp;originHeight=304&amp;originWidth=761&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=31811&amp;status=done&amp;style=none&amp;taskId=ubba2f760-5128-4d52-9412-f54fceaf94a&amp;title=&amp;width=613.9159467066934" alt="image.png"><br>格式像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而目前<code>User</code>实体类中却是<code>String</code>类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688212175474-81e91aec-2ef3-4305-9dc6-28d20e139688.png#averageHue=%23f5f8f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=310&amp;id=u65d78d1d&amp;originHeight=384&amp;originWidth=814&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=46824&amp;status=done&amp;style=none&amp;taskId=u674ba30b-a2fd-4c65-9c1f-acc92e124de&amp;title=&amp;width=656.6722478570939" alt="image.png"></p><p>这样以来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。<br>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库是手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><p>接下来，我们就来看看这个处理器该如何使用。</p><h4 id="5-4-1-定义实体"><a href="#5-4-1-定义实体" class="headerlink" title="5.4.1 定义实体"></a>5.4.1 定义实体</h4><p>首先，我们定义一个单独实体类来与info字段的属性匹配：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215509372-226dae45-89f8-46e5-9cf2-a2d94dafebda.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=353&amp;id=u6e9cbd35&amp;originHeight=437&amp;originWidth=860&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=44479&amp;status=done&amp;style=none&amp;taskId=u3ef96d28-bf45-4adb-9583-cf6c2ce9cf8&amp;title=&amp;width=693.7814903649886" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-使用类型处理器"><a href="#5-4-2-使用类型处理器" class="headerlink" title="5.4.2 使用类型处理器"></a>5.4.2 使用类型处理器</h4><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215729313-c3987a13-e3fe-40f6-8028-e837fdfbee63.png#averageHue=%23f6f8f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=309&amp;id=u6e6612c3&amp;originHeight=383&amp;originWidth=978&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=49918&amp;status=done&amp;style=none&amp;taskId=u6a82025a-637a-4a02-bd01-036a53384b2&amp;title=&amp;width=788.9747646243708" alt="image.png"></p><p>测试可以发现，所有数据都正确封装到UserInfo当中了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215838909-45e8286d-85f4-4521-bede-9d3c8e8be109.png#averageHue=%23f9fbf6&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=278&amp;id=u822a8e35&amp;originHeight=345&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=92222&amp;status=done&amp;style=none&amp;taskId=u80ecd7f1-8bf6-4609-8484-22a05c2093f&amp;title=&amp;width=834.1512337644166" alt="image.png"></p><h3 id="5-5配置加密"><a href="#5-5配置加密" class="headerlink" title="5.5配置加密"></a>5.5配置加密</h3><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。</p><p>我们以数据库的用户名和密码为例。</p><h4 id="5-5-1-生成秘钥"><a href="#5-5-1-生成秘钥" class="headerlink" title="5.5.1.生成秘钥"></a>5.5.1.生成秘钥</h4><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MpDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成 16 位随机 AES 密钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">randomKey</span> <span class="operator">=</span> AES.generateRandomKey();</span><br><span class="line">        System.out.println(<span class="string">&quot;randomKey = &quot;</span> + randomKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;root&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;MySQL123&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">randomKey = 6234633<span class="type">a66fb399f</span></span><br><span class="line"><span class="variable">username</span> <span class="operator">=</span> px2bAbnUfiY8K/IgsKvscg==</span><br><span class="line">password = FGvCSEaOuga3ulDAsxw68Q==</span><br></pre></td></tr></table></figure><h4 id="5-5-2-修改配置"><a href="#5-5-2-修改配置" class="headerlink" title="5.5.2.修改配置"></a>5.5.2.修改配置</h4><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">mpw:QWWVnk1Oal3258x5rVhaeQ==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mpw:EUFmeH3cNAzdRGdOQcabWg==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br></pre></td></tr></table></figure><h4 id="5-5-3-测试"><a href="#5-5-3-测试" class="headerlink" title="5.5.3.测试"></a>5.5.3.测试</h4><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">--mpw.key=6234633a66fb399f</span></span><br></pre></td></tr></table></figure><p>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688218131368-7bba8307-998f-4709-86d1-b5f83d0b363d.png#averageHue=%23f5f7f3&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=392&amp;id=u0b3b23da&amp;originHeight=486&amp;originWidth=1089&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=87247&amp;status=done&amp;style=none&amp;taskId=ue867a34c-18ac-488a-b0c9-a77bdf4d99a&amp;title=&amp;width=878.5209802412472" alt="image.png"></p><p>然后随意运行一个单元测试，可以发现数据库查询正常。</p><h2 id="6-插件功能"><a href="#6-插件功能" class="headerlink" title="6.插件功能"></a>6.插件功能</h2><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><p>:::warning<br><strong>注意：</strong><br>使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除<br>:::</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="6-1-分页插件"><a href="#6-1-分页插件" class="headerlink" title="6.1.分页插件"></a>6.1.分页插件</h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。<br>所以，我们必须配置分页插件。</p><h3 id="6-1-1-配置分页插件"><a href="#6-1-1-配置分页插件" class="headerlink" title="6.1.1.配置分页插件"></a>6.1.1.配置分页插件</h3><p>在项目中新建一个配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688220120678-5d7b8c50-05f8-48f0-b32b-21a4e34dc56f.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=327&amp;id=u5dedcfcd&amp;originHeight=405&amp;originWidth=896&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=42888&amp;status=done&amp;style=none&amp;taskId=ufe639d17-598b-40d7-b932-3133320d017&amp;title=&amp;width=722.8235062407323" alt="image.png"><br>其代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-分页API"><a href="#6-1-2-分页API" class="headerlink" title="6.1.2.分页API"></a>6.1.2.分页API</h3><p>编写一个分页查询的测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的SQL如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688220648583-06cf029a-4d8e-4002-8b07-dc4db3787fa4.png#averageHue=%23f9fcf7&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=649&amp;id=u381c4f60&amp;originHeight=805&amp;originWidth=1336&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=300593&amp;status=done&amp;style=none&amp;taskId=u05c9d87e-599a-4d44-8b0c-62900316533&amp;title=&amp;width=1077.7814780553776" alt="image.png"></p><p>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure><h2 id="6-2-通用分页实体"><a href="#6-2-通用分页实体" class="headerlink" title="6.2.通用分页实体"></a>6.2.通用分页实体</h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><div class="table-container"><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>/users/page</td></tr><tr><td>请求参数</td><td>```json</td></tr><tr><td>{</td><td></td></tr><tr><td>“pageNo”: 1,</td><td></td></tr><tr><td>“pageSize”: 5,</td><td></td></tr><tr><td>“sortBy”: “balance”,</td><td></td></tr><tr><td>“isAsc”: false</td><td></td></tr><tr><td>}</td></tr></tbody></table></div><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">100006</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="number">50003</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1685100878975279298</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_9****&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;英文老师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">2000</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1685100878975279299</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_9****&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;英文老师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">2000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> |<br>| 特殊说明 | •如果排序字段为空，默认按照更新时间排序<br>•排序字段不为空，则按照排序字段排序 |</p><p>这里需要定义3个实体：</p><ul><li><code>PageQuery</code>：分页查询条件的实体，包含分页、排序参数</li><li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li><li><code>UserVO</code>：用户页面视图实体</li></ul><p>接下来我们就按照WEB开发的过程来实现这个接口。<br>首先，我们在项目中引入<code>spring-boot-starter-web</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hutool 工具包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，按<code>alt+8</code>打开<code>service</code>控制台，然后添加一个<code>SpringBoot</code>启动项：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286132717-ae9c6f4d-61a4-4b67-8da1-f4a8a7087ad7.png#averageHue=%23eff2ee&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=361&amp;id=uc2971250&amp;originHeight=448&amp;originWidth=1127&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61466&amp;status=done&amp;style=none&amp;taskId=u5c9cacfa-5ca3-4210-8749-71b5221414d&amp;title=&amp;width=909.1764414434211" alt="image.png"><br>弹窗中选择<code>Spring Boot</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286160462-818bf344-ed58-4ad5-b8aa-68948ce07025.png#averageHue=%23f5f4f2&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=465&amp;id=u2345aaa0&amp;originHeight=576&amp;originWidth=314&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=37539&amp;status=done&amp;style=none&amp;taskId=u18919e97-fda7-4d6b-88cf-71ffc02b73f&amp;title=&amp;width=253.31091624954234" alt="image.png"><br>弹窗中填写信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286326883-b48cd164-9f97-413f-9b8d-b88cb6fff6f4.png#averageHue=%23f3f1f1&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=608&amp;id=u7ac5c1e6&amp;originHeight=754&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=63187&amp;status=done&amp;style=none&amp;taskId=u8236bb84-f4d7-4993-94d6-676e7bc2812&amp;title=&amp;width=1129.4117285011444" alt="image.png"><br>其中不要忘了配置我们之前添加的数据加密的秘钥。</p><h3 id="6-2-1-实体"><a href="#6-2-1-实体" class="headerlink" title="6.2.1.实体"></a>6.2.1.实体</h3><p>首先是请求参数的<code>PageQuery</code>实体：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626203583-31dc37fe-6851-4aad-9438-8e1ebef5ce46.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=428&amp;id=u6de6995d&amp;originHeight=530&amp;originWidth=842&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=52422&amp;status=done&amp;style=none&amp;taskId=u0d14f487-0e76-4433-aa87-a89efcba08e&amp;title=&amp;width=679.2604824271168" alt="image.png"><br><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p><ul><li><code>pageNo</code>：页码</li><li><code>pageSize</code>：每页数据条数</li><li><code>sortBy</code>：排序字段</li><li><code>isAsc</code>：是否升序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义一个<code>UserVO</code>实体：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626250731-71aa58a9-80af-4191-91e7-e22c21ada79a.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=355&amp;id=u6a9535f1&amp;originHeight=440&amp;originWidth=834&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=42155&amp;status=done&amp;style=none&amp;taskId=ue520cb52-d625-447c-9e92-e2cd2ef7153&amp;title=&amp;width=672.8067011213959" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.enums.UserStatus;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用状态（1正常 2冻结）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，则是分页实体PageDTO:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626340460-6e86f884-5110-47b9-a6ca-429d3bcb9e47.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=403&amp;id=u4b113cac&amp;originHeight=499&amp;originWidth=900&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=48491&amp;status=done&amp;style=none&amp;taskId=ubd543d13-2a93-47cb-afc3-2884221e2f7&amp;title=&amp;width=726.0503968935927" alt="image.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line">    <span class="keyword">private</span> Integer pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-开发接口"><a href="#6-2-2-开发接口" class="headerlink" title="6.2.2.开发接口"></a>6.2.2.开发接口</h3><p>我们定义一个<code>UserController</code>，在<code>controller</code>中我们定义分页查询用户的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.dto.PageDTO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.query.PageQuery;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryUserByPage(query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在<code>UserService</code>中创建<code>queryUserByPage</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span>;</span><br></pre></td></tr></table></figure><p>接下来，在UserServiceImpl中实现该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    <span class="comment">// 1.1.分页条件</span></span><br><span class="line">    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">    <span class="comment">// 1.2.排序条件</span></span><br><span class="line">    <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.数据非空校验</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.有数据，转换</span></span><br><span class="line">    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">    <span class="comment">// 5.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为了让UserStatus枚举可以展示为文字描述，再给UserStatus中的desc字段添加<code>@JsonValue</code>注解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626889628-2c81911b-a714-410e-9cdf-76aa27946746.png#averageHue=%23f9fbf6&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=443&amp;id=ud16fa160&amp;originHeight=549&amp;originWidth=751&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74054&amp;status=done&amp;style=none&amp;taskId=u4d9fbbd2-ddee-48f9-9d79-30479deee8d&amp;title=&amp;width=605.8487200745424" alt="image.png"><br>启动项目，在页面查看：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626977575-46df0c79-8d99-4965-a1fa-7ef4379f81ba.png#averageHue=%23f8f8fe&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=603&amp;id=uc72ff4b0&amp;originHeight=748&amp;originWidth=749&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=77622&amp;status=done&amp;style=none&amp;taskId=u0c90cc4d-4b96-48bb-89b9-fe1fe18fa6f&amp;title=&amp;width=604.2352747481121" alt="image.png"></p><h3 id="6-2-3-改造PageQuery实体"><a href="#6-2-3-改造PageQuery实体" class="headerlink" title="6.2.3.改造PageQuery实体"></a>6.2.3.改造PageQuery实体</h3><p>在刚才的代码中，从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦的。<br>我们完全可以在<code>PageQuery</code>这个实体中定义一个工具方法，简化开发。<br>像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们在开发也时就可以省去对从<code>PageQuery</code>到<code>Page</code>的的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建条件</span></span><br><span class="line">Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br></pre></td></tr></table></figure><h3 id="6-2-4-改造PageDTO实体"><a href="#6-2-4-改造PageDTO实体" class="headerlink" title="6.2.4.改造PageDTO实体"></a>6.2.4.改造PageDTO实体</h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。</p><p>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终，业务层的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终查询的结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688291665223-e96361ac-d315-4d39-b54a-9c54083665f2.png#averageHue=%23f8f9fe&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=614&amp;id=u88be7c7b&amp;originHeight=761&amp;originWidth=891&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74030&amp;status=done&amp;style=none&amp;taskId=u44f43f7a-6fb4-4c98-92bf-32cd49ec211&amp;title=&amp;width=718.7898929246568" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
