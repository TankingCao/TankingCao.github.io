<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="https://htmlpreview.github.io/?https://github.com/TankingCao/note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html">计算机网络</a></h1><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><blockquote><p>计算机网络在信息时代中的作用：21世纪是以数字化、网络化、信息化为重要特征的信息时代，作为信息的最大载体和传输媒介，网络已成为这个信息时代的核心基础</p></blockquote><h3 id="1-2-定义与分类"><a href="#1-2-定义与分类" class="headerlink" title="1.2 定义与分类"></a>1.2 定义与分类</h3><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p>简单定义：==硬件==（独立和连接）+==软件==（协议）+==目的==（共享和通信）</p><blockquote><p>==<strong>计算机网络就是以传输信息为基本目的，用通信线路和通信设备将多个计算机连接起来的计算机系统的集合</strong>==</p></blockquote><h4 id="1-2-2-分类"><a href="#1-2-2-分类" class="headerlink" title="1.2.2 分类"></a>1.2.2 分类</h4><blockquote><p>按网络覆盖范围进行分类</p></blockquote><ol><li>局域网（Local Area Network,<code>LAN</code>，一个实验室、一幢楼、一个校园）</li><li>城域网（Metropolitan Area Network,<code>MAN</code>，几个街区甚至整个城市，5-50 km）</li><li>广域网（Wide Area Network,<code>WAN</code>，覆盖一个国家或地区甚至几个洲，也称为<strong>远程网</strong>）</li><li>个人区域网（Personal Area Network,<code>PAN</code>，10 m以内）</li></ol><blockquote><p>按网络的使用者进行分类</p></blockquote><ol><li>公用网（所有愿意缴纳费用的人都能使用）</li><li>专用网（专门为本单位的特殊业务工作建造的，例如，军队、铁路、电力等系统）</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.TZiqFW.png" alt="计算机网络分类" title='计算机网络的分类' /></p><h3 id="1-3-互联网概述"><a href="#1-3-互联网概述" class="headerlink" title="1.3 互联网概述"></a>1.3 互联网概述</h3><h4 id="1-3-1-网络的网络"><a href="#1-3-1-网络的网络" class="headerlink" title="1.3.1 网络的网络"></a>1.3.1 网络的网络</h4><ol><li>网络</li></ol><blockquote><p>==网络==由==若干节点==（Node）和连接这些节点的==链路==(Link)组成</p><p>节点：可以是计算机、集线器、交换机、路由器</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224626941.png" title="网络" style="zoom:80%;" /></p><ol><li>==互连网络==（internet，通用名词，注意和 Internet互联网 区分）</li></ol><blockquote><p>将网络用路由器连接起来就成了互连网络，因此互连网络是==网络的网络==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224534363.png" title="互连网络就是网络的网络" style="zoom:80%;" /></p><blockquote><p>总结：==<strong>网络把许多计算机连接在一起，而互联网络则把许多网络连接在一起</strong>==</p></blockquote><ol><li>==互联网==（Internet，也称 因特网）</li></ol><blockquote><p>当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，==采用TCP/IP协议作为通信规则==，前身是美国的阿帕网（==ARPANet==）</p></blockquote><ol><li>==边缘部分==：用户直接使用的</li><li>==核心部分==：为边缘部分提供服务的</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024224804841.png" title="woc,O" style="zoom: 67%;" /></p><h4 id="1-3-2-互联网结构发展的三个阶段"><a href="#1-3-2-互联网结构发展的三个阶段" class="headerlink" title="1.3.2 互联网结构发展的三个阶段"></a>1.3.2 互联网结构发展的三个阶段</h4><ol><li>第一阶段：从单个网络ARPANET向互连网络发展</li><li>第二阶段：逐步建成三级结构的互联网</li><li>第三阶段：逐渐形成多层次的ISP结构的互联网</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225143618.png" title="ISP结构的互联网" style="zoom: 67%;"/></p><h3 id="1-4-电路交换和分组交换"><a href="#1-4-电路交换和分组交换" class="headerlink" title="1.4 电路交换和分组交换"></a>1.4 电路交换和分组交换</h3><h4 id="1-4-1-电路交换"><a href="#1-4-1-电路交换" class="headerlink" title="1.4.1 电路交换"></a>1.4.1 电路交换</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225354835.png" alt="电路交换"></p><blockquote><p>这种必须经过</p><ol><li><p><code>建立连接</code>（分配通信资源）</p></li><li><p><code>通信</code>（一直占用通信资源）</p></li><li><p><code>释放连接</code>（归还通信资源）</p></li></ol><p>三个步骤的交换方式称为==电路交换==</p><p>电路交换：电路交换是指在通信开始之前，建立一条专用的物理连接，然后在通信过程中一直占用这条连接，直到通信结束。在这个过程中，数据被分成固定大小的数据包，每个数据包都被分配一个专用的物理通路。</p><p>优点：传输==速度快==</p><p>缺点：连接建立需要时间，且连接一旦建立就无法被其他通信使用（==效率很低==）</p></blockquote><h4 id="1-4-2-报文交换"><a href="#1-4-2-报文交换" class="headerlink" title="1.4.2 报文交换"></a>1.4.2 报文交换</h4><blockquote><p>整个报文传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p></blockquote><h4 id="1-4-3-分组交换"><a href="#1-4-3-分组交换" class="headerlink" title="1.4.3 分组交换"></a>1.4.3 分组交换</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231024225503293.png" alt="分组交换" style="zoom: 80%;" /></p><blockquote><p>我们通常把要发送的整块数据称为一个==报文==（Message）</p><p>发送报文之前，先将报文划分为一个个更小的等长的数据段，在数据段前面加上==首部==（又称为==包头==）就构成了==分组==（又称为==包==）</p><p>分组交换：分组交换是指==将报文分成较小的数据包==，每个数据包都带有<strong>目标地址</strong>和<strong>源地址</strong>等信息，然后通过网络传输。在传输过程中，每个数据包都独立传输，可以通过不同的路径到达目的地，由于每个分组交换机都是先存储下来再转发出去，因此该方法被称为<span style='color:rgb(255, 107, 107);font-weight:bold'>存储转发</span>方式</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.hVntPh.png" alt="交换方式对比"></p><h3 id="1-5-计算机网络的主要性能指标"><a href="#1-5-计算机网络的主要性能指标" class="headerlink" title="1.5 计算机网络的主要性能指标"></a>1.5 计算机网络的主要性能指标</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1. 速率"></a>1. 速率</h4><blockquote><ol><li><p>==数据的传输速率==，也称为==数据率==、==比特率== 1字节(byte)=8比特(bit)</p></li><li><p>单位是 <code>bit/s 或 bps</code> ,比特是数据量的单位，是一个==二进制数字==(0或1)</p></li><li>一般来说，表示速率时==<script type="math/tex">k = 10^{3}</script>==,表示数据时，==<script type="math/tex">k = 2^{10}</script>==</li></ol></blockquote><p><img src='https://gitee.com/clibin/image-bed/raw/master/CopyQ.aGEcPX.png' alt='速率'></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2. 带宽"></a>2. 带宽</h4><ol><li><p>带宽本来是指某个==信号具有的频带宽度==，表示通信线路允许通过的信号频带范围,单位为赫兹</p></li><li><p>计算机网络中，带宽表示网络某通道传输能力，即==最高数据率==,单位为==比特每秒==（bit/s）</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.UEfjHW.png" alt='带宽'/></p></li></ol><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3. 吞吐量"></a>3. 吞吐量</h4><blockquote><p>也称为==吞吐率==，表示单位时间内通过某个网络（或信道、接口）的数据量</p></blockquote><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><blockquote><p>时延是指==数据从网络的一端传送到另外一端所需要的时间==，也称为==延迟==或==迟延==</p><p>网络中的时延通常由以下几个不同的部分组成：</p><ol><li><p>==发送时延：主机或路由器将整个分组的所有比特发送到通信线路上所需要的时间==</p><script type="math/tex; mode=display">发送时延 = \frac{分组长度}{发送速率}</script></li><li><p>==传播时延：是电磁波在信道中传播一定距离所花费的时间==</p><script type="math/tex; mode=display">传播时延 = \frac{信道长度}{电磁波在信道上的传播速度}</script></li><li><p>处理时延：主机或路由器在收到分组时处理分组花费的时间（一般不方便计算）</p></li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.hzERwE.png" alt='时延'/></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261920366.png" alt="时延"></p><h4 id="5-时延带宽积-往返时间-利用率-丢包率"><a href="#5-时延带宽积-往返时间-利用率-丢包率" class="headerlink" title="5. 时延带宽积 往返时间 利用率 丢包率"></a>5. 时延带宽积 往返时间 利用率 丢包率</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.XBpSgv.png" alt="" style="zoom:;" /></p><h3 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h3><h4 id="1-6-1-网络协议"><a href="#1-6-1-网络协议" class="headerlink" title="1.6.1 网络协议"></a>1.6.1 网络协议</h4><p>网络协议主要由以下三要素组成：</p><ol><li>==语法：数据与控制信息的结构或格式==（例如，地址字段多长以及它在分组的什么位置）</li><li>==语义：各个控制信息的具体含义==（需要发出何种控制信息、完成何种动作及做出何种响应）</li><li>==同步：事件实现的顺序和时间的详细说明==（数据何时发出以及以什么速率发出）</li></ol><h4 id="1-6-2-分层体系结构"><a href="#1-6-2-分层体系结构" class="headerlink" title="1.6.2 分层体系结构"></a>1.6.2 分层体系结构</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.uQqXEZ.png" alt="常见的计算机网络分层体系结构"></p><h4 id="1-6-3-原理体系结构"><a href="#1-6-3-原理体系结构" class="headerlink" title="1.6.3 原理体系结构"></a>1.6.3 原理体系结构</h4><blockquote><p>我们学习的是具有五层协议的原理体系结构</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.EvnJQE.png" alt="原理体系结构"></p><h4 id="1-6-4-实体、协议和服务"><a href="#1-6-4-实体、协议和服务" class="headerlink" title="1.6.4 实体、协议和服务"></a>1.6.4 实体、协议和服务</h4><blockquote><p><strong>==协议是水平的,服务是垂直的==</strong></p><ol><li>实体：任何可发送或接收信息的硬件或软件进程</li><li><span style='color: #ff6b6b'>协议</span>：==<strong>控制两个或多个对等实体之间通信的规则的集合</strong>==</li><li>==<strong>下层通过层级接口向上层提供服务，下面的协议对上面的实体是”透明“的</strong>==</li><li>透明：某个实际存在的事物看起来好像不存在一样</li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/CopyQ.ZGZDeQ.png" alt="实体、协议和服务"></p><p><img src="https://cdn.processon.com/62913fa9e4b0c71a3a81421f?e=1653689786&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-WUsRKcHkAR_OnyY966rAE8wIOw=" alt="TCP/IP参考模型中的协议"></p><h3 id="1-7-相关习题"><a href="#1-7-相关习题" class="headerlink" title="1.7 相关习题"></a>1.7 相关习题</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261924745.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261925145.png" alt=""></p><h3 id="1-8-思维导图和习题"><a href="#1-8-思维导图和习题" class="headerlink" title="1.8 思维导图和习题"></a>1.8 思维导图和习题</h3><ol><li><a href="https://www.kdocs.cn/view/l/cqzI95zH7t6v">第1章 概述（思维导图）</a></li><li><a href="https://www.kdocs.cn/view/l/cmCC5Updax17">第1章 概述 习题 (kdocs.cn)</a></li></ol><hr><h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h2><blockquote><p>==<strong>任务：怎样在连接各种计算机的传输媒体上传输数据比特流</strong>==（使数据链路层感觉不到各种传输媒体之间的差异，只需要使用物理层服务就能传输比特流，不必关心具体怎么实现）</p></blockquote><h3 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261930116.png" alt="物理层的基本概念"></p><h3 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h3><h4 id="2-2-1-数据通信的基础知识"><a href="#2-2-1-数据通信的基础知识" class="headerlink" title="2.2.1 数据通信的基础知识"></a>2.2.1 数据通信的基础知识</h4><h4 id="2-2-2-编码与调制"><a href="#2-2-2-编码与调制" class="headerlink" title="2.2.2 编码与调制"></a>2.2.2 编码与调制</h4><ol><li><p>定义</p><ul><li>==模拟信号==：消息的参数的取值是连续的</li><li><p>==数字信号==：消息的参数的取值是离散的</p></li><li><p>==编码==：将数字数据转换成数字信号的过程</p></li><li>==调制==：将数字数据转换成模拟信号的过程</li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262020595.png" alt="编码与调制"></p><ol><li>常用编码方式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262040597.png" alt="常用编码方式"></p><ol><li>基本的调制方法</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262047837.png" alt="基本的调制方法"></p><ol><li><strong>==相位调制==</strong></li></ol><blockquote><p><strong>8相位调制</strong>表示8种状态，只需要<strong>3个比特</strong>(二进制，$2^3=8$)即可,所以<strong>1个码元可以承载3个比特</strong>，<strong>==数据传输率 = 3*波特率==</strong>，以此类推</p></blockquote><h4 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262054137.png" alt="信号失真"></p><blockquote><p>==<strong>奈式准则</strong>==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262059898.png" alt="奈式准则"></p><blockquote><p><strong>==香农公式==</strong></p><script type="math/tex; mode=display">c = W \cdot \log_{2}(1 + \frac{S}{N})</script><p>==知道信噪比(dB)求S/N，假设信噪比为30dB==</p><ol><li><script type="math/tex; mode=display">30 = 10 \cdot \log_{10}(\frac{S}{N})</script></li><li><script type="math/tex; mode=display">3 = \log_{10}(\frac{S}{N})</script></li><li><script type="math/tex; mode=display">\frac{S}{N} = 10^3</script></li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262102013.png" alt="香农公式"></p><blockquote><ol><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想==提高信息的传输速率==就必须采用==多元制==（更好的调制方法）和努力==提高信道中的信噪比==</li><li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地==接近香农公式给出的传输速率极限==</li></ol></blockquote><h4 id="2-2-4-传输方式"><a href="#2-2-4-传输方式" class="headerlink" title="2.2.4 传输方式"></a>2.2.4 传输方式</h4><ol><li>并行传输和串行传输</li></ol><blockquote><ul><li>并行传输速度是串行传输的==n倍==，但是<span color='rgb(1,2,3)'>成本高</span>==所以长距离传输使用串行传输==</li><li>远距离传输使用串行传输，计算机内部使用并行传输</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262005937.png" alt="并行传输和串行传输"></p><ol><li>异步传输和同步传输</li></ol><blockquote><p>异步传输==字节之间异步==，但是要添加==开始码==和==停止码==作为引导</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262010168.png" alt="异步传输和同步传输"  /></p><ol><li>单工、半双工和全双工通信</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310262014965.png" alt="单工、半双工和全双工通信"></p><h3 id="2-3-物理层下的传输媒体（了解即可）"><a href="#2-3-物理层下的传输媒体（了解即可）" class="headerlink" title="2.3 物理层下的传输媒体（了解即可）"></a>2.3 物理层下的传输媒体（了解即可）</h3><h4 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h4><ol><li><strong>同轴电缆</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261938546.png" alt="同轴电缆"></p><ol><li><strong>双绞线</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261942966.png" alt="双绞线"></p><ol><li><strong>光纤</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261946552.png" alt="光纤"></p><h4 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h4><ol><li><strong>微波</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310261954118.png" alt="微波"></p><ol><li>其他无线电波</li><li>红外线和可见光</li></ol><h3 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h3><blockquote><p>复用：当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术==在一条物理线路上建立多条通信信道==来共享传输媒体的带宽。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231027222210209.png" alt="信道复用" style="zoom:80%;" /></p><h4 id="2-4-1-频分复用"><a href="#2-4-1-频分复用" class="headerlink" title="2.4.1 频分复用"></a>2.4.1 频分复用</h4><blockquote><p><strong>频分复用</strong>(Frequency-division multiplexing,<code>FDM</code>):==将多路基带信号调制到不同频率载波==上，再进行==叠加形成一个复合信号==,接收端的分用器通过滤波将各路信号滤出，将合成的复合信号恢复成原始的多路信号。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310272254062.png" style="zoom: 67%;" /></p><h4 id="2-4-2-时分复用"><a href="#2-4-2-时分复用" class="headerlink" title="2.4.2 时分复用"></a>2.4.2 时分复用</h4><blockquote><p>时分复用(Time Division Multiplexing,<code>TDM</code>)：将传输线路的带宽资源==按时间轮流分配==给不同的用户，用户只能在分配的时间里使用线路传输数据（类似于==时间片轮转==）</p><p>存在的不足：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。（如果A暂时不使用信道，其他用户正常使用，时分复用还是会给A分配时间，而且这段时间内其他用户也不能使用）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310272254453.png" alt="时分复用" style="zoom: 67%;" /></p><blockquote><p>统计时分复用(statistical time division multiplexing,<code>STDM</code>):==动态地按需分配==共用信道的时隙，只将需要传送数据的终端接入共用信道，可以提高信道的利用率</p><p>帧与帧之间留有空隙用来存储用户的地址信息，因为不是固定的分配给某个用户</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310281701023.png" alt="STDM"></p><h4 id="2-4-3-波分复用"><a href="#2-4-3-波分复用" class="headerlink" title="2.4.3 波分复用"></a>2.4.3 波分复用</h4><blockquote><p>波分复用(Wavelength Division Multiplexing,<code>WDM</code>)就是==光的频分复用==。使用一根光纤来同时传输多个光载波信号。现在已能做到在一根光纤上复用几十路或更多路数的光载波信号。</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310282020333.png" alt="波分复用"></p><h4 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h4><blockquote><ul><li>码分复用(Code Division Multiplexing,<code>CDM</code>)一种共享信道的方法。</li><li>由于该技术主要用于无线多址接入（本书中我们不严格区分多址与复用）人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。</li><li><p>每一个用户可以在同样的时间使用同样的频带进行通信。==各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰==。</p></li><li><p>最初用于军事，因为这种系统发送的信号==有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现==</p></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310282039043.png" alt="码分复用"></p><blockquote><p>规格化内积：将码片序列先写成+1和-1的向量</p><p>例如：==码片序列为（1101）&gt;&gt;&gt; 向量为(+1,+1,-1,+1)==</p><p>向量相乘/向量个数 = 内积</p><ul><li><strong>内积为1  &gt;&gt;&gt; 发送信号1</strong> ==发送的是自己的码片序列==</li><li><strong>内积为0  &gt;&gt;&gt; 未发送信号</strong> ==未发送数据==</li><li><strong>内积为-1 &gt;&gt;&gt; 发送信号0</strong> ==发送的是自己的码片序列的二进制反码==</li></ul></blockquote><h3 id="2-5-相关习题和资料"><a href="#2-5-相关习题和资料" class="headerlink" title="2.5 相关习题和资料"></a>2.5 相关习题和资料</h3><ol><li><a href="https://www.kdocs.cn/view/l/cfixYkxNJ7Ep">第2章 物理层 习题</a></li><li><a href="https://www.kdocs.cn/view/l/ckmnMjp5UQvK">第2章 物理层（思维导图）</a></li></ol><hr><h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h2><blockquote><p><strong>==任务：解决数据包在一个网络或一段链路上传输的问题==</strong></p></blockquote><h3 id="3-1-数据链路和帧"><a href="#3-1-数据链路和帧" class="headerlink" title="3.1 数据链路和帧"></a>3.1 数据链路和帧</h3><blockquote><ul><li>==链路==（Link）是指从一个节点到相邻节点的一段物理线路，而中间没有任何其他的交换节点</li><li>==数据链路==（Data Link）是基于链路的。当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把==实现这些协议的硬件和软件加到链路==上，就构成了数据链路</li><li>计算机中的==网络适配器==（俗称网卡）和其相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能</li><li>==帧==（Frame）是数据链路层的协议数据单元</li></ul></blockquote><h3 id="3-2-封装成帧和透明传输"><a href="#3-2-封装成帧和透明传输" class="headerlink" title="3.2 封装成帧和透明传输"></a>3.2 封装成帧和透明传输</h3><h4 id="3-2-1-封装成帧"><a href="#3-2-1-封装成帧" class="headerlink" title="3.2.1 封装成帧"></a>3.2.1 封装成帧</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310291347647.png" alt="封装成帧"></p><h4 id="3-2-2-透明传输问题"><a href="#3-2-2-透明传输问题" class="headerlink" title="3.2.2 透明传输问题"></a>3.2.2 透明传输问题</h4><blockquote><p><strong>==2. 透明传输问题出现原因==</strong>：上层应用交付的数据单元中可能==含有和帧定界符相同的数据==而被接收端误认为帧定界符从而导致错误。</p><p>如果不解决上述问题，则数据链路层就会==对上层交付的PDU的内容有所限制==，即==PDU中不能包含帧定界符==。显然，这样的数据链路层没有什么应用价值。</p><p>==<strong>透明传输</strong>==：数据链路层对上层交付的PDU的内容==没有任何限制==，就好像数据链路层不存在一样</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202310291859630.png" alt="透明传输问题" style="zoom: 67%;" /></p><h4 id="3-2-3-解决透明传输问题"><a href="#3-2-3-解决透明传输问题" class="headerlink" title="3.2.3 解决透明传输问题"></a>3.2.3 解决透明传输问题</h4><ol><li><strong>==字符填充==(字节填充)</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231029190744213.png" alt="字符填充"></p><ol><li><strong>==零比特填充==</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231029192326597.png" alt="零比特填充"></p><h3 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h3><blockquote><ol><li><p>==<strong>比特差错</strong>==：比特在传输过程中可能会产生差错，0可能变为1,1可能变为0，这叫比特差错，也称为<strong>==误码==</strong></p></li><li><p><strong>==误码率==</strong>：传输==错误的==比特数与所传输比特==总数==的比率称为误码率</p></li><li>使用==差错检测码==来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</li></ol></blockquote><h4 id="3-3-1-使用-循环冗余检验CRC"><a href="#3-3-1-使用-循环冗余检验CRC" class="headerlink" title="3.3.1 使用==循环冗余检验CRC=="></a>3.3.1 使用==循环冗余检验<code>CRC</code>==</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101192256040.png" alt="CRC"></p><h4 id="3-3-2-示例"><a href="#3-3-2-示例" class="headerlink" title="3.3.2 示例"></a>3.3.2 示例</h4><ol><li>发送方</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101193502184.png" alt="CRC"></p><ol><li>接收方</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101193959244.png" alt=""></p><h4 id="3-3-3-总结"><a href="#3-3-3-总结" class="headerlink" title="3.3.3 总结"></a><strong>3.3.3 总结</strong></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101194313756.png" alt=""></p><h3 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h3><h4 id="3-4-1-可靠传输的概念"><a href="#3-4-1-可靠传输的概念" class="headerlink" title="3.4.1 可靠传输的概念"></a>3.4.1 可靠传输的概念</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101194720144.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101195208168.png" alt=""></p><h3 id="3-5-可靠传输的实现机制"><a href="#3-5-可靠传输的实现机制" class="headerlink" title="3.5 可靠传输的实现机制"></a>3.5 可靠传输的实现机制</h3><h4 id="3-5-1-停止-等待协议-SW"><a href="#3-5-1-停止-等待协议-SW" class="headerlink" title="3.5.1 停止-等待协议(SW)"></a>3.5.1 停止-等待协议(SW)</h4><ol><li>基本原理</li></ol><blockquote><p>发送一个数据分组<code>DATA0</code>然后等待接收方发来确认信息<code>ACK0</code>后再传输下一个数据分组<code>DATA1</code> ，如果==超时未接收到==接收方发送的确认信息<code>ACK0</code>或者接==收到否认信息==<code>NAK</code>就重新发送上一个分组数据分组,数据分组和确认信息的编号都是用来区分和上一个分组或信息是否相同</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101204223808.png" alt="SW"></p><ol><li>停止等待协议的信道利用率</li></ol><blockquote><script type="math/tex; mode=display">利用率 = \frac{数据发送时延}{数据发送时延+2个传播时延+确认信息发送时延}</script><p>确认信息的发送时延一般忽略不计</p><p><strong>总结：当往返时间远大于数据帧的发送时延时，信道利用率很低，如果出现超时重传，信道利用率更低</strong>（卫星链路）</p></blockquote><h4 id="3-5-2-回退N帧协议（GBN）"><a href="#3-5-2-回退N帧协议（GBN）" class="headerlink" title="3.5.2 回退N帧协议（GBN）"></a>3.5.2 回退N帧协议（GBN）</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101215803331.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101211215263.png" alt=""></p><h4 id="3-5-3-选择重传协议（SR）"><a href="#3-5-3-选择重传协议（SR）" class="headerlink" title="3.5.3 选择重传协议（SR）"></a>3.5.3 选择重传协议（SR）</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101212500499.png" alt=""></p><h3 id="3-6-点对点协议-PPP"><a href="#3-6-点对点协议-PPP" class="headerlink" title="3.6 点对点协议(PPP)"></a>3.6 点对点协议(<code>PPP</code>)</h3><ol><li>概述</li></ol><blockquote><p>==点对点协议==（Point-to-Point Protocol，PPP）是目前使用最广泛的点对点数据链路层协议</p><ol><li>==网络控制协议NCPs==</li><li>封装成帧</li><li>==链路控制协议LCP==</li></ol></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101213541707.png" alt="PPP"></p><ol><li>PPP的==帧格式==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101221019454.png" alt=""></p><ol><li>PPP的==透明传输==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103154439848.png" alt=""></p><ol><li>PPP的==状态图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231101221315932.png" alt=""></p><h3 id="3-7-媒体接入控制问题"><a href="#3-7-媒体接入控制问题" class="headerlink" title="3.7 媒体接入控制问题"></a>3.7 媒体接入控制问题</h3><h4 id="3-7-1-媒体接入控制-多址接入-问题"><a href="#3-7-1-媒体接入控制-多址接入-问题" class="headerlink" title="3.7.1 媒体接入控制/多址接入 问题"></a>3.7.1 媒体接入控制/多址接入 问题</h4><blockquote><p>如何协调多个发送站点和接收站点对一个共享传输媒体的占用（==多个媒体同时发送信号导致冲突的问题==）</p></blockquote><h4 id="3-7-2-静态划分信道"><a href="#3-7-2-静态划分信道" class="headerlink" title="3.7.2 静态划分信道"></a>3.7.2 静态划分信道</h4><blockquote><ul><li>频分多址</li><li>时分多址</li><li>码分多址</li></ul><p>==<strong>这种固定划分信道的方法非常不灵活，通常在物理层中使用，而不是数据链路层</strong>==</p></blockquote><h4 id="3-7-3-CSMA-CD协议"><a href="#3-7-3-CSMA-CD协议" class="headerlink" title="3.7.3 CSMA/CD协议"></a>3.7.3 <code>CSMA/CD</code>协议</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103161532858.png" alt=""></p><ol><li>==帧发送流程图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162311360.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163826951.png" alt=""></p><ol><li><strong>==争用期==  2τ ，即端到端传播时延的2倍</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162720907.png" alt=""></p><ol><li>==最小帧长==<br>&gt;<blockquote><p>   <strong>最小帧长 = 争用期 x 数据传输速率</strong></p><script type="math/tex; mode=display">   l = 2τ * 数据传输速率</script></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103162936995.png" alt=""></p><ol><li>==动态退避==：发生碰撞后进行重传，随着重传次数增加，退避时间也会逐渐增加，减小了碰撞的概率</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163318636.png" alt="image-20231103163318636"></p><ol><li>==帧接收流程图==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231103163952585.png" alt=""></p><h4 id="3-7-4-CSMA-CA协议"><a href="#3-7-4-CSMA-CA协议" class="headerlink" title="3.7.4 CSMA/CA协议"></a>3.7.4 <code>CSMA/CA</code>协议</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/202311062053040.png" alt=""></p><h3 id="3-8-MAC、IP地址、ARP协议"><a href="#3-8-MAC、IP地址、ARP协议" class="headerlink" title="3.8 MAC、IP地址、ARP协议"></a>3.8 <code>MAC</code>、<code>IP</code>地址、<code>ARP</code>协议</h3><h4 id="3-8-1-MAC地址"><a href="#3-8-1-MAC地址" class="headerlink" title="3.8.1 MAC地址"></a>3.8.1 <code>MAC</code>地址</h4><ol><li><strong>MAC地址</strong>是==对网络上各接口的唯一标识==，而不是对网络上各设备的唯一标识（路由器有多个接口，所以有多个MAC地址）</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109211711863.png" alt=""></p><ol><li>MAC地址格式<br>&gt;<blockquote><p>广播MAC地址为<strong>==FF-FF-FF-FF-FF-FF==</strong></p></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109212131157.png" alt=""></p><ol><li>MAC帧有三种：==单播、广播、多播==</li></ol><blockquote><p>单播帧：==一对一==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109213737953.png" alt=""></p><blockquote><p>广播帧：==一对全体==</p><p>广播地址：<code>FF-FF-FF-FF-FF-FF</code></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109214347270.png" alt=""></p><blockquote><p>多播帧：==一对多==</p><p>多播地址：==第二个数是奇数代表是多播地址==</p></blockquote><p><img src="https://cdn.processon.com/62942804e4b055af8b78ba06?e=1653880340&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:UhUsF4fqZnqyZWpsN-hM0r93O4Y=" alt=""></p><h4 id="3-8-2-IP地址"><a href="#3-8-2-IP地址" class="headerlink" title="3.8.2 IP地址"></a>3.8.2 <code>IP</code>地址</h4><blockquote><p>（网络层再详细介绍）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109220004217.png" alt=""></p><h4 id="3-8-3-ARP协议"><a href="#3-8-3-ARP协议" class="headerlink" title="3.8.3 ARP协议"></a>3.8.3 <code>ARP</code>协议</h4><blockquote><p>主机中保存了一个高速缓存表，==记录了IP和MAC的对应关系==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221234731.png" style="zoom: 67%;" /></p><blockquote><p>ARP协议动态获取MAC地址</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109221003126.png" alt=""></p><blockquote><p><strong>总结：<code>ARP</code>协议只能逐链路（相邻）使用，不能跨网络使用</strong></p></blockquote><h3 id="3-9-集线器和交换机的区别"><a href="#3-9-集线器和交换机的区别" class="headerlink" title="3.9 集线器和交换机的区别"></a>3.9 集线器和交换机的区别</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109222104719.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231109222736241.png" alt=""></p><h3 id="3-10-透明网桥的生成树协议STP"><a href="#3-10-透明网桥的生成树协议STP" class="headerlink" title="3.10 透明网桥的生成树协议STP"></a>3.10 透明网桥的生成树协议<code>STP</code></h3><blockquote><ul><li>为了提高以太网的==可靠性==，有时需要在两个以太网之间使用多个透明网桥来提供==冗余链路==</li><li>为了避免广播帧在环路中永久兜圈，透明网桥使用生成树协议<code>Spanning Tree Protocol</code>，可以在增加冗余链路提高网络可靠性的同时，又避免环路带来的问题</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231111200010935.png" alt=""></p><h3 id="3-11-虚拟局域网VLAN"><a href="#3-11-虚拟局域网VLAN" class="headerlink" title="3.11 虚拟局域网VLAN"></a>3.11 虚拟局域网<code>VLAN</code></h3><blockquote><p>虚拟局域网（<code>Virtual Local Area Network</code>，VLAN）是一种将局域网内的站点划分成与物理位置无关的逻辑组的技术，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求</p><p>==广播风暴==：<strong>广播风暴会浪费网络资源和各主机的CPU资源</strong></p><ul><li>可以使用路由器切割广播域，防止广播风暴，但是==成本较高==</li><li><p>使用vlan技术划分广播域</p></li><li><p><code>A</code>发送广播帧，<code>Access</code>接口接收并<code>打标签</code>,<code>PVID</code>和<code>VID</code>相同的Access端口可以接收该帧，进行==去标签转发==</p></li><li><p><code>Trunk</code>端口的<code>PVID</code>如果等于该帧的<code>VID</code>，也会==先去标签转发，然后再打标签==，否则直接转发</p></li><li><strong>Trunk端口是连接两个交换机的</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231111193532792.png" alt=""></p><h3 id="4-思维导图和习题"><a href="#4-思维导图和习题" class="headerlink" title="4. 思维导图和习题"></a>4. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgV0rfS0qZEA">第3章 数据链路层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ciOEeLV6ffuJ">第3章 数据链路层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cnRBS8NFgTll">第3章 数据链路层（思维导图）-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cl60fYfO1qZe">第3章 数据链路层 习题（第1部分）</a></p><p><a href="https://www.kdocs.cn/view/l/cenjHDfYLe95">第3章 数据链路层 习题（第2部分）</a></p><hr><h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote><p>网络层的主要任务：==将分组从源主机经过多个网络和多段链路传输到目的主机==，可以将该任务划分为==分组转发==和==路由选择==两种重要的功能</p></blockquote><h3 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h3><h4 id="4-2-1-面向连接的虚电路服务"><a href="#4-2-1-面向连接的虚电路服务" class="headerlink" title="4.2.1 面向连接的虚电路服务"></a>4.2.1 面向连接的虚电路服务</h4><blockquote><ul><li><strong>虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而==不是真正建立了一条物理连接==</strong></li><li><strong>分组的首部仅在连接建立阶段使用完整的目的主机地址，之后每个分组的首部只需要携带一条==虚电路编号==即可</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112213851481.png" alt=""></p><h4 id="4-2-2-无连接的数据报服务"><a href="#4-2-2-无连接的数据报服务" class="headerlink" title="4.2.2 无连接的数据报服务"></a>4.2.2 无连接的数据报服务</h4><blockquote><ul><li><code>TCP/IP</code>使用的就是这种==简单灵活的==、==无连接的==、==不可靠的==数据报服务</li><li><strong>核心思想：==可靠通信应由用户主机来保证==</strong></li><li><strong>由于网络自身不提供端到端的可靠传输服务，这就使得网络中的路由器可以做得比较简单，==大大降低了网络造价==</strong></li><li><strong>这种设计思想的==运行方式灵活==、能够适应多种应用。因特网能够发展到今日的规模，充分证明了当初采取这种设计思想的==正确性==</strong></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112220730923.png" alt=""></p><h4 id="4-2-3-IP地址"><a href="#4-2-3-IP地址" class="headerlink" title="4.2.3 IP地址"></a>4.2.3 IP地址</h4><blockquote><p><strong>概念</strong></p></blockquote><ul><li>网际协议（<code>Internet Protocol</code>，<code>IP</code>）是<code>TCP/IP</code>体系结构网际层中的核心协议</li><li><code>IPv4</code>地址就是给因特网(Internet)上的每一台主机（或路由器）的每一个==接口==分配一个在全世界范围内是唯一的==32比特==的标识符</li></ul><h4 id="4-2-4-分类编址的IP"><a href="#4-2-4-分类编址的IP" class="headerlink" title="4.2.4 分类编址的IP"></a>4.2.4 分类编址的<code>IP</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231112223308951.png" alt=""></p><h4 id="4-2-5-划分子网的IP"><a href="#4-2-5-划分子网的IP" class="headerlink" title="4.2.5 划分子网的IP"></a>4.2.5 划分子网的<code>IP</code></h4><blockquote><p><strong>分类编址方法不够灵活且容易造成==大量地址浪费==，划分子网编址方法对其进行改进（“打补丁”）</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113184551320.png" style="zoom:80%;" /></p><blockquote><p>划分子网案例</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113185650959.png" style="zoom:67%;" /></p><h4 id="4-2-6-无分类编制-的IP"><a href="#4-2-6-无分类编制-的IP" class="headerlink" title="4.2.6 ==无分类编制==的IP"></a>4.2.6 ==无分类编制==的<code>IP</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113190642722.png" style="zoom:67%;" /></p><blockquote><p>==无分类域间路由选择==（<code>C</code>lassless <code>I</code>nter-<code>D</code>omain <code>R</code>outing，<code>CIDR</code> ）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113190939322.png" style="zoom:67%;" /></p><blockquote><p><strong>练习</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113193113576.png" alt=""></p><blockquote><p><strong>==路由聚合==</strong></p><p><strong>找出共同前缀，其余位取0</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231113193616181.png" style="zoom:67%;" /></p><h3 id="4-3-IP数据报的发送和转发过程"><a href="#4-3-IP数据报的发送和转发过程" class="headerlink" title="4.3 IP数据报的发送和转发过程"></a>4.3 IP数据报的发送和转发过程</h3><blockquote><p><strong>IP数据报的==发送==和==转发==过程</strong></p><ul><li><p><strong>主机发送IP数据报</strong></p><ul><li>==判断目的主机是否与自己在同一个网络：==<ul><li>若在同一个网络，则属于==直接交付==，直接发送给目的主机</li><li>若不在同一个网络，则属于==间接交付==，传输给主机所在网络的默认网关(路由器)，==由默认网关帮忙转发==)</li></ul></li></ul></li><li><p><strong>路由器转发IP数据报</strong></p><ul><li>==检查IP数据报首部是否出错：==<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>==根据IP数据报的目的地址在路由表中查找匹配的条目：==<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳；</li><li>若找不到，则丢弃该IP数据报并通告源主机；</li></ul></li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/010ac0446c7c01e405dd1b7baf38d50a.png" alt=""></p><blockquote><p>==路由器不转发广播IP数据报==，即路由器隔离广播域，如果因特网中数量巨大的路由器收到广播IP数据报后都进行转发，则会==造成巨大的广播风暴，严重浪费因特网资源==</p><ul><li>==中继器==和==集线器==工作在==物理层==，<strong>既不隔离冲突域也不隔离广播域</strong></li><li>==网桥==和==交换机==(多端口网桥)工作在==数据链路层==，<strong>可以隔离冲突域，不能隔离广播域</strong></li><li>==路由器==工作在==网络层==，<strong>既隔离冲突域，也隔离广播域</strong></li></ul></blockquote><h3 id="4-4-静态路由配置"><a href="#4-4-静态路由配置" class="headerlink" title="4.4 静态路由配置"></a>4.4 静态路由配置</h3><h4 id="1-静态路由的配置"><a href="#1-静态路由的配置" class="headerlink" title="1. 静态路由的配置"></a>1. 静态路由的配置</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231117222851885.png" style="zoom:67%;" /></p><h4 id="2-默认路由"><a href="#2-默认路由" class="headerlink" title="2. 默认路由"></a>2. 默认路由</h4><ol><li><p>默认路由：默认路由条目中的目的网络<code>0.0.0.0/0</code>，其中<code>0.0.0.0</code>表示任意网络，而网络前缀“/0”（相应的地址掩码为<code>0.0.0.0</code>）是==最短的网络前缀==</p></li><li><p>特定主机路由：特定主机路由条目中的目的网络<code>192.168.2.1/32</code>，其中<code>192.168.2.1</code>是特定主机的IP地址，而网络前缀“/32”（相应地址掩码为<code>255.255.255.255</code>）是==最长的网络前缀==</p></li><li>路由器在查找转发表转发IP数据报时，遵循“最长前缀匹配”的原则，因此==默认路由匹配优先级最低，特定主机路由条目的匹配优先级最高==</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231117223841323.png" style="zoom:67%;" /></p><h4 id="3-路由环路"><a href="#3-路由环路" class="headerlink" title="3. 路由环路"></a>3. 路由环路</h4><ul><li>错误配置静态路由有可能导致==路由环路==问题</li><li>为了==防止IP数据报在环路中永久兜圈==，在IP数据报首部设有==生存时间TTL==，TTL为0时会被丢弃</li></ul><p><strong>路由环路问题产生原因：</strong></p><ol><li>路由配置错误</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118125828914.png" style="zoom:67%;" /></p><ol><li>聚合了不存在的IP地址</li></ol><blockquote><p>需要给不存在的IP地址配置黑洞路由，防止IP数据报转发到其他路由器</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118133214440.png" style="zoom:67%;" /></p><ol><li>网络故障</li></ol><blockquote><p>可以在网络发生故障时==添加一条针对该IP的黑洞路由==，待网络正常后又将其设置为失效状态</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118134111043.png" style="zoom: 67%;" /></p><h3 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5 路由选择协议"></a>4.5 路由选择协议</h3><ol><li>路由选择分为两类</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">==静态路由选择==</th><th style="text-align:left">==动态路由选择==</th></tr></thead><tbody><tr><td style="text-align:left">采用==人工配置==的方式给路由器添加网络路由、默认路由和特定主机路由等路由条目</td><td style="text-align:left">路由器通过路由选择协议==自动获取==路由信息</td></tr><tr><td style="text-align:left">静态路由选择==简单、开销小==，但==不能及时适应网络状态（流量、拓扑等）的变化==</td><td style="text-align:left">动态路由选择比较==复杂、开销比较大==，但==能较好地适应网络状态的变化==</td></tr><tr><td style="text-align:left">静态路由选择一般只在==小规模网络==中采用</td><td style="text-align:left">动态路由选择适用于==大规模网络==</td></tr></tbody></table></div><ol><li>因特网采用==分层次==的路由选择协议</li></ol><p>因特网是全球最大的互联网，它所采取的路由选择协议具有以下三个主要特点：</p><ul><li>自适应：因特网采用==动态路由==选择，能较好地适应网络状态的变化。</li><li>分布式：因特网中的各路由器通过相互间的信息交互，==共同完成路由信息的获取和更新==。</li><li>分层次：将整个因特网划分为许多较小的==自治系统==(<code>Autonomous System,AS</code>)，在自治系统内部和外部采用不同类别的路由选择协议，分别进行路由选择</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118150928383.png" style="zoom:67%;" /></p><h3 id="4-6-RIP"><a href="#4-6-RIP" class="headerlink" title="4.6 RIP"></a>4.6 <code>RIP</code></h3><p>路由信息协议（<code>Routing Information Protocol，RIP</code>）是内部网关协议中最先得到广泛使用的协议之一</p><ol><li>相关概念</li></ol><ul><li><p>RIP使用==跳数==（<code>Hop Count</code>）作为度量（<code>Metric</code>）来衡量到达目的网络的距离</p><ul><li><p>RIP将==路由器到直连网络的距离定义为1==</p></li><li><p>RIP将路由器到非直连网络的距离定义为==所经过的路由器数加1==</p></li><li>RIP允许一条路径最多只能包含15个路由器，==距离等于16时相当于不可达==,因此RIP只适用于==小型互<br>联网==</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118140619521.png" style="zoom: 50%;" /></p><ol><li><p>RIP认为好的路由就是“距离短”的路由，也就是所==通过路由器数量最少的路由==,和传输速率和物理距离等无关</p></li><li><p>RIP的==3个重要特点==</p></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118141136250.png" style="zoom: 67%;" /></p><ol><li><p><strong>==RIP的工作原理==</strong></p><ol><li>基本流程</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118141750507.png" style="zoom:67%;" /></p><ol><li><strong>==RIP路由条目的更新规则==</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118142447662.png" style="zoom:80%;" /></p><ol><li><p>==<strong>坏消息传播的慢</strong>==</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118220443883.png" alt=""></p></li></ol></li><li><p>RIP的优缺点</p></li></ol><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>实现==简单==，路由器==开销小==</td><td>RIP限制了==最大RIP距离为<code>15</code>==这就限制了使用RIP的自治系统AS的规模</td></tr><tr><td>如果一个路由器发现了RIP距离更短的路由，那么这种更新信息就传播得很快，即“==好消息传播得快==”</td><td>相邻路由器之间交换的路由信息是路由器中的完整路由表，因而==随着网络规模的扩大，开销也随之增大==</td></tr><tr><td></td><td>“==<strong>坏消息传播得慢</strong>==”，使更新过程的收敛时间过长。因此，对于规模较大的自治系统AS，应当使用<code>OSPF</code>协议</td></tr></tbody></table></div><h3 id="4-7-OSPF"><a href="#4-7-OSPF" class="headerlink" title="4.7 OSPF"></a>4.7 <code>OSPF</code></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><p>开放最短路径优先（<code>Open Shortest Path First，OSPF</code>）协议是为了克服路由信息协议RIP的缺点在1989年开发出来的</p><ul><li>“==开放==”表明<code>OSPF</code>协议不是受某一厂商控制，而是公开发表的</li><li>“==最短路径优先==”是因为使用了Dijkstra提出的==最短路径算法==(<code>Shortest Path First,SPF</code>)</li></ul></blockquote><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><blockquote><ul><li><code>OSPF</code>是==基于<strong>链路状态</strong>==的，而不像<code>RIP</code>是基于距离向量的</li><li><code>OSPF</code>基于链路状态并采用最短路径算法计算路由，==从算法上保证了不会产生路由环路==</li><li><code>OSPF</code>==不限制网络规模，更新效率高，收敛速度快==</li></ul></blockquote><h4 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3. 相关概念"></a>3. 相关概念</h4><ol><li><p>链路状态（<code>Link State，LS</code>）是指本路由器都和哪些路由器相邻，以及相应链路的“代价（cost）”，类似RIP中的距离</p><blockquote><p>“代价”用来表示费用、距离、时延和带宽等，这些都由网络管理人员来决定</p></blockquote></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118223059765.png" style="zoom:80%;" alt='举例-思科路由器的代价计算标准' /></p><ol><li><strong>==<code>OSPF</code>路由器邻居关系的建立和维护==</strong><ul><li><strong>如果在死亡倒计时为0时还未收到邻居的问候分组，则认为该邻居不可达，</strong></li><li><strong>在接受到邻居的问候分组后，刷新死亡倒计时为40s</strong></li><li><strong>路由器每10s会向邻居发送问候分组</strong></li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118223958856.png" style="zoom:67%;" /></p><ol><li>==<strong>链路状态数据库</strong>==(<code>Link State Database，LSDB</code>)</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118224728007.png" alt=""></p><blockquote><p>使用<code>OSPF</code>的各路由器，基于链路状态数据库LSDB进行最短路径优先计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表(==根据链路状态数据库得出全局带权有向图，使用Dijkstra算法得出个路由器的最短路径==)</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231118225157334.png" alt=""></p><ol><li><strong><code>OSPF</code>的五种分组类型</strong><ul><li>类型1，==问候(<code>Hello</code>)分组==：用来发现和维护邻居路由器的可达性。</li><li>类型2，==数据库描述(<code>Database Description</code>)分组==：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>类型3，==链路状态请求(<code>Link State Request</code>)分组==：向邻居路由器请求发送某些链路状态项目的详细信息。</li><li>类型4，==链路状态更新(<code>Link State Update</code>)分组==：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</li><li>类型5，==链路状态确认(<code>Link State Acknowledgment</code>)分组==：这是对链路状态更新分组的确认分组。</li></ul></li></ol><h4 id="4-基本工作原理"><a href="#4-基本工作原理" class="headerlink" title="4. 基本工作原理"></a>4. 基本工作原理</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119152547862.png" style="zoom:67%;" /></p><blockquote><p>采用划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做能==使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模更大的自治系统AS==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119152848527.png" style="zoom:67%;" /></p><h3 id="4-8-BGP"><a href="#4-8-BGP" class="headerlink" title="4.8  BGP"></a>4.8  <code>BGP</code></h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><ul><li><strong>边界网关协议</strong>（<code>Border Gateway Protocol，BGP</code>）属于==外部网关协议==<code>EGP</code>这个类别，用于自治系统<code>AS</code>之间的路由选择协议</li><li>由于在不同AS内度量路由的“代价”（距离、带宽、费用等）可能不同，因此==对于AS之间的路由选择，使用统一的“代价”作为度量来寻找最佳路由是不行的==</li><li>AS之间的路由选择还必须考虑相关策略（政治、经济、安全等）</li></ul><p><strong>总结：<code>BGP</code>只能是力求寻找一条能够到达目的网络且比较好的路由（即不能兜圈子），而并非要寻找一条最佳路由</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119154933166.png" style="zoom: 80%;" /></p><blockquote><ul><li><p>在配置BGP时，每个AS的管理员要选择至少一个路由器作为该AS的“==BGP发言人==”</p></li><li><p>一般来说，两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是==BGP边界路由器==</p></li><li>使用<code>TCP</code>连接交换路由信息的两个BGP发言人，彼此称为对方的==邻站==（neighbor）或==对等站==（peer）</li><li>BGP发言人除了运行BGP协议外，还必须运行自己所在AS所使用的内部网关协议IGP，例如RIP或OSPF</li><li>BGP发言人交换网络可达性的信息，也就是==要到达某个网络所要经过的一系列自治系统==</li><li>当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就==根据所采用的策略==，从收到的路由信息中==找出到达各自治系统的较好的路由==，也就是==构造出树形结构且不存在环路的自治系统连通图==</li></ul></blockquote><h4 id="2-四种报文"><a href="#2-四种报文" class="headerlink" title="2. 四种报文"></a>2. 四种报文</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119155610676.png"  /></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119160021206.png"  /></p><h3 id="4-9-IPv4数据报的首部格式"><a href="#4-9-IPv4数据报的首部格式" class="headerlink" title="4.9 IPv4数据报的首部格式"></a>4.9 IPv4数据报的首部格式</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119161128658.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:center">版本</th><th>长度为==4==个比特，用来表示IP协议的版本，==通信双方使用的IP协议的版本必须一致==，目前广泛使用的IP协议的版本号为4（即IPv4）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>首部长度</strong></td><td>长度为==4==个比特，该字段的取值==以4字节为单位==，用来表示IPV4数据报的首部长度。<br/>最小取值为二进制的0101，即十进制的5，再乘以4字节单位，==表示IPv4数据报首部只有20字节固定部分==<br />最大取值为二进制的1111，即十进制的15，再乘以4字节单位，==表示IPV4数据报首部包含20字节固定部分和最大40字节可变部分==</td></tr><tr><td style="text-align:center"><strong>总长度</strong></td><td>长度为==16==个比特，该字段的取值==以字节为单位==，用来==表示IPv4数据报的长度==（==首部长度+数据载荷长度==）<br />最大取值为二进制的16个比特1，即十进制的65535（很少传输这么长的IPv4数据报）</td></tr><tr><td style="text-align:center"><strong>标识</strong></td><td>长度为==16==个比特，==属于同一个IPv4数据报的各分片数据报应该具有相同的标识==</td></tr><tr><td style="text-align:center"><strong>标志</strong></td><td>最低位(<code>More Fragment,MF</code>)<br/>    MF=1表示本分片后面还有分片<br/>    MF=0表示本分片后面没有分片<br/>中间位(<code>Don&#39;t Fragment,DF</code>)<br/>    DF=1表示不允许分片<br/>    DF=0表示允许分片<br/>最高位为保留位，必须设置为0</td></tr><tr><td style="text-align:center"><strong>片偏移</strong></td><td>长度为==16==个比特，该字段的取值，==以8字节为单位==，用来指出分片IPv4数据报的==数据载荷偏移其在原IPv4数据报的位置有多远，只能为整数，否则必须调整前一个分片长度==</td></tr><tr><td style="text-align:center"><strong>生存时间</strong></td><td>长度为==8==个比特，最大取值为二进制的11111111，即十进制的255。该字段的取值最初以秒为单位。因此，IPv4数据报的最大生存时间最初为255秒。路由器转发IPv4数据报时，将其首部中该字段的值减去该数据报在路由器上所耗费的时间，若结果不为0就转发，否则就丢弃<br />生存时间字段==后来改为以“跳数”为单位，路由器收到待转发的IPv4数据报时，将其首部中的该字段的值减1，若结果不为0就转发，否则就丢弃==</td></tr><tr><td style="text-align:center"><strong>协议</strong></td><td>长度为8个比特，用来==指明IPv4数据报的数据载荷是何种协议数据单元PDU==<br /><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119165547509.png" alt=""></td></tr><tr><td style="text-align:center"><strong>首部检验和</strong></td><td>长度为==16==个比特，用于==检测IPv4数据报在传输过程中其首部是否出现了差错==<br />IPv4数据报==每经过一个路由器==，其首部中的某些字段的值（例如生存时间TTL、标志以及片偏移等）都可能发生变化，因此路由器都要==重新计算一下首部检验和==</td></tr><tr><td style="text-align:center"><strong>源IP地址和目的IP地址</strong></td><td>长度都为==32==个比特，用来填写发送（接收）IPv4数据报的源（目的）主机的IPv4地址</td></tr></tbody></table></div><blockquote><p><code>MTU</code>：==最大传送单元，超过最大传送单元的长度的IP数据报必须分片==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119164911210.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119171554203.png" alt=""></p><h3 id="4-10-ICMP"><a href="#4-10-ICMP" class="headerlink" title="4.10 ICMP"></a>4.10 <code>ICMP</code></h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><blockquote><ul><li>为了更有效地转发IP数据报以及提高IP数据报交付成功的机会，TCP/IP体系结构的网际层使用了网际控制报文协议（<code>Internet Control Message Protocol，ICMP</code>）</li><li>主机或路由器使用ICMP来发送==差错报告报文==和==询问报文==</li><li>ICMP报文被==封装在IP数据报中作为数据载荷==发送</li></ul></blockquote><h4 id="2-ICMP报文数据类型"><a href="#2-ICMP报文数据类型" class="headerlink" title="2. ICMP报文数据类型"></a>2. ICMP报文数据类型</h4><ul><li><p><strong>差错报告报文</strong>：用来==向主机或路由器报告差错情况==</p><ul><li><p><strong>终点不可达</strong>：==当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文==，具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119222854859.png" alt=""></p></li><li><p><strong>源点抑制</strong>：==当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文==，使源点知道应当把IP数据报的发送速率放慢</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231119222400135.png"  /></p></li><li><p><strong>超时</strong>：</p><ul><li>当路由器收到一个目的IP地址不是自己的IP数据报时，会将其首部中生存时间TTL字段的值减1。若结果不为0，则路由器将该数据报转发出去；==若结果为0，路由器不但要丢弃该数据报，还要向发送该IP数据报的源点发送时间超过（超时）报文==</li><li>另外，当终点在预先规定的时间内==未能收到一个数据报的全部数据报分片==时，就把已收到的数据报片都==丢弃==，也会==向源点发送时间超过（超时）报文==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120194354557.png"  /></p></li><li><p><strong>参数问题</strong>：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段的值发现首部在传送过程中出现了误码，就丢弃该数据报，并向发送该数据报的源点发送参数问题报文</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120194840526.png" alt=""></p></li><li><p><strong>改变路由（重定向）</strong>：路由器把==改变路由报文==发送给主机，让主机知道下次==应将IP数据报发送给另外的路由器==，这样可以==通过更好的路由到达目的主机==</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120195049808.png" alt=""></p></li></ul></li><li><p><strong>以下情况==不应发送ICMP差错报告报文==</strong>：</p><ul><li>对==ICMP差错报告报文==不再发送ICMP差错报告报文</li><li>对第一个分片的IP数据报片的所有==后续数据报片==都不发送ICMP差错报告报文</li><li>对==具有多播地址的IP数据报==都不发送ICMP差错报告报文</li><li>对具有==特殊地址==（例如<code>127.0.0.0</code>或<code>0.0.0.0</code>）的IP数据报不发送CMP差错报告报文。</li></ul></li><li><p><strong>询问报文</strong>：用来==向主机或路由器询问情况==</p><ul><li><p><strong>回送请求和回答</strong>：</p><p>由主机或路由器向一个特定的目的主机或路由器发出。收到此报文的主机或路由器必须给发送该报文的源主机或路由器发送ICMP回送回答报文。这种询问报文==用来测试目的站是否可达以及了解其有关状态==</p></li><li><p><strong>时间戳请求和回答</strong>：</p><p>用来请求某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32比特的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。这种询问报文==用来进行时钟同步和测量时间==</p></li></ul></li></ul><h4 id="3-ICMP的典型应用"><a href="#3-ICMP的典型应用" class="headerlink" title="3. ICMP的典型应用"></a>3. ICMP的典型应用</h4><h5 id="1-PING"><a href="#1-PING" class="headerlink" title="1. PING"></a>1. <code>PING</code></h5><blockquote><p>分组网间探测（Packet InterNet Groper，<code>PING</code>）</p><p>在命令行中==使用ping命令用来测试主机或路由器之间的连通性==</p><ul><li>PING是TCP/IP体系结构的==应用层直接使用网际层ICMP==的一个例子，它并不使用运输层的TCP或UDP</li><li>PING应用所使用的ICMP报文类型为==回送请求和回答==</li></ul></blockquote><h5 id="2-traceroute"><a href="#2-traceroute" class="headerlink" title="2. traceroute"></a>2. <code>traceroute</code></h5><blockquote><p>跟踪路由应用traceroute，==用于探测IP数据报从源主机到达目的主机要经过哪些路由器==</p><p>在不同操作系统中，traceroute应用的命令和实现机制有所不同：</p><ul><li>在UNIX版本中，具体命令为<code>traceroute</code>，其==在运输层使用UDP协议==，==在网络层使用ICMP报文类型只有差错报告报文==</li><li>在Windows版本中，具体命令为<code>tracert</code>，其==应用层直接使用网际层的ICMP协议，所使用的ICMP报文类型有回送请求和回答报文以及差错报告报文==</li></ul><p><strong>==原理==</strong>：==设置IP数据报TTL为1，经过第一个路由器时，TTL减为0，IP数据报被丢弃，路由器向源主机发送超时差错报告报文，这样就知道了经过的第一个路由器的IP地址，以此类推依次设置TTL为2,3,4，……，直到接收到目的主机的回送请求回答报文==</p></blockquote><h3 id="4-11-VPN"><a href="#4-11-VPN" class="headerlink" title="4.11 VPN"></a>4.11 <code>VPN</code></h3><blockquote><p>==虚拟专用网==(<code>Virtual Private Network,VPN</code>)：<strong>利用公用的==因特网==作为本机构各==专用网之间的通信载体==，这样形成的网络又称为虚拟专用网</strong></p></blockquote><p><strong>专用地址</strong>：</p><ul><li><code>10.0.0.0-10.255.255.255</code>(CIDR地址块10/8)</li><li><code>172.16.0.0-172.31.255.255</code>(ClDR地址块172.16/12)</li><li><code>192.168.0.0-192.168.255.255</code>(CIDR地址块192.168/16)</li></ul><blockquote><p>很显然，全世界可能有很多不同机构的专用网具有相同的专用IP地址，但这并不会引起麻烦，因为==这些专用地址仅在机构内部使用==</p><p><strong>注意</strong>：在因特网中的所有路由器，==对目的地址是专用地址的IP数据报一律不进行转发==，这需要由因特网服务提供者ISP对其拥有的因特网路由器进行设置来实现（需要自己对路由器额外配置）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120204244180.png" alt=""></p><h3 id="4-12-NAT"><a href="#4-12-NAT" class="headerlink" title="4.12 NAT"></a>4.12 <code>NAT</code></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><ul><li><p><strong>背景</strong>：尽管因特网采用了无分类编址方法来减缓IPv4地址空间耗尽的速度，但由于==因特网用户数量的急剧增长==，特别是==大量小型办公室==和==家庭网络==接入因特网的需求不断增加，I==Pv4地址空间即将耗尽的危险然仍没有解除==（实际上，因特网号码分配管理局IANN于2011年2月3日宣布，IPv4地址已经分配完毕）</p></li><li><p><strong>==网络地址转换==</strong>（<code>Network Address Translation，NAT</code>）技术于1994年被提出，==用来缓解IPv4地址空间即将耗尽的问题==</p><ul><li>NAT能==使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源==</li><li>这种方法需要在专用网络连接到因特网的路由器上==安装NAT软件==。装有NAT软件的路由器称为==NAT路由器==，它==至少要有一个有效的外部全球地址IPG==。这样，所有使用内部专用地址的主机在和外部因特网通信时，都要==在NAT路由器上将其内部专用地址转换成IPG==</li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120210441321.png" alt=""></p><h4 id="2-NAPT"><a href="#2-NAPT" class="headerlink" title="2. NAPT"></a>2. <code>NAPT</code></h4><blockquote><p><strong>==网络地址与端口号转换方法==</strong>:将NAT和运输层端口号结合使用，称为网络地址与端口号转换（<code>Network Address and Port Translation，NAPT</code>）</p><ul><li>由于目前绝大多数基于TCP/IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP，==为了更加有效地利用NAT路由器中的全球IP地址==，现在常==将NAT转换和运输层端口号结合使用==<ul><li>这样就可以使内部专用网中使用专用地址的==大量主机，共用NAT路由器上的1个全球IP地址==，因而可以同时与因特网中的不同主机进行通信</li><li>现在很多家用路由器将家中各种智能设备（手机、平板、笔记本电脑、台式电脑、物联网设备等）接入因特网，这种路由器实际上就是一个==NAPT路由器==，但往往并不运行路由选择协议</li></ul></li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231120211722902.png" alt=""></p><blockquote><p>==由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护==</p></blockquote><h3 id="5-思维导图和习题"><a href="#5-思维导图和习题" class="headerlink" title="5. 思维导图和习题"></a>5. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/ceLxGZ0br8Gy">第4章 网络层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cu2tek1gzIPq">第4章 网络层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cjXVALCjxr0X">第4章 网络层（思维导图）-3 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cbSlBNdR8CSr">第4章 网络层（思维导图）-4 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/ccu9ATsOpoZf">第4章 网络层 习题(第1部分)</a></p><p><a href="https://www.kdocs.cn/view/l/cqBldcygudFg">第4章 网络层 习题(第2部分)</a></p><hr><h2 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>第2~4章依次介绍了计算机网络体系结构中的==物理层==、==数据链路层==和==网络层==，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了==主机到主机的通信==</li><li>然而在计算机网络中实际进行==通信的真正实体，是位于通信两端主机中的进程==</li><li>如何==<strong>为运行在不同主机上的应用进程提供直接的逻辑通信服务</strong>==，就是==运输层的主要任务==，运输层协议又称为端到端协议</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124190055469.png" alt=""></p><h3 id="2-端口号，复用和分用"><a href="#2-端口号，复用和分用" class="headerlink" title="2. 端口号，复用和分用"></a>2. 端口号，复用和分用</h3><h4 id="1-运输层端口号"><a href="#1-运输层端口号" class="headerlink" title="1. 运输层端口号"></a>1. 运输层端口号</h4><ul><li>运行在计算机上的进程是使用==进程标识符==(<code>P</code>rocess <code>ld</code>entification,<code>PID</code>)来标识的。<ul><li>然而，因特网上的计算机并不是使用统一的操作系统，而==不同操作系统==(Windows、Linux、.MacOS)<br>又==使用不同格式的进程标识符==</li><li>为了使运行不同操作系统的计算机的应用进程之间能够基于网络进行通信，就必须==使用统一的方法<br>对TCPP体系的应用进程进行标识==</li></ul></li><li><code>TCP/IP</code>体系结构的运输层使用端口号来标识和区分应用层的不同应用进程。端口号的==长度为6比特，取<br>值范围是0~65535==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124191009578.png" style="zoom:100%;" /></p><blockquote><p>==<strong>端口号只具有本地意义，即端口号只是为了标识本计算机网络协议栈应用层中的各应用进程。在因特网中，不同计算机中的相同端口号是没有关系的，即相互独立。另外，<code>TCP</code>和<code>UDP</code>端口号之间也是没有关系的</strong>==</p></blockquote><h4 id="2-发送方的复用和接收方的分用"><a href="#2-发送方的复用和接收方的分用" class="headerlink" title="2. 发送方的复用和接收方的分用"></a>2. 发送方的复用和接收方的分用</h4><ol><li><strong>复用（Multiplexing）：</strong><ul><li><strong>定义：</strong> 复用是指==将多个应用程序的数据流合并到一个共享的通信通道上==</li><li><strong>TCP中的复用：</strong> 在TCP中，复用通过源端口号来实现。TCP连接的两端使用IP地址和端口号来唯一标识。源端口号表示发送端的应用程序，目的端口号表示接收端的应用程序。这样，在单个TCP连接中，多个应用程序的数据可以共享同一个物理通信通道</li><li><strong>UDP中的复用：</strong> 在UDP中，复用同样通过源端口号来实现。UDP报文的源端口号用于标识发送端的应用程序，目的端口号用于标识接收端的应用程序</li></ul></li><li><strong>分用（Demultiplexing）：</strong><ul><li><strong>定义：</strong> 分用是指==根据数据流中的标识信息将合并的数据流分发给正确的应用程序==</li><li><strong>TCP中的分用：</strong> 在TCP中，分用通过目的端口号来实现。接收端根据目的端口号将接收到的数据分发给相应的应用程序。这样，TCP层能够将数据正确地传递给目标应用程序</li><li><strong>UDP中的分用：</strong> 在UDP中，同样通过目的端口号来实现分用。接收端通过目的端口号确定应该将数据交付给哪个应用程序</li></ul></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124192346522.png" alt=""></p><blockquote><p>==常见协议的分类==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124192909256.png" alt=""></p><p><strong><a href='https://www.bilibili.com/video/BV1c4411d7jb?t=353.6&p=58'>运输层端口号应用举例</a></strong></p><h3 id="3-TCP和UDP的对比"><a href="#3-TCP和UDP的对比" class="headerlink" title="3.  TCP和UDP的对比"></a>3.  <code>TCP</code>和<code>UDP</code>的对比</h3><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124195001220.png" alt=""></p><p><strong>==注意==</strong>：</p><ul><li>TCP面向连接是==逻辑连接，并非真实物理连接==</li><li>==TCP面向字节流，UDP面向应用报文==（只是给数据报添加一个UDP首部）</li><li>TCP只支持单播，UDP支持单播、多播和广播</li><li>==TCP提供可靠服务，UDP提供不可靠服务==</li></ul><h3 id="4-TCP的流量控制"><a href="#4-TCP的流量控制" class="headerlink" title="4. TCP的流量控制"></a>4. TCP的<strong>流量控制</strong></h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><p>TCP为应用程序提供了==流量控制==（<code>Flow Control</code>）机制，以解决因==发送方发送数据太快而导致接收方来不及接收，造成接收方的接收缓存溢出==的问题</p><p><strong>流量控制的基本方法：</strong>==接收方根据自己的接收能力（接收缓存的可用空间大小）控制发送方的发送速率==</p></blockquote><h4 id="2-流量控制方法"><a href="#2-流量控制方法" class="headerlink" title="2. 流量控制方法"></a>2. <a href='https://www.bilibili.com/video/BV1c4411d7jb?t=44.1&p=60'>流量控制方法</a></h4><ol><li><strong>流程</strong></li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124203621190.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124205122410.png" alt=""></p><ol><li><p>例题</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124210146804.png" alt=""></p></li></ol><h3 id="5-TCP的拥塞-se-控制"><a href="#5-TCP的拥塞-se-控制" class="headerlink" title="5. TCP的拥塞(se)控制"></a>5. TCP的<strong>拥塞(se)控制</strong></h3><h4 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124211432668.png" /></p><h4 id="2-4种拥塞控制方法"><a href="#2-4种拥塞控制方法" class="headerlink" title="2. 4种拥塞控制方法"></a>2. 4种拥塞控制方法</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124212653543.png" alt=""></p><h5 id="1-慢开始、拥塞避免"><a href="#1-慢开始、拥塞避免" class="headerlink" title="==1. 慢开始、拥塞避免=="></a>==1. 慢开始、拥塞避免==</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124213905436.png" alt=""></p><h5 id="2-快重传、快恢复"><a href="#2-快重传、快恢复" class="headerlink" title="==2. 快重传、快恢复=="></a>==2. 快重传、快恢复==</h5><blockquote><p>快重传算法和快恢复算法（==改进TCP性能==，1990年Reno版本）</p></blockquote><ol><li>问题</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124214535400.png" alt=""></p><ol><li><p><strong>==快重传==</strong></p><ul><li><strong>采用快重传算法可以让发送方尽早知道发生了==个别TCP报文段的丢失==</strong></li><li>“快重传”是指<strong>使发送方尽快（尽早）进行重传，而不是等重传计时器超时再重传</strong><ul><li>这就要求==接收方不要==等待自己发送数据时才进行==捎带确认==，而是==要立即发送确认==，即使收到了==失序的报文段==也要==立即==发出对已收到的报文段的==重复确认==</li><li>==发送方==一旦==收到3个连续的重复确认==，就将相应的报文段==立即重传==，而不是等该报文段的重传计时器超时再重传</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231124215953819.png" alt=""></p></li><li><p>==<strong>快恢复</strong>==</p></li></ol><blockquote><p>与快重传算法配合使用的是<strong>快恢复算法</strong>，==发送方==一旦==收到3个重复确认==，就知道现在==只是丢失了个别的报文段==，于是==不启动慢开始算法，<strong>而是执行快恢复算法</strong>==</p><ul><li><strong>快恢复算法：</strong>==发送方将慢开始门限ssthresh的值和拥塞窗口cwnd的值<strong>都调整为当前cwnd值的一半</strong>，并开始执行拥塞避免算法==</li><li>也有的快恢复实现是把快恢复开始时的cwnd值再增大一些，即cwnd=新ssthresh+3</li></ul></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125205520540.png" alt=""></p><h3 id="6-TCP超时重传时间的选择"><a href="#6-TCP超时重传时间的选择" class="headerlink" title="6. TCP超时重传时间的选择"></a>6. TCP超时重传时间的选择</h3><blockquote><p><strong>==TCP超时重传时间RTO的选择==是TCP==最复杂==的问题之一</strong></p><p>问题：</p><ul><li>==超时重传时间设置过小==，在确认报文段发送给接收方的过程中，发送方重传数据报文，==增大了网络负荷==</li><li>==超时重传时间设置过大==，需要重传数据报文时，推迟时间太长，==网络空闲时间大，降低了传输效率==</li><li>超时重传时间<code>RTO</code>应略大于往返时间<code>RTT</code></li></ul></blockquote><h4 id="RTO的选择"><a href="#RTO的选择" class="headerlink" title="==RTO的选择=="></a><strong>==RTO的选择==</strong></h4><h5 id="1-RTTs的计算"><a href="#1-RTTs的计算" class="headerlink" title="1. RTTs的计算"></a>1. RTTs的计算</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125211946213.png" alt=""></p><h5 id="2-RRTd和RTO的计算"><a href="#2-RRTd和RTO的计算" class="headerlink" title="2. RRTd和RTO的计算"></a>2. RRTd和RTO的计算</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125212210328.png" alt=""></p><h4 id="发生超时重传时无法测准RTT"><a href="#发生超时重传时无法测准RTT" class="headerlink" title="发生超时重传时无法测准RTT"></a>发生超时重传时无法测准RTT</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125212838059.png" alt=""></p><blockquote><p><strong>通过上述两个例子可以看出：当发送方出现超时重传后，收到确认报文段时是无法判断出该确认到底是对原数据报文段的确认还是对重传数据报文段的确认，也就是无法准确测量出RTT，进而无法正确计算RTO</strong></p></blockquote><h5 id="Karn算法及修正"><a href="#Karn算法及修正" class="headerlink" title="Karn算法及修正"></a>Karn算法及修正</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125213341384.png" alt=""></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231125213649193.png" alt=""></p><h3 id="7-TCP可靠传输的实现"><a href="#7-TCP可靠传输的实现" class="headerlink" title="7.TCP可靠传输的实现"></a>7.TCP可靠传输的实现</h3><ul><li><strong>TCP的窗口以字节为单位</strong></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126212908308.png" alt=""></p><ul><li>发送方<ul><li>发送窗口内的已发送数据如果迟迟未收到确认，会发生==超时重传==</li><li>只有处于发送窗口内的数据才能发送</li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126213314315.png" alt=""></p><ul><li>接收方<ul><li>接收方==<strong>只能对按序收到的数据中的最高序号给出累计确认</strong>==，3次重复确认会导致发送方==<strong>快重传</strong>==</li><li><strong>序号落入接收窗口内的数据是允许接收的数据</strong></li></ul></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126213800870.png" alt=""></p><ul><li><strong>==总结==</strong></li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231126214833403.png" alt=""></p><h3 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8. TCP的运输连接管理"></a>8. TCP的运输连接管理</h3><h4 id="1-TCP连接的建立"><a href="#1-TCP连接的建立" class="headerlink" title="1. TCP连接的建立"></a>1. TCP连接的建立</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203192027726.png" alt=""></p><blockquote><p>TCP双方连接的建立要解决的三个问题</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203192339624.png" alt=""></p><h4 id="2-三报文握手"><a href="#2-三报文握手" class="headerlink" title="2. 三报文握手"></a>2. 三报文握手</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203193842118 .png" alt=""></p><blockquote><p><strong>思考：第三次确认==是否多余==，==能不能两报文握手？==</strong></p><p>答案：不能，如下图所示</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203194753830.png" alt=""></p><h4 id="3-四报文挥手"><a href="#3-四报文挥手" class="headerlink" title="3. 四报文挥手"></a>3. 四报文挥手</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203195725711.png" alt=""></p><blockquote><p><strong>思考：为什么客户端发送完最后一个确认报文段后不立刻关闭而是等待2个MSL时间后才关闭？</strong></p><p>答案：如图所示</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203200428799.png" alt=""></p><blockquote><p>==TCP保活计时器的作用==</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203201004403.png" alt=""></p><h3 id="9-TCP报文段首部格式"><a href="#9-TCP报文段首部格式" class="headerlink" title="9. TCP报文段首部格式"></a>9. TCP报文段首部格式</h3><blockquote><p>参阅思维导图 1</p></blockquote><h3 id="10-思维导图和习题"><a href="#10-思维导图和习题" class="headerlink" title="10. 思维导图和习题"></a>10. 思维导图和习题</h3><p><a href="https://www.kdocs.cn/view/l/cgoja6Lpohhj">第5章 运输层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/chkSS9vn9Zgd">第5章 运输层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cpaRQtp0G6Ou">第5章 运输层 习题 (kdocs.cn)</a></p><hr><h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>应用层是计算机网络体系结构的==<strong>最顶层</strong>==，是==<strong>设计和建立计算机网络的最终目的</strong>==，也是计算机网络中发展最快的部分<ul><li>早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）</li><li>20世纪90年代将因特网带入千家万户的万维网WWW</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台</li></ul></li></ul><h3 id="2-客户服务器和对等方式"><a href="#2-客户服务器和对等方式" class="headerlink" title="2. 客户服务器和对等方式"></a>2. 客户服务器和对等方式</h3><h4 id="1-C-S方式"><a href="#1-C-S方式" class="headerlink" title="1. C/S方式"></a>1. <code>C/S</code>方式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210526922.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210406504.png" alt=""></p><h4 id="2-P2P方式"><a href="#2-P2P方式" class="headerlink" title="2. P2P方式"></a>2. <code>P2P</code>方式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210957388.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203210908603.png" alt=""></p><h3 id="3-DHCP"><a href="#3-DHCP" class="headerlink" title="3. DHCP"></a>3. <code>DHCP</code></h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><p>动态主机配置协议（<code>D</code>ynamic <code>h</code>ost <code>c</code>onfiguration <code>p</code>rotocol）</p><p>作用：</p><ul><li><code>DHCP</code>可为计算机==自动配置网络参数==，包括：<ul><li>IP地址</li><li>子网掩码</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul></blockquote><h4 id="2-DHCP基本工作过程"><a href="#2-DHCP基本工作过程" class="headerlink" title="2. DHCP基本工作过程"></a>2. <code>DHCP</code>基本工作过程</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203212822735.png" alt=""></p><h4 id="3-DHCP中继代理"><a href="#3-DHCP中继代理" class="headerlink" title="3. DHCP中继代理"></a>3. <code>DHCP</code>中继代理</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231203213528827.png" alt=""></p><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4. DNS"></a>4. <code>DNS</code></h3><blockquote><p><strong>域名系统</strong>（<code>D</code>omain <code>N</code>ame <code>S</code>ystem,<code>DNS</code>）</p></blockquote><h4 id="1-域名系统的作用"><a href="#1-域名系统的作用" class="headerlink" title="1. 域名系统的作用"></a>1. 域名系统的作用</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204215706663.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204215946064.png" alt=""></p><h4 id="2-因特网的域名结构"><a href="#2-因特网的域名结构" class="headerlink" title="2. 因特网的域名结构"></a>2. 因特网的域名结构</h4><blockquote><p>因特网采用<strong>==层次树状结构的域名结构==</strong></p></blockquote><h5 id="1-域名规范"><a href="#1-域名规范" class="headerlink" title="1. 域名规范"></a>1. 域名规范</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204220316573.png" alt=""></p><h5 id="2-不同国家的域名"><a href="#2-不同国家的域名" class="headerlink" title="2. 不同国家的域名"></a>2. 不同国家的域名</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204220844413.png" alt=""></p><h5 id="3-因特网的域名空间"><a href="#3-因特网的域名空间" class="headerlink" title="3. 因特网的域名空间"></a>3. 因特网的域名空间</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221139510.png" alt=""></p><h4 id="3-域名服务器"><a href="#3-域名服务器" class="headerlink" title="3. 域名服务器"></a>3. 域名服务器</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221502337.png" alt=""></p><h4 id="4-域名解析"><a href="#4-域名解析" class="headerlink" title="4. 域名解析"></a>4. 域名解析</h4><h5 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1. 递归查询"></a>1. 递归查询</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204221840693.png" alt=""></p><h5 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2. 迭代查询"></a>2. 迭代查询</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222346748.png" alt=""></p><h5 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3. 高速缓存"></a>3. 高速缓存</h5><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222807218.png" alt=""></p><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204222817296.png" alt=""></p><h3 id="5-FTP"><a href="#5-FTP" class="headerlink" title="5. FTP"></a>5. <code>FTP</code></h3><blockquote><p><strong>文件传送协议</strong>（<code>F</code>ile <code>T</code>ransfer <code>P</code>rotocol，<code>FTP</code>）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204223526085.png" alt=""></p><blockquote><p><strong>基本工作原理</strong></p></blockquote><ol><li>主动模式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204224108197.png" alt=""></p><ol><li>被动模式</li></ol><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231204224211222.png" alt=""></p><h3 id="6-电子邮件"><a href="#6-电子邮件" class="headerlink" title="6. 电子邮件"></a>6. 电子邮件</h3><h4 id="1-E-mail"><a href="#1-E-mail" class="headerlink" title="1. E-mail"></a>1. <code>E-mail</code></h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090041032.png" alt=""></p><h4 id="2-电子邮件系统的组成"><a href="#2-电子邮件系统的组成" class="headerlink" title="2. 电子邮件系统的组成"></a>2. 电子邮件系统的组成</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090359331.png" alt=""></p><h4 id="3-邮件发送和接收过程"><a href="#3-邮件发送和接收过程" class="headerlink" title="3. 邮件发送和接收过程"></a>3. 邮件发送和接收过程</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205090654917.png" alt=""></p><h4 id="4-SMTP"><a href="#4-SMTP" class="headerlink" title="4. SMTP"></a>4. <code>SMTP</code></h4><blockquote><p>简单邮件传送协议（Simple Mail Transfer Protocol，<code>SMTP</code>）的基本工作过程</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091401858.png" alt=""></p><h4 id="5-电子邮件的信息格式"><a href="#5-电子邮件的信息格式" class="headerlink" title="5. 电子邮件的信息格式"></a>5. 电子邮件的信息格式</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091646693.png" alt=""></p><h4 id="6-MIME"><a href="#6-MIME" class="headerlink" title="6. MIME"></a>6. <code>MIME</code></h4><blockquote><p><strong>多用途因特网邮件扩展</strong> (Multipurpose Internet Mail Extensions，<code>MIME</code>)</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205091958949.png" alt=""></p><blockquote><p><strong><code>MIME</code>对邮件内容中的非ASCII字符转换成ASCII字符</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205092205673.png" alt=""></p><h4 id="7-常用邮件读取协议"><a href="#7-常用邮件读取协议" class="headerlink" title="7. 常用邮件读取协议"></a>7. 常用邮件读取协议</h4><blockquote><p><strong>邮局协议</strong>（Post Office Protocol，<code>POP</code>）</p><p><strong>因特网邮件访问协议</strong>（Internet Message Access Protocol，<code>IMAP</code>）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205092629754.png" alt=""></p><h4 id="8-基于万维网的电子邮件"><a href="#8-基于万维网的电子邮件" class="headerlink" title="8. 基于万维网的电子邮件"></a>8. 基于万维网的电子邮件</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205093140031.png" alt=""></p><h3 id="7-万维网"><a href="#7-万维网" class="headerlink" title="7. 万维网"></a>7. 万维网</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><ul><li><strong>==万维网==</strong>（World Wide Web，<code>WWW</code>）==并非某种特殊的计算机网络==。它是一个大规模的、联机式的信息储藏所，是==运行在因特网上的一个分布式应用==</li><li>万维网利用网页之间的==超链接==将不同网站的网页链接成一张逻辑上的信息网</li><li>万维网是欧洲粒子物理实验室的==Tim Berners-Lee==最初于1989年3月提出的</li></ul></blockquote><h4 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. <code>URL</code></h4><blockquote><p>==统一资源定位符==（<code>U</code>niform <code>R</code>esource <code>L</code>ocator）</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205094301978.png" alt="image-20231205094301978"></p><h4 id="3-万维网文档"><a href="#3-万维网文档" class="headerlink" title="3. 万维网文档"></a>3. 万维网文档</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205094813054.png" alt=""></p><h4 id="4-HTTP"><a href="#4-HTTP" class="headerlink" title="4. HTTP"></a>4. <code>HTTP</code></h4><h5 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1. 概述"></a>1. 概述</h5><blockquote><p><strong>==超文本传输协议==</strong><code>HTTP</code>(HyperText Transfer Protocol)</p><p>HTTP定义了<strong>浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</strong></p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205095412658.png" alt=""></p><h5 id="2-报文格式"><a href="#2-报文格式" class="headerlink" title="2. 报文格式"></a>2. 报文格式</h5><ul><li>==请求报文格式==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205095830137.png" alt=""></p><ul><li>==响应报文格式==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205100113338.png" alt=""></p><h4 id="5-Cookie"><a href="#5-Cookie" class="headerlink" title="5. Cookie"></a>5. <code>Cookie</code></h4><ul><li>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种==无状态==的协议。这样可以简化服务器的设计</li><li>现在，用户可以通过万维网进行各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</li><li>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是说，==Cookie是一种对无状态的HTTP进行状态化的技术==</li></ul><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205103323858.png" alt=""></p><h4 id="6-万维网缓存与代理服务器"><a href="#6-万维网缓存与代理服务器" class="headerlink" title="6. 万维网缓存与代理服务器"></a>6. 万维网缓存与代理服务器</h4><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231205103638305.png" alt=""></p><h4 id="7-思维导图和相关习题"><a href="#7-思维导图和相关习题" class="headerlink" title="7. 思维导图和相关习题"></a>7. 思维导图和相关习题</h4><p><a href="https://www.kdocs.cn/view/l/cle5dxMBHZIH">第6章 应用层（思维导图）-1 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cabHsokbKiNO">第6章 应用层（思维导图）-2 (kdocs.cn)</a></p><p><a href="https://www.kdocs.cn/view/l/cv9vfzDopPvi">第6章 应用层 习题 (kdocs.cn)</a></p><hr><h2 id="计算机网络相关术语"><a href="#计算机网络相关术语" class="headerlink" title="计算机网络相关术语"></a><em>计算机网络相关术语</em></h2><p><strong>ACK</strong> (Acknowledgement) 确认</p><p><strong>ADSL</strong> (Asymmetric Digital Subscriber Line) 非对称数字用户线</p><p><strong>AP</strong> (Access Point) 接入点</p><p><strong>AP</strong> (Application) 应用程序</p><p><strong>API</strong> (Application Programming Interface) 应用编程接口</p><p><strong>APNIC</strong> (Asia Pacific Network Information Centre) 亚太网络信息中心</p><p><strong>ARIN</strong> (American Registry for Internet Numbers) 美国因特网号码注册机构</p><p><strong>==ARP (Address Resolution Protocol) 地址解析协议==</strong></p><p><strong>ARPA</strong> (Advanced Research Projects Agency) 美国国防部远景研究规划局 (高级研究计划署) </p><p><strong>ARQ</strong> (Automatic Repeat-request) 自动重传请求</p><p><strong>AS</strong> (autonomous system) 自制系统</p><p>==<strong>BGP</strong> (Border Gateway Protocol ) 边界网关协议==</p><p><strong>BOOTP</strong> (Bootstrap Protocol) 引导程序协议</p><p><strong>BSA</strong> (Basic Service Area) 基本服务区</p><p><strong>BT</strong> (Bit Torrent) 一种P2P程序</p><p><strong>CA</strong> (Certificate Authority) 认证中心</p><p><strong>CA</strong> (Collision Avoidance) 碰撞避免</p><p><strong>CATV</strong> ( Community Antenna Television) 有线电视</p><p>==<strong>CDM</strong> (Code Division Multiplexing) 码分复用==</p><p>==<strong>CDMA</strong> (Code Division Multiple Access) 码分多址==</p><p><strong>CGI</strong>  (Common Gateway Interface) 通用网关接口</p><p>==<strong>CIDR</strong> (Classless Inter-Domain Routing) 无分类域间路由选择==</p><p>==<strong>CRC</strong> (Cyclical Redundancy Check) 循环冗余校验==</p><p>==<strong>CSMA/CD</strong> (Carrier Sense Multiple Access/Collision Detect) 载波监听 多址接入/碰撞检测==</p><p><strong>CSMA/CA</strong> (Carrier Sense Multiple Access with Collision Avoidance)  载波监听多点接入/冲突避免</p><p><strong>CTS</strong> (Clear To Send) 允许发送</p><p><strong>DACS</strong> (Digital Access and Cross-connect System) 数字交接系统</p><p><strong>==DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议==</strong></p><p><strong>DiffServ (Differentiated Services) 区分服务</strong></p><p><strong>DLCI</strong> (Data Link Connection Identifier) 数据链路连接标识符</p><p><strong>DMT</strong> (Discrete Multi-Tone) 离散多音 (调制) </p><p>==<strong>DNS</strong> (Domain Name System) 域名系统==</p><p><strong>DoS</strong> (Denial of Service) 拒绝服务</p><p><strong>DS</strong> (Distribution System) 分配系统</p><p><strong>DSL</strong> (Digital Subscriber Line) 数字用户线</p><p><strong>DSLAM</strong> ( DSL Access Multiplexer) 数字用户线接入复用器</p><p><strong>DSSS</strong> (Direct Sequence Spread Spectrum) 直接序列扩频</p><p><strong>EFM</strong> (Ethernet in the First Mile ) 第一英里的以太网</p><p><strong>EFPHB</strong> (Expedited Forwarding Per-Hop Behavior) 迅速转发每跳行为</p><p><strong>EGP</strong> (Exterior Gateway Protocol) 外部网关协议</p><p><strong>EIA</strong> (Electronic Industries Association) 美国电子工业协会</p><p><strong>FCS</strong> (Frame Check Sequence) 帧检验序列</p><p><strong>FDDI</strong> (fiber-distributed data interface) 光纤分布式数据接口</p><p>==<strong>FDM</strong> (Frequency-division multiplexing) 频分复用==</p><p><strong>FEC</strong> (Forwarding Equivalence Class) 转发等价类</p><p><strong>FFD</strong> (Full-Function Device) 全功能设备</p><p><strong>FHSS</strong> (Frequency-Hopping Spread Spectrum) 跳频扩频</p><p><strong>FIFO</strong> (First In First Out) 先进先出</p><p><strong>FQ</strong> (Fair Queuing) 公平排队</p><p>==<strong>FTP (File Transfer Protocol) 文件传输协议</strong>==</p><p><strong>GIF</strong> (Graphics System for Mobile) 全球移动通信系统，GSM体制</p><p><strong>HDLC</strong> ( High-Level Data Link Control) 高级数据链路控制</p><p><strong>HDSL</strong> (High-speed DSL) 高速数字用户线</p><p><strong>HSSG</strong> (High Speed Study Group) 高速研究组</p><p><strong>HTML</strong> (Hyper Text Markup Language) 超文本标记语言</p><p><strong>==HTTP (Hyper Text Transfer Protocol) 超文本传送协议==</strong></p><p><strong>IAB</strong> (Internet Architecture Board) 因特网体系结构委员</p><p><strong>IANA</strong> (Internet Assigned Numbers Authority) 因特网赋号管理局</p><p><strong>==ICMP (Internet Control Message Protocol) 网际控制报文协议==</strong></p><p><strong>IEEE</strong> (Institute of Electrical and Electronic Engineering) (美国) 电气和电子工程师学会</p><p><strong>IFS</strong> (Inter Frame Space) 帧间间隔</p><p><strong>IGMP</strong> (Internet Group Management Protocol) 网际组管理协议</p><p><strong>IGP</strong> (Interior Gateway Protocol) 内部网关协议</p><p><strong>IM</strong> (Instant Messaging) 及时传信</p><p><strong>==IMAP ( Internet Message Access Protocol) 因特网报文存取协议==</strong></p><p><strong>IntServ</strong> (Integrated Services) 综合服务</p><p><strong>==IP (Internet Protocol) 网际协议==</strong></p><p><strong>IPCP</strong> (IP Control Protocol) IP控制协议</p><p><strong>IPng</strong> (IP Next Protocol) 下一代IP</p><p><strong>IPsec</strong> (IP security) IP安全协议</p><p><strong>ISDN</strong> (Internet Services Digital Network) 综合业务数字网</p><p><strong>ISO</strong> (International Organization for Standardization ) 国际标准化组织</p><p><strong>ISOC</strong> (Internet Society) 因特网协会</p><p><strong>ISP</strong> (Internet Service Provider) 因特网服务提供者</p><p>==<strong>LAN</strong> (Local Area Network) 局域网==</p><p><strong>LCP</strong> (Link Control Protocol) 链路控制协议</p><p><strong>LDP</strong> (Label Distribution Protocol) 标记分配协议</p><p><strong>LLC</strong>(Logical Link Control) 逻辑链路控制</p><p><strong>LSR</strong>(Label Switched Router) 标记交换路由器</p><p><strong>MAC</strong>(Medium Access Control) 媒体接入控制</p><p><strong>MACA</strong>(Multiple Access with Collision Avoidance)具有碰撞避免的多点接入</p><p>==<strong>MAN</strong>(Metropolitan Area Network) 城域网==</p><p><strong>MBONE</strong>(Multicast Backbone On the InterNet) 多播主干网</p><p><strong>MCU</strong>(Multipoint Control Unit) 多点控制单元</p><p><strong>MD</strong>(Message Digest) 报文摘要</p><p><strong>MF</strong>(More Fragment) 还有分片</p><p><strong>MRU</strong>(Maximum Receive Unit) 最大接收单元</p><p><strong>MSS</strong>(Maximum Segment Size) 最长报文段</p><p><strong>MTU</strong>(Maximum Transfer Unit) 最大传送单元</p><p><strong>NAP</strong>(Network Access Point)　网络接入点</p><p>==<strong>NAT</strong>(Network Address Translation) 网络地址转换==</p><p><strong>NAV</strong>(Network Allocation Vector) 网络分配向量</p><p><strong>NCP</strong>(Network Control Protocol) 网络控制协议</p><p><strong>NFS</strong>(Network File System) 网络文件系统</p><p><strong>NOC</strong>(Network Operations Center) 网络运行中心</p><p><strong>NSAP</strong>(Network Service Access Point) 网络层服务访问点</p><p><strong>NSF</strong>(National Service Foundation) (美国)国家科学基金会</p><p><strong>OFDM</strong>(Orthogonal Frequency Division Multiplexing) 正交频分复用</p><p><strong>OSI/RM</strong> (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型</p><p>==<strong>OSPF(Open Shortest Path First) 开放最短通路优先</strong>==</p><p>==<strong>P2P</strong>(Peer-to-Peer) 对等方式==</p><p>==<strong>PAN</strong>(Personal Area Network) 个人区域网==</p><p><strong>PAP</strong>(Password Authentication Protocol) 口令鉴别协议</p><p><strong>PCA</strong>(Policy Certification Authority) 政策认证中心</p><p><strong>PCF</strong>(Point Coordination Function) 点协调功能</p><p><strong>PCM</strong>(Pulse Code Modulation) 脉码调制</p><p><strong>PEM</strong>(Privacy Enhanced Mail) 因特网的正式邮件加密标准</p><p><strong>PGP</strong>(Pretty Good Privacy) 一种电子邮件的机密标准</p><p><strong>PHB</strong>(Per-Hop Behavior) 每跳行为</p><p><strong>PIFS</strong>(Point Coordination Function IFS) 点协调功能帧间间隔</p><p><strong>PK</strong>(public key) 公钥，公开密钥</p><p><strong>PoP</strong>(Point of Presence) 汇接点</p><p>==<strong>POP</strong>(Post Office Protocol) 邮局协议==</p><p><strong>==PPP（Point-to-Point Protocol） 点对点协议==</strong></p><p><strong>PPPoE</strong>(Point-to-Point Protocol over Ethernet) 以太网上的点对点协议</p><p><strong>QAM</strong>(Quadrature Amplitude Modulation) 正交幅度调制</p><p><strong>QoS</strong>(Quality of Service)　服务质量</p><p><strong>QPSK</strong>(Quarternary Phase Shift Keying)正交相移键控</p><p><strong>RARP</strong>(Reverse Address Resolution Protocol)逆地址解析协议</p><p><strong>RFD</strong>(Reduced-Function Device)精简功能设备</p><p><strong>RG</strong>(Research Group)研究组</p><p><strong>==RIP(Routing Information Protocol)路由信息协议==</strong></p><p><strong>RIPE</strong>(法文表示的European IP Network)欧洲的IP 网络</p><p><strong>RTP</strong>(Real-Time Transfer Protocol)实时传送协议</p><p><strong>RTSP</strong>(Real-Time Streaming Protocol)实时流式协议</p><p>==<strong>RTT</strong>(Round-Trip Time)往返时间==</p><p><strong>SA</strong>(Security Association)安全关联</p><p><strong>SACK</strong>(Selective ACK)选择确认</p><p><strong>SAP</strong>(Service Access Point)服务访问点</p><p><strong>SCTP</strong>(Stream Control Transmission Protocol)流控制传输协议</p><p><strong>SDH</strong>(Synchronous Digital Hierarchy)同步数字系列</p><p><strong>SMI</strong>(Structure of Management Information)管理信息结构</p><p><strong>==SMTP(Simple Mail Transfer Protocol)简单邮件传送协议==</strong></p><p><strong>SNA</strong>(System Network Architecture)系统网络体系结构</p><p><strong>SNMP</strong>(Simple Network Management Protocol)简单网络管理协议</p><p><strong>SOH</strong>(Start Of Header)首部开始</p><p><strong>SONET</strong>(Synchronous Optical Network)同步光纤网</p><p><strong>STDM</strong>(Statistic TDM)统计时分复用</p><p><strong>STM</strong>(Synchronous Transfer Module)同步传递模块</p><p><strong>STS</strong>(Synchronous Transport Signal)同步传送信号</p><p><strong>TAG</strong>(TAG Switching)标记交换</p><p><strong>TCB</strong>(Transmission Control Block)传输控制程序块</p><p><strong>==TCP(Transmission Control Protocol)传输控制协议==</strong></p><p>==<strong>TDM</strong>(Time Division Multiplexing)时分复用==</p><p><strong>TELNET</strong>(TELetype NETwork)电传机网络，一种因特网的应用程序</p><p><strong>TFTP</strong>(Trivial File Transfer Protocol)简单文件传送协议</p><p><strong>TIA</strong>(Telecommunications Industries Association)电信行业协会</p><p><strong>TLD</strong>(Top Level Domain)顶级域名</p><p><strong>TLI</strong>(Transport Layer Interface)运输层接口</p><p><strong>TLS</strong>(Transport Layer Security)运输层安全协议</p><p><strong>TLV</strong>(Type-Length-Value)类型-长度-值</p><p><strong>TPDU</strong>(Transport Protocol Data Unit)运输协议数据单元</p><p><strong>==UDP(User Datagram Protocol)用户数据报协议==</strong></p><p>==<strong>URL</strong>(Uniform Resource Locator)统一资源定位符==</p><p><strong>UTP</strong>(Unshield Twisted Pair)无屏蔽双绞线</p><p><strong>UWB</strong>(Ultra-Wide Band)超宽带</p><p><strong>VC</strong>(Virtual Circuit)虚电路</p><p><strong>VDSL</strong>(Very high speed DSL)甚高数字用户线</p><p>==<strong>VLAN</strong>(Virtual LAN)虚拟局域网==</p><p>==<strong>VPN</strong>(Virtual Private Network) 虚拟专用网==</p><p>==<strong>WAN</strong>(Wide Area Network) 广域网==</p><p><strong>WDM</strong>(Wavelength Division Multiplexing) 波分复用</p><p><strong>WG</strong>(Working Group)　工作组</p><p><strong>Ｗi-Fi</strong>(Wireless-Fidelity) 无线保真度（无限局域网的同义词）</p><p><strong>WLAN</strong>(Wireless Local Area Network) 无线局域网</p><p><strong>WMAN</strong>(Wireless Metrpolitan Area Network) 无线个城域网</p><p><strong>WPAN</strong>(wireless Personal Area Network) 无线个人区域网</p><p><strong>WSN</strong>(Wireless Sensor Network)　无线传感器网络</p><p>==<strong>WWW</strong>(World Wide Web) 万维网==</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/2023/10/14/mybatis/"/>
      <url>/2023/10/14/mybatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://mybatis.org/images/mybatis-logo.png"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h3><blockquote><p>MyBatis 是一款优秀的==持久层框架==，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>新建<code>maven</code>项目</p></li><li><p>在<code>pom.xml</code>文件中导入相关依赖,数据库依赖导入需要的就行</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sqlserver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mssql-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.2.0.jre8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a><a href="https://mybatis.org/mybatis-3/zh/configuration.html">核心配置</a></h2><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><blockquote><p>配置标签顺序(核心配置文件中的==标签顺序必须符合下面顺序==)</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/image-20231013140702442.png" alt="图片没了" style="float: left;"></p><blockquote><p>核心配置文件<code>mybatis-config.xml</code>示例</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration 核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.加载配置文件，从配置文件中读取数据使用$&#123;&#125;,见下面的数据源配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--2.配置日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标准日志工厂配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置log4j日志--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        3.可以给实体类取别名，之后使用类名不需要写全限定类名</span></span><br><span class="line"><span class="comment">            3.1 typeAlias标签页实现</span></span><br><span class="line"><span class="comment">            3.2 package 扫描包下所有类并起一个默认别名为类名(小写也可以)或</span></span><br><span class="line"><span class="comment">                        如果想自定义别名，需要在类名上面加@Alias注解</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.clb.pojo.User&quot; alias=&quot;User&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.clb.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4.配置多环境，default指定使用哪个环境--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;environments default=&quot;mysql&quot;&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sql server数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ms.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ms.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ms.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;ms.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    每一个Mapper.xml配置文件都需要在mybatis核心配置文件中注册</span></span><br><span class="line"><span class="comment">        1.mapper标签 使用resource指定mapper配置文件注册(无条件!)</span></span><br><span class="line"><span class="comment">        2.mapper标签 使用class指定mapper类注册</span></span><br><span class="line"><span class="comment">        3.package标签扫描包</span></span><br><span class="line"><span class="comment">        总结:第 2,3中方法都需要满足:</span></span><br><span class="line"><span class="comment">                条件：1.接口名和它的mapper配置文件名相同</span></span><br><span class="line"><span class="comment">                     2.接口文件和它的mapper配置文件在同一个包下</span></span><br><span class="line"><span class="comment">            1.所以建议使用第一种方法，指定配置文件路径(使用配置文件时)</span></span><br><span class="line"><span class="comment">            2.使用注解开发时，使用方法2,3</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/clb/dao/EmpMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mapper class=&quot;com.clb.dao.EmpMapper&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;package name=&quot;com.clb.dao&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>数据源配置文件示例</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="attr">mysql.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">mysql.url</span>=<span class="string">jdbc:mysql://localhost:3306/clb</span></span><br><span class="line"><span class="attr">mysql.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">mysql.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># sql server</span></span><br><span class="line"><span class="attr">ms.driver</span>=<span class="string">com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line"><span class="comment">#ms.url=jdbc:sqlserver://localhost:1433;trustServerCertificate=true</span></span><br><span class="line"><span class="attr">ms.url</span>=<span class="string">jdbc:sqlserver://192.168.0.88:1433;trustServerCertificate=true</span></span><br><span class="line"><span class="attr">ms.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">ms.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="Mapper-xml映射文件"><a href="#Mapper-xml映射文件" class="headerlink" title="Mapper.xml映射文件"></a>Mapper.xml映射文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--把原来的UserDaoImpl类转换成一个xml配置文件--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.clb.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--结果集映射 type -&gt; 需要将数据库数据映射成user类型 数据库字段名和属性名一致则会自动映射，无需额外配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--colum 数据库中的列 -&gt; property 实体类中的属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        查询语句</span></span><br><span class="line"><span class="comment">            id:         对应namespace中的接口的方法名</span></span><br><span class="line"><span class="comment">            resultType: sql语句执行的返回类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.clb.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户,这里#&#123;id&#125;中的id就是方法中的id变量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.clb.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--模糊查询，concat用于拼接字符串--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.clb.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where name like concat(&#x27;&#x27;, #&#123;name&#125;, &#x27;&#x27;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加一个用户,对象中的属性可以直接取出来，不需要加类名user.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.clb.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user(id, name, pwd) value (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="MybatisUtils"><a href="#MybatisUtils" class="headerlink" title="MybatisUtils"></a>MybatisUtils</h3><blockquote><p>要使用mybatis执行sql语句，要使用<code>SqlSession</code>对象,可以直接在测试类中获取</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//加载核心配置文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">//获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//获取SqlSession对象</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">        <span class="comment">//获取Mapper对象，执行xml映射文件中的方法</span></span><br><span class="line">        <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmpMapper.class);</span><br><span class="line">        List&lt;Emp&gt; emps = mapper.selectBySalary(<span class="number">5000</span>);</span><br><span class="line">        emps.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是每次使用都要写这一串代码，==有点麻烦==，前面获取SqlSession对象的代码是固定代码，将这段固定代码提取到工具类<code>MybatisUtils</code>，使用工具类的静态方法获取SqlSession对象</p><p>==MybatisUtils工具类示例==</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sqlSessionFactory --&gt; sqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MybatisUtils</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//定义一个SqlSessionFactory对象并使用静态初始化块初始化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用mybatis第一步，获取sqlSessionFactory对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMybatisUtils</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用工具类直接获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    List&lt;Emp&gt; emps = mapper.selectBySalary(<span class="number">1000</span>);</span><br><span class="line">    emps.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><blockquote><p>使用注解直接写sql语句代替xml映射文件</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, pwd password from user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @Param()注解:</span></span><br><span class="line"><span class="comment">    *   1.基本类型或者String类型需要加上</span></span><br><span class="line"><span class="comment">    *   2.引用类型可以不加</span></span><br><span class="line"><span class="comment">    *   3.如果只有一个基本类型的话，可以不加，但是建议加上</span></span><br><span class="line"><span class="comment">    *   4.在注解中的sql语句中&#123;&#125;中的参数就是@Param注解中的属性名</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, pwd password &quot; +</span></span><br><span class="line"><span class="meta">            &quot;from user &quot; +</span></span><br><span class="line"><span class="meta">            &quot;where id = #&#123;id&#125; and name=#&#123;name&#125; and pwd=#&#123;password&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> i, <span class="meta">@Param(&quot;name&quot;)</span>String n, <span class="meta">@Param(&quot;password&quot;)</span> String p)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;中的三个属性均来自参数中对象的属性</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(id, name, pwd) VALUE (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>@Result</code>注解可以定义结果映射，使用<code>@ResultMap</code>可以引用xml文件中定义的ResultMap结果映射</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where first_name = #&#123;name&#125;;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;first_name&quot;, property = &quot;firstName&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Emp <span class="title function_">getByFirstNameEmp</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更推荐使用</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from emp where first_name = #&#123;name&#125;;&quot;)</span></span><br><span class="line"><span class="meta">@ResultMap(&quot;EmpMap&quot;)</span></span><br><span class="line">Emp <span class="title function_">getByFirstNameEmp</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>总结：简单的sql语句使用注解比配置文件来的更方便且更快，但是复杂的sql语句使用注解反而不方便或难以实现，所以==简单的sql使用注解，复杂的使用xml，搭配使用==</p></blockquote><hr><h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">动态 SQL</a></h2><blockquote><p>==动态查询==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。</span></span><br><span class="line"><span class="comment">    而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--动态sql if标签 如果参数不为空就加上条件，否则不加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pageQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.entity.Category&quot;</span>&gt;</span></span><br><span class="line">    select * from category</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type != null&quot;</span>&gt;</span></span><br><span class="line">            and type = #&#123;type&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by sort asc , create_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==动态更新==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span></span><br><span class="line">    update category</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type != null&quot;</span>&gt;</span></span><br><span class="line">            type = #&#123;type&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sort != null&quot;</span>&gt;</span></span><br><span class="line">            sort = #&#123;sort&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">            update_time = #&#123;updateTime&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateUser != null&quot;</span>&gt;</span></span><br><span class="line">            update_user = #&#123;updateUser&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==批量插入，传入参数是一个集合类型，删除同理==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBatch&quot;</span>&gt;</span></span><br><span class="line">    insert into dish_flavor (dish_id, name, value)values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;flavors&quot;</span> <span class="attr">item</span>=<span class="string">&quot;f&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;f.dishId&#125;,#&#123;f.name&#125;,#&#123;f.value&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多动态SQL用法见<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">官网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/08/31/Redis/"/>
      <url>/2023/08/31/Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://redis.io/">Redis</a></h1><h2 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h2><blockquote><p>==NoSQL==    &gt;&gt;&gt;&gt;&gt;    ==not only sql==,不仅仅是sql(不是没有sql)</p></blockquote><p>Nosql特点</p><ol><li>方便拓展（数据之间没有关系，很好拓展！）</li><li>大数据量高性能（redis一秒写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li><li>数据类型是多样的！（不需要事先设计数据库！随取随用！如果是数据量非常大的表，关系型数据库就很难设计了！）</li><li>传统==RDBMS==(关系型数据库管理系统)和==NoSQL==</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RDBMS的特点：</span><br><span class="line"></span><br><span class="line">- 基于关系模型，使用表格的存储方式，数据按照行和列进行组织。</span><br><span class="line">- 使用SQL语言进行数据的查询和操作，SQL语言是一种通用的、标准化的、结构化的语言，可以进行复杂的查询和分析。</span><br><span class="line">- 强调ACID规则（原子性、一致性、隔离性、持久性），可以保证数据的完整性和一致性，适合处理高要求的事务操作。</span><br><span class="line">- 通常只能进行纵向扩展，即增加单个服务器的硬件资源来提高性能，这种方式成本高昂且有上限。</span><br><span class="line">- 适合处理结构化或半结构化的数据，需要进行复杂查询或分析的场景，例如金融、电商、教育等领域。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NoSQL的特点：</span><br><span class="line"></span><br><span class="line">- 不基于关系模型，使用键值对、文档、图形等多种存储方式，数据的结构和格式可以灵活变化，不需要预先定义。</span><br><span class="line">- 使用非结构化查询语言（UnQL）或者特定的API进行数据的访问和操作，UnQL没有统一的标准，每种NoSQL数据库都有自己的语法和规则。</span><br><span class="line">- 通常只提供弱一致性或最终一致性的保证，不能支持复杂的事务操作，但可以提高数据的可用性和并发性。</span><br><span class="line">- 通常可以进行横向扩展，即增加多个服务器来分担数据和负载，这种方式成本低廉且可以无限扩展。</span><br><span class="line">- 适合处理非结构化或多变的数据，需要高并发或海量数据存储的场景，例如社交网络、游戏、物联网等领域。</span><br></pre></td></tr></table></figure><p>大数据时代的3V:主要是描述问题的</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高:主要是对程序的要求</p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>实际开发项目一般都是 NoSQL+RDBMS 搭配使用</p><hr><h2 id="redis入门"><a href="#redis入门" class="headerlink" title="redis入门"></a>redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>redis是什么？</p></blockquote><ol><li>Redis（==Re==mote ==Di==ctionary ==S==erver )，即远程字典服务</li><li>是一个开源的使用ANSI ==C语言==编写、支持网络、可基于内存亦可持久化的日志型、==Key-Value==数据库，并提供多种语言的API</li><li>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave==(主从)同步==</li><li>免费和开源，是当下最热门的NoSQL技术之一</li></ol><blockquote><p>redis能做什么？</p></blockquote><ol><li>内存存储、==持久化==，内存是断电即失的，所以说持久化很重要！</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量）</li></ol><blockquote><p>特性</p></blockquote><ol><li>多样的数据类型</li><li>持久化</li><li>事务</li><li>集群</li></ol><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><blockquote><p>登录redis客户端redis-cli:computer:</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接登录 -h ip地址 -p 端口号 -a 密码(不用密码也能登陆，但是没有权限)</span></span><br><span class="line">redis-cli -h localhost -p 6379 -a 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐登录后再用密码进行认证</span></span><br><span class="line"><span class="comment"># 1.登录</span></span><br><span class="line">redis-cli (-h localhost -p 6379 如果是本地登陆可以省略)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.身份认证 OK &gt;&gt;&gt; 成功</span></span><br><span class="line">&gt; auth 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命令的帮助信息</span></span><br><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p><img src="https://github.com/TankingCao/picx-images-hosting/raw/master/CopyQ.PGpyFa.13e3fgmo8pb4.webp" alt="CopyQ" /></p><blockquote><p><strong>redis有==16==个数据库(0-15)，默认使用的是==0==，可以使用select切换数据库</strong></p></blockquote><p>切换数据库 <code>select [index]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换数据库为1号</span></span><br><span class="line"><span class="keyword">select</span> 1</span><br></pre></td></tr></table></figure><p>查看当前数据库大小<code>dbsize</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbsize</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>设置键值对<code>set [key] [value]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> name clb</span><br><span class="line">&gt; OK</span><br></pre></td></tr></table></figure><p>根据键获取值<code>get [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get name</span><br><span class="line">&gt; <span class="string">&quot;clb&quot;</span></span><br></pre></td></tr></table></figure><p>查找所有适配的key <code>keys [pattern]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有</span></span><br><span class="line">keys *</span><br><span class="line">&gt; 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">&gt; 2) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure><p>清空当前数据库<code>flushdb</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure><p>清空所有数据库<code>flushall</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>==redis是单线程的！==</strong></p></blockquote><p>官方表示，redis是基于内存操作，CPU不是redis的性能瓶颈，redis的性能瓶颈是机器的内存大小和网络带宽，既然单线程更容易实现，那就顺理成章的使用单线程了</p><blockquote><p>==<strong>redis为什么单线程还这么快？</strong>==</p></blockquote><p>误区：</p><ul><li>高性能的服务器一定是多线程的？</li><li>多线程（CPU上下文会切换）一定比单线程效率高？</li></ul><p>==核心==：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写操作都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p><hr><h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><p>查看一个或者多个key是否存在，返回个数<code>exists [key...]</code></p><p><img src="https://github.com/TankingCao/picx-images-hosting/raw/master/CopyQ.WwCwYX.17lc3f7zn400.webp" alt="CopyQ" /></p><p>设置过期时间(多长时间后过期自动从数据库删除)<code>expire [key] [time] 单位默认是秒</code></p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expire name 3<span class="comment"># 3秒后过期，过期了数据就没了</span></span><br></pre></td></tr></table></figure></blockquote><p>查看key的剩余时间<code>ttl [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ttl name</span><br><span class="line">&gt; 2</span><br></pre></td></tr></table></figure><p>移动key到其他数据库<code>move [key] [db]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">move name 15</span><br></pre></td></tr></table></figure><p>删除一个或多个key<code>del [key...]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del name</span><br><span class="line">del name age</span><br></pre></td></tr></table></figure><p>查看key的类型<code>type [key]</code>,不存在返回none</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> name </span><br><span class="line">&gt; string</span><br></pre></td></tr></table></figure><hr><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作==数据库==、==缓存==和==消息中间件==，它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）</p><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>==字符串==</p><p>set、get、keys、exists同上</p><p>追加字符串<code>append [key] [value]</code> 如果name不存在，就等同于set方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">append name nb</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><p>查询字符串长度<code>strlen [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strlen name</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><hr><p>增加和减少操作，前提是key对应的值可以转化成integer，否则报错</p><p>自增(++) <code>incr [key]</code>,自减(–)<code>decr [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get views</span><br><span class="line">&gt; <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">incr views</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">decr views</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>增加(+=)<code>incrby [key] [步长]</code>，减少(-=)<code>decrby [key] [步长]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get views</span><br><span class="line">&gt; <span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">INCRBY views 5</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 15</span><br><span class="line"></span><br><span class="line">DECRBY views 3</span><br><span class="line">&gt; (<span class="built_in">integer</span>) 12</span><br></pre></td></tr></table></figure><blockquote><p> 获取字符串的子串<code>getrange [key] [start] [end]</code></p></blockquote><p>注意：==闭区间==（开始索引和结束索引都包含），==逆序索引从-1开始(倒数第1个索引为-1，倒数第2索引为-2…)==</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get k</span><br><span class="line">&gt; <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line">getrange k 0 4<span class="comment">#[0,4]</span></span><br><span class="line">&gt; <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">getrange k 0 -1<span class="comment">#获取全部，0表示头部，-1表示尾部</span></span><br><span class="line"><span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>替换字符串<code>setrange [key] [start] [value]</code>,从start索引开始，用value直接覆盖后面的值，如果原来字符串长度不够，那么补0增加长度后再进行覆盖</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line"><span class="string">&quot;12345&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setrange str 1 abcdefg</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line"><span class="string">&quot;1abcdefg&quot;</span></span><br></pre></td></tr></table></figure><p>设置key-value并指定过期时间<code>setex [key] [seconds] [value]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 clb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure><blockquote><p>==设置key-value==<code>setnx [key] [value]</code></p></blockquote><p>和set的区别：==如果key已经存在，set方法直接覆盖原来的值，而setnx不会==</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name cxk</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx name ikun</span><br><span class="line">(<span class="built_in">integer</span>) 0<span class="comment">#key已经存在，不覆盖</span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;cxk&quot;</span></span><br></pre></td></tr></table></figure><hr><p>批量设置<code>mset [key value ...]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br></pre></td></tr></table></figure><p>批量获取<code>mget [key ...]</code></p><blockquote><p>批量设置<code>msetnx [key value ...]</code>msetnx是一个==<strong>原子性</strong>==操作，要么全部成功，要么全部失败,只要有一个key存在，整个操作全部失败</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 666 k4 999</span><br><span class="line">(<span class="built_in">integer</span>) 0<span class="comment"># k1存在，整个操作失败，k4也未赋值</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure><hr><p>设置一个对象user:1 值用一个json字符串来表示，但是这样不能直接获取到name属性，所以要单独赋值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">user</span>:<span class="number">1</span> &#123;name:zhangsan,age:<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的key的设计：<code>user:&#123;id&#125;:&#123;filed&#125;</code>非常巧妙(这样就能直接获取一个user对象中的各种属性，类似一种层次结构)</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> mset <span class="keyword">user</span>:<span class="number">1</span>:name zhangsan <span class="keyword">user</span>:<span class="number">1</span>:age <span class="number">19</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> mget <span class="keyword">user</span>:<span class="number">1</span>:name <span class="keyword">user</span>:<span class="number">1</span>:age</span><br><span class="line"><span class="number">1</span>) &quot;zhangsan&quot;</span><br><span class="line"><span class="number">2</span>) &quot;19&quot;</span><br></pre></td></tr></table></figure><hr><blockquote><p>getset方法<code>getset [key] [value]</code>获取key原来对应的value，设置一个新的值，返回原来被替换的值，如果本来就不存在，返回nil</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> getset name ikun</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> getset name kunkun</span><br><span class="line">&quot;ikun&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">get</span> name</span><br><span class="line">&quot;kunkun&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>==列表==</p><p>插入值</p><ol><li>从左边插入（头插法）<code>lpush [key] [value ...]</code></li><li>从右边插入（尾插法）<code>rpush [key] [value ...]</code></li><li>从左边开始遍历<code>lrange [start] [end]</code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lpush list <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span> # <span class="number">-1</span>代表尾部，所以是遍历全部</span><br><span class="line"><span class="number">1</span>) &quot;3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;1&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpush list <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;1&quot;</span><br><span class="line"><span class="number">4</span>) &quot;4&quot;</span><br><span class="line"><span class="number">5</span>) &quot;5&quot;</span><br><span class="line"><span class="number">6</span>) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>移除元素</p><ol><li>从左边开始移除<code>lpop [key] [count个数]</code></li><li>从右边开始移除<code>rpop [key] [count个数]</code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;1&quot;</span><br><span class="line"><span class="number">4</span>) &quot;4&quot;</span><br><span class="line"><span class="number">5</span>) &quot;5&quot;</span><br><span class="line"><span class="number">6</span>) &quot;6&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lpop list <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpop list <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;6&quot;</span><br><span class="line"><span class="number">2</span>) &quot;5&quot;</span><br><span class="line"><span class="number">3</span>) &quot;4&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>获取列表中指定索引的值<code>lindex [key] [index]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange lst <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;3&quot;</span><br><span class="line"><span class="number">4</span>) &quot;2&quot;</span><br><span class="line"><span class="number">5</span>) &quot;1&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lindex lst <span class="number">1</span></span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>获取列表长度<code>llen [key]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange lst <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;4&quot;</span><br><span class="line"><span class="number">3</span>) &quot;3&quot;</span><br><span class="line"><span class="number">4</span>) &quot;2&quot;</span><br><span class="line"><span class="number">5</span>) &quot;1&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> llen lst</span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>删除列表中n个指定元素(精确匹配)<code>lrem [key] 3 2</code> &gt;&gt;&gt; 删除list列表中从左往右数的前3个2，返回值为成功删除的个数</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;2&quot; </span><br><span class="line"><span class="number">2</span>) &quot;10&quot;</span><br><span class="line"><span class="number">3</span>) &quot;9&quot;</span><br><span class="line"><span class="number">4</span>) &quot;6&quot;</span><br><span class="line"><span class="number">5</span>) &quot;2&quot;</span><br><span class="line"><span class="number">6</span>) &quot;2&quot;</span><br><span class="line"><span class="number">7</span>) &quot;2&quot;</span><br><span class="line"><span class="number">8</span>) &quot;1&quot;</span><br><span class="line"><span class="number">9</span>) &quot;2&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrem list <span class="number">3</span> <span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;10&quot;</span><br><span class="line"><span class="number">2</span>) &quot;9&quot;</span><br><span class="line"><span class="number">3</span>) &quot;6&quot;</span><br><span class="line"><span class="number">4</span>) &quot;2&quot;</span><br><span class="line"><span class="number">5</span>) &quot;1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;2&quot;</span><br></pre></td></tr></table></figure><p>截取列表指定索引之间的元素<code>ltrim [key] [start] [stop]</code> 截取[start,stop],==这是在原数组上进行修改!==</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;c&quot;</span><br><span class="line"><span class="number">4</span>) &quot;d&quot;</span><br><span class="line"><span class="number">5</span>) &quot;e&quot;</span><br><span class="line"><span class="number">6</span>) &quot;ok&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> ltrim list <span class="number">0</span> <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;c&quot;</span><br></pre></td></tr></table></figure><blockquote><p>移除arr1中最右边的元素并从左边插入arr2<code>rpoplpush [source] [destination]</code></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange arr1 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;3&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange arr2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;c&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpoplpush arr1 arr2</span><br><span class="line">&quot;3&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange arr1 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;2&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange arr2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;a&quot;</span><br><span class="line"><span class="number">3</span>) &quot;b&quot;</span><br><span class="line"><span class="number">4</span>) &quot;c&quot;</span><br></pre></td></tr></table></figure><p>根据索引设置列表中的元素<code>lset [key] [index] [value]</code>，相当于更新操作</p><p>列表不存在或索引超出范围(可以使用负数表示逆序索引)都会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v3&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lset list <span class="number">1</span> <span class="number">666</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;666&quot;</span><br><span class="line"><span class="number">3</span>) &quot;v3&quot;</span><br></pre></td></tr></table></figure><p>在列表中从左往右数第1个pivot前面/后面插入指定元素</p><p><code>linsert [key] before|after [pivot] [element]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">2</span>) &quot;cxk&quot;</span><br><span class="line"><span class="number">3</span>) &quot;clb&quot;</span><br><span class="line"><span class="number">4</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">5</span>) &quot;nb&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> linsert list before kun <span class="number">666</span> # 从左往右第一个kun前插入<span class="number">666</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;666&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">3</span>) &quot;cxk&quot;</span><br><span class="line"><span class="number">4</span>) &quot;clb&quot;</span><br><span class="line"><span class="number">5</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">6</span>) &quot;nb&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> linsert list after nb ctrl # 从左往右第一个nb后面插入ctrl</span><br><span class="line">(<span class="type">integer</span>) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange list <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;666&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">3</span>) &quot;cxk&quot;</span><br><span class="line"><span class="number">4</span>) &quot;clb&quot;</span><br><span class="line"><span class="number">5</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">6</span>) &quot;nb&quot;</span><br><span class="line"><span class="number">7</span>) &quot;ctrl&quot;</span><br></pre></td></tr></table></figure><blockquote><p>小结：List实际上是一个==双向链表==结构，在两边crud快，中间元素crud相对较慢</p></blockquote><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>==集合，不能有重复元素==</p><p>set集合添加元素<code>sadd [key] [member ...]</code>,添加重复元素无效</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd <span class="keyword">set</span> hello ikun cxk ctrl hello</span><br><span class="line">(<span class="type">integer</span>) <span class="number">4</span> # 因为<span class="keyword">set</span>不允许有重复元素，所以最后一个hello未被添加</span><br></pre></td></tr></table></figure><p>set查看所有元素<code>smembers [key]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> smembers <span class="keyword">set</span></span><br><span class="line"><span class="number">1</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">2</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">3</span>) &quot;hello&quot;</span><br><span class="line"><span class="number">4</span>) &quot;cxk&quot;</span><br></pre></td></tr></table></figure><p>set是否包含元素<code>sismember [key] [member]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sismember <span class="keyword">set</span> ikun</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>获取set中元素个数<code>scarg set</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> scard <span class="keyword">set</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">4</span></span><br></pre></td></tr></table></figure><p>移除set中指定元素<code>srem [key] [member]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srem <span class="keyword">set</span> ikun</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>从set中随机移除几个元素<code>spop [key] [count:个数超出上限则全部移除]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> spop <span class="keyword">set</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> spop <span class="keyword">set</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;4&quot;</span><br><span class="line"><span class="number">2</span>) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>从set中随机取出几个元素<code>srandmember [key] [count:个数超出上限则取出全部]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srandmember <span class="keyword">set</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srandmember <span class="keyword">set</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;4&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srandmember <span class="keyword">set</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;4&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srandmember <span class="keyword">set</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;5&quot;</span><br></pre></td></tr></table></figure><p>从一个集合中移动指定元素到另外一个集合<code>smove [source] [destination] member</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd s1 ikun cxk</span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd s2 ctrl rap</span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> smove s1 s2 ikun</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> SMEMBERS s2</span><br><span class="line"><span class="number">1</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">2</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">3</span>) &quot;rap&quot;</span><br></pre></td></tr></table></figure><p>差集、交集、并集<code>sdiff|sinter|sunion [set1] [set2...]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd s1 a b c d</span><br><span class="line">(<span class="type">integer</span>) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd s2 c d e f</span><br><span class="line">(<span class="type">integer</span>) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sdiff s1 s2 # 差集</span><br><span class="line"><span class="number">1</span>) &quot;a&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sdiff s2 s1 # 差集</span><br><span class="line"><span class="number">1</span>) &quot;e&quot;</span><br><span class="line"><span class="number">2</span>) &quot;f&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sinter s1 s2 # 交集</span><br><span class="line"><span class="number">1</span>) &quot;d&quot;</span><br><span class="line"><span class="number">2</span>) &quot;c&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sunion s1 s2 # 并集</span><br><span class="line"><span class="number">1</span>) &quot;f&quot;</span><br><span class="line"><span class="number">2</span>) &quot;b&quot;</span><br><span class="line"><span class="number">3</span>) &quot;a&quot;</span><br><span class="line"><span class="number">4</span>) &quot;e&quot;</span><br><span class="line"><span class="number">5</span>) &quot;d&quot;</span><br><span class="line"><span class="number">6</span>) &quot;c&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>==键值对，相当于map==</p><p>设置<code>hset|hmset [hash] [key value ...]</code>hset从redis4开始支持批量设置</p><p>获取</p><ol><li>根据key获取一个 值<code>hget [hash] [key]</code></li><li>根据多个key获取多个值<code>hmget [hash] [key ...]</code></li><li>获取所有键和值<code>hgetall [hash]</code></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hset hash k1 v1 k2 v2 k3 v3</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hget hash k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hgetall hash</span><br><span class="line"><span class="number">1</span>) &quot;k1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">5</span>) &quot;k3&quot;</span><br><span class="line"><span class="number">6</span>) &quot;v3&quot;</span><br></pre></td></tr></table></figure><p>根据键删除k-v<code>hdel [hash] [key ...]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hdel hash k1</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>获取键值对个数<code>hlen [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hlen hash</span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>获取所有的key<code>hkeys [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hkeys hash</span><br><span class="line"><span class="number">1</span>) &quot;k2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;k3&quot;</span><br></pre></td></tr></table></figure><p>获取所有的value<code>hvals [hash]</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hvals hash</span><br><span class="line"><span class="number">1</span>) &quot;v2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;v3&quot;</span><br></pre></td></tr></table></figure><p><code>hsetnx</code> <code>hincrby</code>用法同string</p><blockquote><p>hash更多应用于存储用户信息！</p></blockquote><hr><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>==有序集合==，在set基础上增加了一个score，默认根据score升序排序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zadd <span class="keyword">set</span> <span class="number">-6</span> ikun <span class="number">66</span> kun <span class="number">6</span> kunkun <span class="number">0</span> ctrl</span><br><span class="line">(<span class="type">integer</span>) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrange <span class="keyword">set</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">2</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">3</span>) &quot;kunkun&quot;</span><br><span class="line"><span class="number">4</span>) &quot;kun&quot;</span><br></pre></td></tr></table></figure><p>获取score在-inf(负无穷,可以改为具体数值)到+inf之间元素并带有score(升序)</p><p><code>zrangebyscore [set] [-inf] [+inf] (withscores可以不用)</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrangebyscore <span class="keyword">set</span> <span class="operator">-</span>inf <span class="operator">+</span>inf withscores</span><br><span class="line"><span class="number">1</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">2</span>) &quot;-6&quot;</span><br><span class="line"><span class="number">3</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">4</span>) &quot;0&quot;</span><br><span class="line"><span class="number">5</span>) &quot;kunkun&quot;</span><br><span class="line"><span class="number">6</span>) &quot;6&quot;</span><br><span class="line"><span class="number">7</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">8</span>) &quot;66&quot;</span><br></pre></td></tr></table></figure><p>根据score逆序获取，range前面加<code>rev</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrevrange <span class="keyword">set</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">2</span>) &quot;kunkun&quot;</span><br><span class="line"><span class="number">3</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">4</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> ZREVRANGEBYSCORE <span class="keyword">set</span> <span class="operator">+</span>inf <span class="operator">-</span>inf withscores</span><br><span class="line"><span class="number">1</span>) &quot;kun&quot;</span><br><span class="line"><span class="number">2</span>) &quot;66&quot;</span><br><span class="line"><span class="number">3</span>) &quot;kunkun&quot;</span><br><span class="line"><span class="number">4</span>) &quot;6&quot;</span><br><span class="line"><span class="number">5</span>) &quot;ctrl&quot;</span><br><span class="line"><span class="number">6</span>) &quot;0&quot;</span><br><span class="line"><span class="number">7</span>) &quot;ikun&quot;</span><br><span class="line"><span class="number">8</span>) &quot;-6&quot;</span><br></pre></td></tr></table></figure><blockquote><p>获取有序集合元素个数<code>zcard [set]</code></p><p>统计score在区间内的元素个数<code>zcount [set] [min] [max]</code>包含两端</p></blockquote><hr><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a><a href="http://www.redis.cn/commands/geoadd.html">Geospatial(地理位置)</a></h3><blockquote><p>==<strong>geoadd</strong>== 添加一个或多个城市信息<code>geoadd [key] [经度 纬度 member ...]</code></p><p>:rocket: ==<strong>这里的key实际上是zset(有序集合),zset方法可以操作这里的key</strong>==</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p> 查询所有位置信息</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>==<strong>geopos</strong>== 查询一个或多个城市经度和纬度<code>geopos [key] [member ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing shanghai</span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">   2) <span class="string">&quot;31.22999903975783553&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>==<strong>geodist</strong>==计算两地之间的距离<code>geodist [key] [member1] [member2] [unit:单位,默认为米]</code></p></blockquote><ul><li><strong>m</strong> 表示单位为米(默认使用)</li><li><strong>km</strong> 表示单位为千米</li><li><strong>mi</strong> 表示单位为英里</li><li><strong>ft</strong> 表示单位为英尺</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>==<strong>georadius</strong>== 以指定点为半径，查找位置在方圆半径内的元素(元素来源于key)，==返回结果按照距离升序排序==</p><p><code>georadius [key] [经度 纬度 距离 单位] [withcoord:输出经纬度] [withdist:输出距离] [count 个数:指定查找的最多个数]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找以经纬度坐标(110,30)为中心，方圆500km内的城市信息，只找最近的两个(只找出在china:key中录入的城市)</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>==georadiusmember==</strong> 根据已存在点作为中心查找范围内的元素,用法同上</p><p><code>georadiusbymember [key] [member] 200 km</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 200 km</span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>geohash返回一个位置的geohash字符串(11位字符) <code>geohash [key] [mamber ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash china:city beijing shanghai</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw3sj5zbj0&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>==元素不重复，类似于set集合，但是占用内存更小，不过数据量大的时候有一定误差==</p><blockquote><p>添加元素  <code>pfadd [key] [value ...]</code></p><p>统计不重复元素个数 <code>pfcount [key]</code></p><p>合并多个集合 <code>pfmege [destination] [source ...]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd set1 1 2 3 4 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd set2 4 5 6 7 8</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge set3 set1 set2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount set3</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br></pre></td></tr></table></figure><hr><h3 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap(位图)"></a>Bitmap(位图)</h3><p>设置一周打卡信息(1 打卡，0 未打卡)</p><blockquote><p><code>setbit [key] [offset:int数字，此处表示周几] [status 0/1]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 7 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><blockquote><p>获取某天状态 <code>getbit [key] [offset]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>统计状态为1的个数 <code>bitcount [key]</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>redis事务本质：一组命令的集合，有一致性、顺序性、排他性，</p><p>==redis事务没有隔离级别的概念==，所有命令在事务中并没有直接被执行，只有发起执行命令的时候才会执行</p><p><strong>==redis单条命令保证原子性，但是事务不保证原子性==</strong></p><blockquote><p>redis的事务</p></blockquote><ul><li>开始事务（<code>multi</code> 开启事务之后输入的命令不会直接执行，而是进入命令队列，直到事务被执行，所有的命令才按顺序执行）</li><li>命令入队（<code>...</code>）</li><li>执行事务（<code>exec</code>） </li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; mget k1 k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) 1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">   2) <span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>放弃事务（<code>discard</code>命令入队过程中使用可以放弃事务）</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 1231</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>==编译型异常==（命令有问题，过不了编译），事务中所有命令不执行！</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; setttttt k2 v2<span class="comment"># 不存在的命令导致编译异常</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;setttttt&#x27;</span>, with args beginning with: <span class="string">&#x27;k2&#x27;</span> <span class="string">&#x27;v2&#x27;</span> </span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.<span class="comment"># 之前的编译异常导致整个事务被放弃</span></span><br></pre></td></tr></table></figure><blockquote><p>==运行时异常==（除0错误，索引越界…）错误命令不执行，其他命令正常执行，==不能保证原子性==</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1<span class="comment"># v1不能转换为integer类型，运行时异常，编译没问题</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>==<strong>悲观锁</strong>==：很悲观，认为什么时候都会出问题，无论做什么都会加锁</p><p>==<strong>乐观锁</strong>==：</p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul></blockquote><p>使用watch当做redis的乐观锁操作 <code>watch [key]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多线程并发修改</span></span><br><span class="line"><span class="comment"># --------------线程1--------------</span></span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视，想当于加乐观锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby money 666</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># exec还未执行时，线程2开始执行</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)<span class="comment"># 执行失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------线程2--------------</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money -6<span class="comment"># 修改了线程1中加了乐观锁的money</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>执行失败后使用<code>unwatch</code>解锁后再重新监视并执行</p><hr><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>==官方推荐==的java连接开发工具，使用java操作redis的中间件，如果要使用java操作redis，那么一定要对jedis十分的熟悉！</p><ol><li>导入jedis依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jedis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>创建jedis对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Jedis对象并认证</span></span><br><span class="line">jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.66.6&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>使用jedis对象调用API,jedis的API基本都是对应redis中的命令</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.flushDB();</span><br><span class="line">System.out.println(jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;clb&quot;</span>));</span><br><span class="line">System.out.println(jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>));</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>事务操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#事务</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTX</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    json.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cxk&quot;</span>);</span><br><span class="line">    json.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;34&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> json.toJSONString();</span><br><span class="line">    jedis.flushDB();</span><br><span class="line"></span><br><span class="line">    jedis.watch(result);</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 制造一个运行时异常</span></span><br><span class="line">        multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">        multi.exec(); <span class="comment">//执行事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        multi.discard();<span class="comment">//放弃事务</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">        jedis.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>SpringBoot2.x之后，原来使用的jedis被替换成了lettuce</p><p>==jedis==：采用直连，多个线程池操作的话，是不安全的，如果想要避免，就要使用<code>jedis pool</code>连接池，更像<code>BIO</code>（阻塞IO）模式</p><p>==<strong>lettuce</strong>==：采用<code>netty</code>，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据，更像<code>NIO</code>（非阻塞IO）模式</p><ol><li>导入redis依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>配置文件配置redis</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.66</span><span class="number">.6</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis02SpringbootApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法和redis命令一一对应</span></span><br><span class="line">        <span class="comment">//opsForValue()   操作String</span></span><br><span class="line">        <span class="comment">//opsForList()    操作List</span></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;坤坤&quot;</span>);</span><br><span class="line">      System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis中各种数据类型对应的操作方法</p><p><img src="https://github.com/TankingCao/picx-images-hosting/raw/master/1693648470356.jpg" alt="1693648470356" /></p><ol><li>==序列化== ：<ul><li>在Spring Boot中，序列化是指==将对象转换为可以存储或传输的字节序列的过程==。这可以通过将对象转换为==JSON==或==XML==格式来实现。序列化允许在存储或传输对象时==减少内存使用==，并确保在在不同系统之间交换数据时能够正确表示对象</li><li>实体类一般都要序列化，<code>implements Serializable</code>实现序列化接口就可以了，默认使用的是JDK序列化,也可以使用其他json工具实现，因为默认的jdk序列化存储中文到redis会出现乱码</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus</title>
      <link href="/2023/08/31/mybatis-plus/"/>
      <url>/2023/08/31/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上==只做增强不做改变==，为简化开发、提高效率而生。</p></blockquote><p><img src="https://www.baomidou.com/img/relationship-with-mybatis.png" alt=""></p><h2 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h2><h3 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h3><blockquote><p>导入mybatis-plus依赖,包含了mybatis，==不用额外再导入mybatis依赖==</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-创建Mapper"><a href="#1-2-创建Mapper" class="headerlink" title="1.2 创建Mapper"></a>1.2 创建Mapper</h3><blockquote><p>为了简化单表CRUD，mp已经提供了对于单表的CRUD操作的接口<code>BaseMapper</code>,直接继承BaseMapper接口即可直接使用</p></blockquote><p><img src="https://gitee.com/clibin/image-bed/raw/master/202309122231328.png" alt=""></p><h3 id="1-3-测试CRUD"><a href="#1-3-测试CRUD" class="headerlink" title="1.3 测试CRUD"></a>1.3 测试CRUD</h3><blockquote><p>测试BaseMapper中对单表CRUD操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//user.setId(5L);</span></span><br><span class="line">    user.setUsername(<span class="string">&quot;ikun23&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">    user.setBalance(<span class="number">200</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>,<span class="string">&quot;英语老师&quot;</span>,<span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">5L</span>);</span><br><span class="line">    user.setBalance(<span class="number">3</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>,<span class="string">&quot;英语老师&quot;</span>,<span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(userMapper.deleteById(<span class="number">5L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：只要继承了<code>BaseMapper</code>，就能直接对单表进行CRUD操作！</p></blockquote><h2 id="2-常见注解"><a href="#2-常见注解" class="headerlink" title="2.常见注解"></a>2.常见注解</h2><blockquote><p><strong>问题</strong>：在刚刚的测试中，我们直接调用BaseMapper中的方法就能对表增删改查，在继承<code>BaseMapper</code>的时候我们只是指定了一个泛型<code>&lt;User&gt;</code>,并没有指定是哪张表，那么==mybatis-plus怎么知道我们要操作的是user表呢？它又是怎么知道这张表中的所有字段名呢？==</p><p>解答：其实mp遵从==约定大于配置==的思想,mp从<code>User</code>类推导出数据库中表名为<code>user</code>，然后根据User类中的所有变量名从==驼峰命名==转成==下划线==作为数据库的字段名，从而在调用方法时可以自动生成正确的sql语句。</p><p>如果我们在创建User类和user表的时候遵从驼峰命名和下划线命名，那么我们不需要做额外的配置，如果类名和表名、属性名和字段名直接不是简单的转换，那么我们就不得不使用一些相应的注解来声明表的信息</p></blockquote><h3 id="2-1-TableName"><a href="#2-1-TableName" class="headerlink" title="2.1 @TableName"></a>2.1 <a href="https://www.baomidou.com/pages/223848/#tablename">@TableName</a></h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-TableId"><a href="#2-2-TableId" class="headerlink" title="2.2  @TableId"></a>2.2 <a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableId.java"> @TableId</a></h3><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>==IdType.NONE==</td><td>指定主键类型</td></tr></tbody></table></div><p><code>IdType</code>支持的类型有：</p><div class="table-container"><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td><del>ID_WORKER</del></td><td>分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td><del>UUID</del></td><td>32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td><del>ID_WORKER_STR</del></td><td>分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table></div><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="2-3-TableField"><a href="#2-3-TableField" class="headerlink" title="2.3 @TableField"></a>2.3 <a href="https://www.baomidou.com/pages/223848/#tablefield">@TableField</a></h3><ul><li>描述：字段注解（非主键）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常见配置"><a href="#3-常见配置" class="headerlink" title="3.常见配置"></a>3.常见配置</h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：<br><a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">使用配置 | MyBatis-Plus</a></p><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span><span class="comment">#别名扫描包</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure><p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure><p>可以看到默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。</p><p>使用<code>@MapperScan</code>注解标识mapper类所在目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.clb.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>配置了==@MapperScan==注解后，mapper类中无需添加==@Mapper==注解</p></blockquote><hr><h2 id="4-核心功能"><a href="#4-核心功能" class="headerlink" title="==4.核心功能=="></a><strong>==4.核心功能==</strong></h2><h3 id="4-1-条件构造器"><a href="#4-1-条件构造器" class="headerlink" title="4.1 条件构造器"></a>4.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117068580-3abcd2bb-fbf8-4430-8f2a-dcf130f05f70.png#averageHue=%23faf4ef&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=312&amp;id=ua83b74d8&amp;originHeight=387&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74950&amp;status=done&amp;style=none&amp;taskId=uf547d320-6fa6-4d9c-a531-25573a538a5&amp;title=&amp;width=697.008381017849" alt="image.png"><br>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117775304-84915c47-d2d9-49f4-90fb-99270d9353c7.png#averageHue=%23f7faf2&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=407&amp;id=uf66fc47c&amp;originHeight=504&amp;originWidth=1212&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=60824&amp;status=done&amp;style=none&amp;taskId=u14c0b946-02c2-4631-bd09-d2459214134&amp;title=&amp;width=977.7478678167049" alt="image.png"></p><p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688117979051-e388959d-86ba-4aa9-9d57-cd9fd84fc00f.png#averageHue=%23f9f8f6&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=651&amp;id=ua30f8ba3&amp;originHeight=807&amp;originWidth=836&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=103972&amp;status=done&amp;style=none&amp;taskId=u4c610b14-da63-46ae-8a13-08672c8643e&amp;title=&amp;width=674.4201464478261" alt="image.png"><br>而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688118137162-ffcf1fe3-57cb-46ef-b069-9d576e9f0184.png#averageHue=%23e2c889&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=127&amp;id=ue7075211&amp;originHeight=158&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=23389&amp;status=done&amp;style=none&amp;taskId=ua0264d53-8522-4608-97e1-d30b91f878c&amp;title=&amp;width=662.3193064995996" alt="image.png"><br>而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688118200333-0c97025d-1bd9-4f3b-a486-7e6a1cf3604d.png#averageHue=%23e5ca91&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=126&amp;id=uad24f810&amp;originHeight=156&amp;originWidth=825&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=22371&amp;status=done&amp;style=none&amp;taskId=uacb8416a-d529-44e1-9a64-84c0ac60765&amp;title=&amp;width=665.54619715246" alt="image.png"></p><p>接下来，我们就来看看如何利用<code>Wrapper</code>实现复杂查询。</p><h4 id="4-1-1-QueryWrapper"><a href="#4-1-1-QueryWrapper" class="headerlink" title="4.1.1 QueryWrapper"></a>4.1.1 QueryWrapper</h4><p>修改、删除、查询都可以使用QueryWrapper构建查询条件</p><p><strong>查询：</strong>查询名字带有o，且存款大于等于1000的人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,username,info,balance </span><br><span class="line">from user</span><br><span class="line">where username like %o% and balance &gt;= 1000;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//构建查询条件</span></span><br><span class="line">    wrapper.select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-UpdateWrapper"><a href="#4-1-2-UpdateWrapper" class="headerlink" title="4.1.2 UpdateWrapper"></a>4.1.2 UpdateWrapper</h4><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。<br>例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对于的SQL应该是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line"><span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-LambdaQueryWrapper"><a href="#4-1-3-LambdaQueryWrapper" class="headerlink" title="4.1.3 LambdaQueryWrapper"></a>4.1.3 LambdaQueryWrapper</h4><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，可能会出现字符串写错的现象，因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,username,info,balance </span><br><span class="line">from user</span><br><span class="line">where username like %o% and balance &gt;= 1000;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//构建查询条件</span></span><br><span class="line">    <span class="comment">//由原来的字符串变成getter函数对象获取类属性</span></span><br><span class="line">    wrapper.select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">        .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    userMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4);</span><br></pre></td></tr></table></figure><h3 id="4-2-自定义SQL"><a href="#4-2-自定义SQL" class="headerlink" title="4.2 自定义SQL"></a>4.2 自定义SQL</h3><h4 id="4-2-1-基本使用"><a href="#4-2-1-基本使用" class="headerlink" title="4.2.1 基本使用"></a>4.2.1 基本使用</h4><p>在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688133292238-a0f07be7-b115-4970-95d0-2f36bf68cc19.png#averageHue=%23f8fbf6&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=362&amp;id=u502de218&amp;originHeight=449&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=98085&amp;status=done&amp;style=none&amp;taskId=u903bfb55-ce92-4788-af0e-33eeeabe260&amp;title=&amp;width=860.773081650515" alt="image.png"><br>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。<br>这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。</p><p>所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml或注解编写SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4)</span><br></pre></td></tr></table></figure><p><code>update user set balance = balance - 200</code>使用注解完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将wrapper作为ew，并使用ew.customSqlSegment取出条件是固定写法</span></span><br><span class="line"><span class="meta">@Update(&quot;update tb_user set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBalanceByWrapper</span><span class="params">(<span class="meta">@Param(&quot;amount&quot;)</span> <span class="type">int</span> amount, <span class="meta">@Param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p><code>where id in(1,2,4)</code> 使用自定义sql完成,将wrapper作为参数传入自定义的方法中<code>$&#123;ew.customSqlSegment&#125;</code> ==&gt;<code>where id in (1,2,4)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCustomSql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.in(User::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    userMapper.updateBalanceByWrapper(amount, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-多表联查"><a href="#4-2-2-多表联查" class="headerlink" title="4.2.2 多表联查"></a>4.2.2 多表联查</h4><p>理论上来将MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。<br>例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户<br>要是自己基于mybatis实现SQL，大概是这样的：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user u</span><br><span class="line">    INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">    WHERE u.id</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    AND a.city = #&#123;city&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。<br>查询条件这样来构建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在UserMapper中自定义方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==总结:where条件可以使用wrapper构建，然后作为参数传递==</p></blockquote><h3 id="4-3-Service接口"><a href="#4-3-Service接口" class="headerlink" title="4.3 Service接口"></a>4.3 Service接口</h3><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br>通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul><h4 id="4-3-1-CRUD"><a href="#4-3-1-CRUD" class="headerlink" title="4.3.1.CRUD"></a>4.3.1.CRUD</h4><p>我们先俩看下基本的CRUD接口。<br><strong>新增</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688175852334-462e40db-e880-4131-adaa-5fc14360ff73.png#averageHue=%23f9f8f5&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=235&amp;id=u06631bbd&amp;originHeight=291&amp;originWidth=890&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=35948&amp;status=done&amp;style=none&amp;taskId=u045be908-a24b-4312-b024-0a2376b2e00&amp;title=&amp;width=717.9831702614417" alt="image.png"></p><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><p><strong>删除：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176052341-b6c0528d-bb35-452d-9087-ea5ee2708bd4.png#averageHue=%23f9f7f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=330&amp;id=u1802c257&amp;originHeight=409&amp;originWidth=913&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=55434&amp;status=done&amp;style=none&amp;taskId=ubf745089-f151-433a-bf03-10a0e0907ce&amp;title=&amp;width=736.5377915153891" alt="image.png"></p><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><code>~~removeBatchByIds~~</code>：暂不支持</li></ul><p><strong>修改：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176292104-2d148912-019b-46c2-8537-54b9b1274abd.png#averageHue=%23faf6f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=358&amp;id=ub3a7a979&amp;originHeight=444&amp;originWidth=931&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61438&amp;status=done&amp;style=none&amp;taskId=u17eb7110-22a9-42b9-b021-bdef1484f11&amp;title=&amp;width=751.0587994532609" alt="image.png"></p><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><p><strong>Get：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176734766-5df895e7-950a-4050-aa14-996ba9f6efc7.png#averageHue=%23f9f3f1&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=232&amp;id=uc50ce3bb&amp;originHeight=287&amp;originWidth=897&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=35993&amp;status=done&amp;style=none&amp;taskId=u965dedf4-cadf-4370-be0b-1b4dfbae494&amp;title=&amp;width=723.6302289039475" alt="image.png"></p><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176798210-d60284da-3862-422b-9621-2eec6b77c7ee.png#averageHue=%23f9f5f2&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=303&amp;id=udd4bc117&amp;originHeight=375&amp;originWidth=919&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=48612&amp;status=done&amp;style=none&amp;taskId=uc743900e-ec3f-40c3-84b0-054169510ba&amp;title=&amp;width=741.3781274946797" alt="image.png"></p><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688176988135-5c605f58-87f5-42de-8613-ba3e7f7c36b4.png#averageHue=%23dbc789&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=108&amp;id=u366b7592&amp;originHeight=134&amp;originWidth=775&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=13537&amp;status=done&amp;style=none&amp;taskId=u18328f20-d548-4a65-b93f-be7bbc9ca96&amp;title=&amp;width=625.2100639917048" alt="image.png"></p><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>：<br>当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689651515691-7a4ff31d-e73e-443e-a088-62af40589fa5.png#averageHue=%23f4f4f1&amp;clientId=u82e37f7f-41b7-4&amp;from=paste&amp;height=111&amp;id=ue40936a2&amp;originHeight=124&amp;originWidth=529&amp;originalType=binary&amp;ratio=1.115625023841858&amp;rotation=0&amp;showTitle=false&amp;size=11331&amp;status=done&amp;style=none&amp;taskId=u07515801-2ee5-4a97-9377-685cbb7dfbf&amp;title=&amp;width=474.17365933429153" alt="image.png"></p><h4 id="4-3-2-基本用法"><a href="#4-3-2-基本用法" class="headerlink" title="4.3.2 基本用法"></a>4.3.2 基本用法</h4><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了，如下图(<strong>绿色为接口，蓝色为实现类</strong>)</p><p><img src="https://gitee.com/clibin/image-bed/raw/master/202309131733746.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义接口继承IService接口，需要指定泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义实现类继承ServiceImpl，实现自定义接口，需要指定对应的Mapper和泛型，对应的Mapper需要继承BaseMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//user.setId(5L);</span></span><br><span class="line">    user.setUsername(<span class="string">&quot;kun_&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(UserInfo.of(<span class="number">24</span>, <span class="string">&quot;英语老师&quot;</span>, <span class="string">&quot;female&quot;</span>));</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    user.setStatus(UserStatus.NORMAL);</span><br><span class="line">    userService.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userService.list(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().select(User::getUsername, User::getBalance).le(User::getBalance, <span class="number">999</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-批量新增"><a href="#4-3-3-批量新增" class="headerlink" title="4.3.3 批量新增"></a>4.3.3 批量新增</h4><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。<br>首先我们测试逐条插入数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">buildUser</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;&quot;</span> + (<span class="number">18688190000L</span> + i));</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(user.getCreateTime());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688182456300-08cbaea5-afd5-44e2-9e55-868595671548.png#averageHue=%23f6f8f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=244&amp;id=u1934bf0f&amp;originHeight=303&amp;originWidth=1525&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107948&amp;status=done&amp;style=none&amp;taskId=ua11c6515-de40-48dc-8d87-8a2dd7f255b&amp;title=&amp;width=1230.2520614030323" alt="image.png"><br>可以看到速度非常慢。</p><p>然后再试试MybatisPlus的批处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备10万条数据</span></span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        list.add(buildUser(i));</span><br><span class="line">        <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行最终耗时如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688182059553-db1fa9e1-3b14-47a3-be33-f7f0e7805cea.png#averageHue=%23f6f8f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=246&amp;id=udd2b6e84&amp;originHeight=305&amp;originWidth=1528&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107606&amp;status=done&amp;style=none&amp;taskId=ue141c82d-fd21-4e29-a2b5-284f261341f&amp;title=&amp;width=1232.6722293926775" alt="image.png"><br>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p><p>不过，我们简单查看一下<code>MybatisPlus</code>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Preparing: INSERT INTO <span class="title function_">user</span> <span class="params">( username, password, phone, info, balance, create_time, update_time )</span> VALUES ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, <span class="string">&quot;&quot;</span>, <span class="number">2000</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span>, <span class="number">2023</span>-<span class="number">07</span>-<span class="number">01</span></span><br></pre></td></tr></table></figure><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><p>该怎么做呢？</p><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：<br><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">cj-conn-prop_rewriteBatchedStatements</a><br>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p><p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688183132724-a20e7a12-396d-49b6-943b-3c26357a9b92.png#averageHue=%23f6f9f4&amp;clientId=u9097aa82-6411-4&amp;from=paste&amp;height=273&amp;id=ue336017d&amp;originHeight=338&amp;originWidth=1450&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=112189&amp;status=done&amp;style=none&amp;taskId=ub2301dcf-ab09-4346-8378-f324485339d&amp;title=&amp;width=1169.7478616618994" alt="image.png"></p><p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688194832130-aecf5c68-30f2-4925-862a-fdb15f4f4614.png#averageHue=%23f5f8f4&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=515&amp;id=u39f69fec&amp;originHeight=639&amp;originWidth=1509&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=157560&amp;status=done&amp;style=none&amp;taskId=uc973871c-05ff-42b0-9e86-297efa8cf5d&amp;title=&amp;width=1217.3444987915905" alt="image.png"><br>最终，SQL被重写了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688194899752-20700857-a5d3-4d14-bff0-6351fbf68a5b.png#averageHue=%23f4f4f3&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=662&amp;id=ub69cdd4a&amp;originHeight=820&amp;originWidth=1438&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=81949&amp;status=done&amp;style=none&amp;taskId=u8db236a7-b1a5-4f0d-b1e9-6c8974cec1e&amp;title=&amp;width=1160.0671897033183" alt="image.png"></p><blockquote><p>总结:</p><ol><li><p>插入大量数据的时候，使用<code>saveBatch</code>批量插入一定数量的数据而不是在循环里面一条一条插入数据<code>save</code></p></li><li><p>mysql配置文件中开启批处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp？rewriteBatchedStatements=true</span> <span class="comment">#rewriteBatchedStatements=true 开启批处理</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-3-4-Lambda"><a href="#4-3-4-Lambda" class="headerlink" title="4.3.4 Lambda"></a>4.3.4 Lambda</h4><p>Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p><p>基于Lambda查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询1个</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">rose</span> <span class="operator">=</span> userService.lambdaQuery()</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">            .one(); <span class="comment">// .one()查询1个</span></span><br><span class="line">    System.out.println(<span class="string">&quot;rose = &quot;</span> + rose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.查询多个</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .list(); <span class="comment">// .list()查询集合</span></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.count统计</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userService.lambdaQuery()</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .count(); <span class="comment">// .count()则计数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现lambdaQuery方法中除了可以构建条件，而且根据链式编程的最后一个方法来判断最终的返回结果，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p>lambdaQuery还支持动态条件查询。比如下面这个需求：</p><blockquote><p>定义一个方法，接收参数为username、status、minBalance、maxBalance，参数可以为空。</p><ul><li>如果username参数不为空，则采用模糊查询;</li><li>如果status参数不为空，则采用精确匹配；</li><li>如果minBalance参数不为空，则余额必须大于minBalance</li><li>如果maxBalance参数不为空，则余额必须小于maxBalance</li></ul></blockquote><p>这个需求就是典型的动态查询，在业务开发中经常碰到，实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryUser</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = queryUser(<span class="string">&quot;o&quot;</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUser</span><span class="params">(String username, Integer status, Integer minBalance, Integer maxBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span> , User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Lambda更新：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, <span class="number">800</span>) <span class="comment">// set balance = 800</span></span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Jack&quot;</span>) <span class="comment">// where username = &quot;Jack&quot;</span></span><br><span class="line">            .update(); <span class="comment">// 执行Update</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lambdaUpdate()</code>方法后基于链式编程，可以添加<code>set</code>条件和<code>where</code>条件。但最后一定要跟上<code>update()</code>，否则语句不会执行。</p><p>lambdaUpdate()同样支持动态条件，例如下面的需求：</p><blockquote><p>基于IService中的lambdaUpdate()方法实现一个更新方法，满足下列需求：</p><ul><li>参数为balance、id、username</li><li>id或username至少一个不为空，根据id或username精确匹配用户</li><li>将匹配到的用户余额修改为balance</li><li>如果balance为0，则将用户status修改为冻结状态</li></ul></blockquote><p>实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    updateBalance(<span class="number">0L</span>, <span class="number">1L</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBalance</span><span class="params">(Long balance, Long id, String username)</span>&#123;</span><br><span class="line">    userService.lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, balance)</span><br><span class="line">            .set(balance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>)</span><br><span class="line">            .eq(id != <span class="literal">null</span>, User::getId, id)</span><br><span class="line">            .eq(username != <span class="literal">null</span>, User::getId, username)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-静态工具"><a href="#4-4-静态工具" class="headerlink" title="4.4.静态工具"></a>4.4.静态工具</h3><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688195216843-3b5850bb-92f9-4eb8-a41d-db93d9606e5d.png#averageHue=%23fbf9f8&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=725&amp;id=u51b23a1d&amp;originHeight=899&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107357&amp;status=done&amp;style=none&amp;taskId=u2b03fdcc-1631-4557-a076-94311862860&amp;title=&amp;width=829.3108977851259" alt="image.png"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Db.getById(<span class="number">1L</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 利用Db实现复杂条件查询</span></span><br><span class="line">    List&lt;User&gt; list = Db.lambdaQuery(User.class)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">            .list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-拓展功能"><a href="#5-拓展功能" class="headerlink" title="5.拓展功能"></a>5.拓展功能</h2><h3 id="5-1-代码生成插件"><a href="#5-1-代码生成插件" class="headerlink" title="5.1 代码生成插件"></a>5.1 代码生成插件</h3><ol><li>安装插件</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688091751297-6918cbf6-d2c2-4ae1-a88e-05b53deeb007.png#averageHue=%23f6f5f5&amp;clientId=uea9a4aab-c071-4&amp;from=paste&amp;height=618&amp;id=u6048bc70&amp;originHeight=766&amp;originWidth=1507&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107031&amp;status=done&amp;style=none&amp;taskId=u820e9b5e-098b-47f6-8ff5-fd30fe3b308&amp;title=&amp;width=1215.7310534651604" alt="image.png"></p><ol><li>配置数据库</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196733527-e4bc1921-cc23-4f8c-92f9-b917ec261523.png#averageHue=%23d9ceb7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=190&amp;id=u1be4369c&amp;originHeight=236&amp;originWidth=1221&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=37503&amp;status=done&amp;style=none&amp;taskId=u6232584f-51f8-4184-8a55-86890ee8ade&amp;title=&amp;width=985.0083717856409" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196793381-60acee0a-500e-4b4d-8b3b-aa4cd3af80c8.png#averageHue=%23f4f4f4&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=317&amp;id=u4cc24dc2&amp;originHeight=393&amp;originWidth=629&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=17584&amp;status=done&amp;style=none&amp;taskId=ud0ec4100-04a0-443a-bc58-9a65002e9fe&amp;title=&amp;width=507.4285551622998" alt="image.png"></p><ol><li><p>生成代码</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688196861061-152ee240-f56d-47a3-9c74-7fc67a82dd17.png#averageHue=%23d7cbb2&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=153&amp;id=u30692977&amp;originHeight=190&amp;originWidth=1109&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=31203&amp;status=done&amp;style=none&amp;taskId=u8299bd93-3309-486f-bd92-3804ced967f&amp;title=&amp;width=894.6554335055492" alt="image.png"></p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688197265415-9a6942d2-b53f-4788-aa90-d2308690c8c6.png#averageHue=%23f3e9e8&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=489&amp;id=u319836cf&amp;originHeight=606&amp;originWidth=1376&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=129466&amp;status=done&amp;style=none&amp;taskId=u0e1d05ee-af06-445f-9ad7-8769e084e36&amp;title=&amp;width=1110.050384583982" alt="image.png"></p><h3 id="5-2-逻辑删除"><a href="#5-2-逻辑删除" class="headerlink" title="5.2 逻辑删除"></a>5.2 逻辑删除</h3><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。<br>:::warning<br><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。<br>:::</p><p>例如，我们给<code>address</code>表添加一个逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address</span><br><span class="line"><span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后给<code>Address</code>实体添加<code>deleted</code>字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688202948723-552f1db1-84ad-4b78-99ee-28ac6f2f5159.png#averageHue=%23f6f8f3&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=389&amp;id=ua4217141&amp;originHeight=482&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=53297&amp;status=done&amp;style=none&amp;taskId=u2aa3f980-e287-47b8-8b36-3ccbc249d3a&amp;title=&amp;width=690.5545997121282" alt="image.png"></p><p>接下来，我们要在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><p>测试：<br>首先，我们执行一个删除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688203124731-99a02bc4-df99-4bcf-a38d-4ebf0e82bf6b.png#averageHue=%23f9fcf7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=312&amp;id=uc2faa0ed&amp;originHeight=387&amp;originWidth=1347&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=141086&amp;status=done&amp;style=none&amp;taskId=u07bf156e-f27f-452a-ad3d-64f60e95502&amp;title=&amp;width=1086.6554273507438" alt="image.png"></p><p>查询一下试试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688203269018-391c8134-3442-43a8-893f-08f562155ae7.png#averageHue=%23f9fcf7&amp;clientId=ucb5715c2-9b63-4&amp;from=paste&amp;height=452&amp;id=uedd32412&amp;originHeight=560&amp;originWidth=1328&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=233822&amp;status=done&amp;style=none&amp;taskId=ub7380c63-d002-4cad-a704-6bf18ff3948&amp;title=&amp;width=1071.3276967496568" alt="image.png"></p><p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p><p>:::warning<br><strong>注意</strong>：<br>逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。<br>:::</p><h3 id="5-3-通用枚举"><a href="#5-3-通用枚举" class="headerlink" title="5.3 通用枚举"></a>5.3 通用枚举</h3><p>User类中有一个用户状态字段：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688205450700-35d2bce8-ec2d-42f2-8977-bd7ebf101afd.png#averageHue=%23f5f7f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=349&amp;id=u29e826cf&amp;originHeight=432&amp;originWidth=688&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=47157&amp;status=done&amp;style=none&amp;taskId=u2b1c794b-d20f-478d-aeff-87d6913e1f2&amp;title=&amp;width=555.025192291991" alt="image.png"><br>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p><p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h4 id="5-3-1-定义枚举"><a href="#5-3-1-定义枚举" class="headerlink" title="5.3.1.定义枚举"></a>5.3.1.定义枚举</h4><p>我们定义一个用户状态的枚举：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688206435536-1e0ebd0f-4185-4e4b-8dc8-8b2dab235f44.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=403&amp;id=uf7e016c3&amp;originHeight=499&amp;originWidth=915&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=53038&amp;status=done&amp;style=none&amp;taskId=u5e55ee20-4f76-4516-b0f2-c1a81d103fc&amp;title=&amp;width=738.1512368418192" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把<code>User</code>类中的<code>status</code>字段改为<code>UserStatus</code> 类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688207388430-424b3be8-4c08-4c31-aa73-7b41e271a760.png#averageHue=%23f6f7f2&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=340&amp;id=ua014304a&amp;originHeight=422&amp;originWidth=714&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=47282&amp;status=done&amp;style=none&amp;taskId=u2e238813-09bf-4ab7-8ddf-8c8f581014c&amp;title=&amp;width=575.9999815355836" alt="image.png"></p><p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。<br><code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688206653554-4bc9d7a3-3c39-4981-a8ba-6f06ba7df734.png#averageHue=%23f8fbf6&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=418&amp;id=ua72da7b8&amp;originHeight=518&amp;originWidth=635&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=67892&amp;status=done&amp;style=none&amp;taskId=ua1ac546f-70cf-4525-a941-afce46f09a2&amp;title=&amp;width=512.2688911415904" alt="image.png"></p><h4 id="5-3-2-配置枚举处理器"><a href="#5-3-2-配置枚举处理器" class="headerlink" title="5.3.2.配置枚举处理器"></a>5.3.2.配置枚举处理器</h4><p>在application.yaml文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3.测试"></a>5.3.3.测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = userService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688207514989-da3d683d-641b-4a05-8330-ec1818604dd4.png#averageHue=%23f7faf3&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=272&amp;id=u5c65f589&amp;originHeight=337&amp;originWidth=758&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=70020&amp;status=done&amp;style=none&amp;taskId=ub88fd551-ea20-4385-9696-bc4800cc4d4&amp;title=&amp;width=611.4957787170481" alt="image.png"></p><h3 id="5-4-字段类型处理器"><a href="#5-4-字段类型处理器" class="headerlink" title="5.4 字段类型处理器"></a>5.4 字段类型处理器</h3><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688212092835-57dab221-e046-48f4-907a-d3bf18fc2a30.png#averageHue=%23f7f6f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=245&amp;id=u3dcab959&amp;originHeight=304&amp;originWidth=761&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=31811&amp;status=done&amp;style=none&amp;taskId=ubba2f760-5128-4d52-9412-f54fceaf94a&amp;title=&amp;width=613.9159467066934" alt="image.png"><br>格式像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而目前<code>User</code>实体类中却是<code>String</code>类型：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688212175474-81e91aec-2ef3-4305-9dc6-28d20e139688.png#averageHue=%23f5f8f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=310&amp;id=u65d78d1d&amp;originHeight=384&amp;originWidth=814&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=46824&amp;status=done&amp;style=none&amp;taskId=u674ba30b-a2fd-4c65-9c1f-acc92e124de&amp;title=&amp;width=656.6722478570939" alt="image.png"></p><p>这样以来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。<br>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库是手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><p>接下来，我们就来看看这个处理器该如何使用。</p><h4 id="5-4-1-定义实体"><a href="#5-4-1-定义实体" class="headerlink" title="5.4.1 定义实体"></a>5.4.1 定义实体</h4><p>首先，我们定义一个单独实体类来与info字段的属性匹配：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215509372-226dae45-89f8-46e5-9cf2-a2d94dafebda.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=353&amp;id=u6e9cbd35&amp;originHeight=437&amp;originWidth=860&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=44479&amp;status=done&amp;style=none&amp;taskId=u3ef96d28-bf45-4adb-9583-cf6c2ce9cf8&amp;title=&amp;width=693.7814903649886" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-使用类型处理器"><a href="#5-4-2-使用类型处理器" class="headerlink" title="5.4.2 使用类型处理器"></a>5.4.2 使用类型处理器</h4><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215729313-c3987a13-e3fe-40f6-8028-e837fdfbee63.png#averageHue=%23f6f8f4&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=309&amp;id=u6e6612c3&amp;originHeight=383&amp;originWidth=978&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=49918&amp;status=done&amp;style=none&amp;taskId=u6a82025a-637a-4a02-bd01-036a53384b2&amp;title=&amp;width=788.9747646243708" alt="image.png"></p><p>测试可以发现，所有数据都正确封装到UserInfo当中了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688215838909-45e8286d-85f4-4521-bede-9d3c8e8be109.png#averageHue=%23f9fbf6&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=278&amp;id=u822a8e35&amp;originHeight=345&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=92222&amp;status=done&amp;style=none&amp;taskId=u80ecd7f1-8bf6-4609-8484-22a05c2093f&amp;title=&amp;width=834.1512337644166" alt="image.png"></p><h3 id="5-5配置加密"><a href="#5-5配置加密" class="headerlink" title="5.5配置加密"></a>5.5配置加密</h3><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。</p><p>我们以数据库的用户名和密码为例。</p><h4 id="5-5-1-生成秘钥"><a href="#5-5-1-生成秘钥" class="headerlink" title="5.5.1.生成秘钥"></a>5.5.1.生成秘钥</h4><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MpDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成 16 位随机 AES 密钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">randomKey</span> <span class="operator">=</span> AES.generateRandomKey();</span><br><span class="line">        System.out.println(<span class="string">&quot;randomKey = &quot;</span> + randomKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;root&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;MySQL123&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">randomKey = 6234633<span class="type">a66fb399f</span></span><br><span class="line"><span class="variable">username</span> <span class="operator">=</span> px2bAbnUfiY8K/IgsKvscg==</span><br><span class="line">password = FGvCSEaOuga3ulDAsxw68Q==</span><br></pre></td></tr></table></figure><h4 id="5-5-2-修改配置"><a href="#5-5-2-修改配置" class="headerlink" title="5.5.2.修改配置"></a>5.5.2.修改配置</h4><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">mpw:QWWVnk1Oal3258x5rVhaeQ==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mpw:EUFmeH3cNAzdRGdOQcabWg==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br></pre></td></tr></table></figure><h4 id="5-5-3-测试"><a href="#5-5-3-测试" class="headerlink" title="5.5.3.测试"></a>5.5.3.测试</h4><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">--mpw.key=6234633a66fb399f</span></span><br></pre></td></tr></table></figure><p>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688218131368-7bba8307-998f-4709-86d1-b5f83d0b363d.png#averageHue=%23f5f7f3&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=392&amp;id=u0b3b23da&amp;originHeight=486&amp;originWidth=1089&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=87247&amp;status=done&amp;style=none&amp;taskId=ue867a34c-18ac-488a-b0c9-a77bdf4d99a&amp;title=&amp;width=878.5209802412472" alt="image.png"></p><p>然后随意运行一个单元测试，可以发现数据库查询正常。</p><h2 id="6-插件功能"><a href="#6-插件功能" class="headerlink" title="6.插件功能"></a>6.插件功能</h2><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><p>:::warning<br><strong>注意：</strong><br>使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除<br>:::</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="6-1-分页插件"><a href="#6-1-分页插件" class="headerlink" title="6.1.分页插件"></a>6.1.分页插件</h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。<br>所以，我们必须配置分页插件。</p><h3 id="6-1-1-配置分页插件"><a href="#6-1-1-配置分页插件" class="headerlink" title="6.1.1.配置分页插件"></a>6.1.1.配置分页插件</h3><p>在项目中新建一个配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688220120678-5d7b8c50-05f8-48f0-b32b-21a4e34dc56f.png#averageHue=%23f9fbf8&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=327&amp;id=u5dedcfcd&amp;originHeight=405&amp;originWidth=896&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=42888&amp;status=done&amp;style=none&amp;taskId=ufe639d17-598b-40d7-b932-3133320d017&amp;title=&amp;width=722.8235062407323" alt="image.png"><br>其代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-分页API"><a href="#6-1-2-分页API" class="headerlink" title="6.1.2.分页API"></a>6.1.2.分页API</h3><p>编写一个分页查询的测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的SQL如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688220648583-06cf029a-4d8e-4002-8b07-dc4db3787fa4.png#averageHue=%23f9fcf7&amp;clientId=ucdd19af3-b6b9-4&amp;from=paste&amp;height=649&amp;id=u381c4f60&amp;originHeight=805&amp;originWidth=1336&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=300593&amp;status=done&amp;style=none&amp;taskId=u05c9d87e-599a-4d44-8b0c-62900316533&amp;title=&amp;width=1077.7814780553776" alt="image.png"></p><p>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure><h2 id="6-2-通用分页实体"><a href="#6-2-通用分页实体" class="headerlink" title="6.2.通用分页实体"></a>6.2.通用分页实体</h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><div class="table-container"><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>/users/page</td></tr><tr><td>请求参数</td><td>```json</td></tr><tr><td>{</td><td></td></tr><tr><td>“pageNo”: 1,</td><td></td></tr><tr><td>“pageSize”: 5,</td><td></td></tr><tr><td>“sortBy”: “balance”,</td><td></td></tr><tr><td>“isAsc”: false</td><td></td></tr><tr><td>}</td></tr></tbody></table></div><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">100006</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="number">50003</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1685100878975279298</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_9****&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;英文老师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">2000</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1685100878975279299</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_9****&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;英文老师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">2000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> |<br>| 特殊说明 | •如果排序字段为空，默认按照更新时间排序<br>•排序字段不为空，则按照排序字段排序 |</p><p>这里需要定义3个实体：</p><ul><li><code>PageQuery</code>：分页查询条件的实体，包含分页、排序参数</li><li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li><li><code>UserVO</code>：用户页面视图实体</li></ul><p>接下来我们就按照WEB开发的过程来实现这个接口。<br>首先，我们在项目中引入<code>spring-boot-starter-web</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hutool 工具包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，按<code>alt+8</code>打开<code>service</code>控制台，然后添加一个<code>SpringBoot</code>启动项：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286132717-ae9c6f4d-61a4-4b67-8da1-f4a8a7087ad7.png#averageHue=%23eff2ee&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=361&amp;id=uc2971250&amp;originHeight=448&amp;originWidth=1127&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61466&amp;status=done&amp;style=none&amp;taskId=u5c9cacfa-5ca3-4210-8749-71b5221414d&amp;title=&amp;width=909.1764414434211" alt="image.png"><br>弹窗中选择<code>Spring Boot</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286160462-818bf344-ed58-4ad5-b8aa-68948ce07025.png#averageHue=%23f5f4f2&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=465&amp;id=u2345aaa0&amp;originHeight=576&amp;originWidth=314&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=37539&amp;status=done&amp;style=none&amp;taskId=u18919e97-fda7-4d6b-88cf-71ffc02b73f&amp;title=&amp;width=253.31091624954234" alt="image.png"><br>弹窗中填写信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688286326883-b48cd164-9f97-413f-9b8d-b88cb6fff6f4.png#averageHue=%23f3f1f1&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=608&amp;id=u7ac5c1e6&amp;originHeight=754&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=63187&amp;status=done&amp;style=none&amp;taskId=u8236bb84-f4d7-4993-94d6-676e7bc2812&amp;title=&amp;width=1129.4117285011444" alt="image.png"><br>其中不要忘了配置我们之前添加的数据加密的秘钥。</p><h3 id="6-2-1-实体"><a href="#6-2-1-实体" class="headerlink" title="6.2.1.实体"></a>6.2.1.实体</h3><p>首先是请求参数的<code>PageQuery</code>实体：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626203583-31dc37fe-6851-4aad-9438-8e1ebef5ce46.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=428&amp;id=u6de6995d&amp;originHeight=530&amp;originWidth=842&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=52422&amp;status=done&amp;style=none&amp;taskId=u0d14f487-0e76-4433-aa87-a89efcba08e&amp;title=&amp;width=679.2604824271168" alt="image.png"><br><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p><ul><li><code>pageNo</code>：页码</li><li><code>pageSize</code>：每页数据条数</li><li><code>sortBy</code>：排序字段</li><li><code>isAsc</code>：是否升序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义一个<code>UserVO</code>实体：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626250731-71aa58a9-80af-4191-91e7-e22c21ada79a.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=355&amp;id=u6a9535f1&amp;originHeight=440&amp;originWidth=834&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=42155&amp;status=done&amp;style=none&amp;taskId=ue520cb52-d625-447c-9e92-e2cd2ef7153&amp;title=&amp;width=672.8067011213959" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.enums.UserStatus;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用状态（1正常 2冻结）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，则是分页实体PageDTO:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626340460-6e86f884-5110-47b9-a6ca-429d3bcb9e47.png#averageHue=%23f9fbf8&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=403&amp;id=u4b113cac&amp;originHeight=499&amp;originWidth=900&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=48491&amp;status=done&amp;style=none&amp;taskId=ubd543d13-2a93-47cb-afc3-2884221e2f7&amp;title=&amp;width=726.0503968935927" alt="image.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line">    <span class="keyword">private</span> Integer pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-开发接口"><a href="#6-2-2-开发接口" class="headerlink" title="6.2.2.开发接口"></a>6.2.2.开发接口</h3><p>我们定义一个<code>UserController</code>，在<code>controller</code>中我们定义分页查询用户的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.dto.PageDTO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.query.PageQuery;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryUserByPage(query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在<code>UserService</code>中创建<code>queryUserByPage</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span>;</span><br></pre></td></tr></table></figure><p>接下来，在UserServiceImpl中实现该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    <span class="comment">// 1.1.分页条件</span></span><br><span class="line">    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">    <span class="comment">// 1.2.排序条件</span></span><br><span class="line">    <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.数据非空校验</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.有数据，转换</span></span><br><span class="line">    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">    <span class="comment">// 5.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为了让UserStatus枚举可以展示为文字描述，再给UserStatus中的desc字段添加<code>@JsonValue</code>注解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626889628-2c81911b-a714-410e-9cdf-76aa27946746.png#averageHue=%23f9fbf6&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=443&amp;id=ud16fa160&amp;originHeight=549&amp;originWidth=751&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74054&amp;status=done&amp;style=none&amp;taskId=u4d9fbbd2-ddee-48f9-9d79-30479deee8d&amp;title=&amp;width=605.8487200745424" alt="image.png"><br>启动项目，在页面查看：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690626977575-46df0c79-8d99-4965-a1fa-7ef4379f81ba.png#averageHue=%23f8f8fe&amp;clientId=uacc03b97-2f4b-4&amp;from=paste&amp;height=603&amp;id=uc72ff4b0&amp;originHeight=748&amp;originWidth=749&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=77622&amp;status=done&amp;style=none&amp;taskId=u0c90cc4d-4b96-48bb-89b9-fe1fe18fa6f&amp;title=&amp;width=604.2352747481121" alt="image.png"></p><h3 id="6-2-3-改造PageQuery实体"><a href="#6-2-3-改造PageQuery实体" class="headerlink" title="6.2.3.改造PageQuery实体"></a>6.2.3.改造PageQuery实体</h3><p>在刚才的代码中，从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦的。<br>我们完全可以在<code>PageQuery</code>这个实体中定义一个工具方法，简化开发。<br>像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们在开发也时就可以省去对从<code>PageQuery</code>到<code>Page</code>的的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建条件</span></span><br><span class="line">Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br></pre></td></tr></table></figure><h3 id="6-2-4-改造PageDTO实体"><a href="#6-2-4-改造PageDTO实体" class="headerlink" title="6.2.4.改造PageDTO实体"></a>6.2.4.改造PageDTO实体</h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。</p><p>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终，业务层的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终查询的结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1688291665223-e96361ac-d315-4d39-b54a-9c54083665f2.png#averageHue=%23f8f9fe&amp;clientId=uba0f15c0-624d-4&amp;from=paste&amp;height=614&amp;id=u88be7c7b&amp;originHeight=761&amp;originWidth=891&amp;originalType=binary&amp;ratio=1.2395833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74030&amp;status=done&amp;style=none&amp;taskId=u44f43f7a-6fb4-4c98-92bf-32cd49ec211&amp;title=&amp;width=718.7898929246568" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2023/08/31/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/08/31/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027214128.png" alt="image-20221027214128453"></p><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径</li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符<em>， 比如：`</em>`test表示搜索任意以test结尾的文件</li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="反引号"><a href="#反引号" class="headerlink" title="`反引号"></a>`反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-f，持续跟踪文件修改</li></ul><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png" alt="image-20221027215841573"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png" alt="image-20221027215846581"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png" alt="image-20221027215849668"></p><h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png" alt="image-20221027215858967"></p><h2 id="命令的选项"><a href="#命令的选项" class="headerlink" title="命令的选项"></a>命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p><p>课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220005.png" alt="image-20221027220005610"></p><h3 id="查看命令的详细手册"><a href="#查看命令的详细手册" class="headerlink" title="查看命令的详细手册"></a>查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220010.png" alt="image-20221027220009949"></p><h1 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00..99)</li><li>%m   月份 (01..12)</li><li>%d   日 (01..31)</li><li>%H   小时 (00..23)</li><li>%M   分钟 (00..59)</li><li>%S   秒 (00..60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220514.png" alt="image-20221027220514640"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220525.png" alt="image-20221027220525625"></p></li><li><p>-d选项日期计算</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220429.png" alt="image-20221027220429831"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220449.png" alt="image-20221027220449312"></p></li></ul></li></ul><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>修改时区为中国时区</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220554.png" alt="image-20221027220554654"></p><h2 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h2><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure></li></ol><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221303.png" alt="image-20221027221303037"></p><h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221241.png" alt="image-20221027221241123"></p><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221129.png" alt="image-20221027221129782"></p><h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221149.png" alt="image-20221027221148964"></p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221201.png" alt="image-20221027221201079"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221210.png" alt="image-20221027221210518"></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221340.png" alt="image-20221027221340729"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221354.png" alt="image-20221027221354137"></p><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>查看磁盘占用</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221413.png" alt="image-20221027221413787"></p><h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><p>查看CPU、磁盘的相关信息</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221440.png" alt="image-20221027221439990"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221514.png" alt="image-20221027221514237"></p><h2 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h2><p>查看网络统计</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221545.png" alt="image-20221027221545822"></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>临时设置：export 变量名=变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221906.png" alt="image-20221027221906247"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221939.png" alt="image-20221027221939899"></p><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222021.png" alt="image-20221027222021619"></p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222035.png" alt="image-20221027222035337"></p><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222157.png" alt="image-20221027222157276"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222326.png" alt="image-20221027222326192"></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222354.png" alt="image-20221027222354498"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222407.png" alt="image-20221027222407618"></p><h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222446.png" alt="image-20221027222446514"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222512.png" alt="image-20221027222512274"></p></li></ul><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2023/07/28/mysql/"/>
      <url>/2023/07/28/mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="执行编写顺序"><a href="#执行编写顺序" class="headerlink" title="执行编写顺序"></a>执行编写顺序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语句编写和执行顺序</span></span><br><span class="line"><span class="keyword">select</span>    <span class="comment">-- 4</span></span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">from</span>    <span class="comment">-- 1</span></span><br><span class="line">    表名列表</span><br><span class="line"><span class="keyword">where</span>    <span class="comment">-- 2</span></span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="comment">--3</span></span><br><span class="line">    分组字段列表</span><br><span class="line"><span class="keyword">having</span>     </span><br><span class="line">    分组后条件列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="comment">--5</span></span><br><span class="line">    排序字段列表</span><br><span class="line">limit     <span class="comment">--6</span></span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure><h1 id="一、数据定义语言DDL"><a href="#一、数据定义语言DDL" class="headerlink" title="一、数据定义语言DDL"></a>一、数据定义语言DDL</h1><h2 id="1、数据库操作"><a href="#1、数据库操作" class="headerlink" title="1、数据库操作"></a>1、数据库操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># DDL<span class="operator">-</span>数据库操作</span><br><span class="line"><span class="keyword">show</span> databases;                          #显示所有数据库</span><br><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名;    #创建数据库</span><br><span class="line">use 数据库名 ;                              #使用数据库</span><br><span class="line"><span class="keyword">select</span> database();                          #显示当前在哪个数据库下</span><br><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名;            #删库跑路</span><br></pre></td></tr></table></figure><h2 id="2、表操作"><a href="#2、表操作" class="headerlink" title="2、表操作"></a>2、表操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- DDL-表操作</span></span><br><span class="line"><span class="keyword">show</span> tables;# 显示所有表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段 字段类型，字段 字段类型……) # 创建表</span><br><span class="line"><span class="keyword">desc</span> 表名 #查看表中所有字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>(添加字段)<span class="operator">/</span>modify(修改字段类型)<span class="operator">/</span>change(修改字段名及类型)<span class="operator">/</span><span class="keyword">drop</span>(删除字段)<span class="operator">/</span>rename <span class="keyword">to</span>(修改表名);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;# 删除表</span><br></pre></td></tr></table></figure><h1 id="二、-DML（增删改）"><a href="#二、-DML（增删改）" class="headerlink" title="二、 DML（增删改）"></a>二、 DML（增删改）</h1><h2 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert update delete"></a>insert update delete</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 插入一条语句</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">123</span>, <span class="string">&#x27;cxk&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">456</span>, <span class="string">&#x27;ikun&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 插入多条语句</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">values</span> (<span class="number">456</span>, <span class="string">&#x27;ikun&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">456</span>, <span class="string">&#x27;ikun&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">456</span>, <span class="string">&#x27;ikun&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">456</span>, <span class="string">&#x27;ikun&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查看表</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"># 修改 把name为ikun的name全部改为小黑子</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小黑子&#x27;</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;ikun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 把name为cxk的 name改为鸡哥，性别改为女</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">set</span> name  <span class="operator">=</span> <span class="string">&#x27;鸡哥&#x27;</span>,</span><br><span class="line">gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;cxk&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 把所有人的年龄改为<span class="number">69</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">set</span> age<span class="operator">=</span><span class="number">69</span>;</span><br><span class="line"></span><br><span class="line"># 删除 name为小黑子的人</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;小黑子&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 删除所有人</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h1 id="三、DQL（查）"><a href="#三、DQL（查）" class="headerlink" title="三、DQL（查）"></a>三、DQL（查）</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表并插入数据--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> employee;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp</span><br><span class="line">(</span><br><span class="line">id          <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">workno      <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">name        <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">gender      <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">age         tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">idcard      <span class="type">char</span>(<span class="number">18</span>) comment <span class="string">&#x27;身份证号&#x27;</span>,</span><br><span class="line">workaddress <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;工作地址&#x27;</span>,</span><br><span class="line">entrydate   <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据--------------------------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;柳岩&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;123456789012345678&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;00002&#x27;</span>, <span class="string">&#x27;张无忌&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;123456789012345670&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2005-09-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;00003&#x27;</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;123456789712345670&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;2005-08-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;00004&#x27;</span>, <span class="string">&#x27;赵敏&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;123456757123845670&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2009-12-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;00005&#x27;</span>, <span class="string">&#x27;小昭&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;123456769012345678&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;2007-07-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;00006&#x27;</span>, <span class="string">&#x27;杨逍&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;12345678931234567X&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2006-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;00007&#x27;</span>, <span class="string">&#x27;范瑶&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">40</span>, <span class="string">&#x27;123456789212345670&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2005-05-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;00008&#x27;</span>, <span class="string">&#x27;黛绮丝&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;123456157123645670&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>, <span class="string">&#x27;2015-05-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;00009&#x27;</span>, <span class="string">&#x27;范凉凉&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">45</span>, <span class="string">&#x27;123156789012345678&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2010-04-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;00010&#x27;</span>, <span class="string">&#x27;陈友谅&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">53</span>, <span class="string">&#x27;123456789012345670&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;2011-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;00011&#x27;</span>, <span class="string">&#x27;张士诚&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">55</span>, <span class="string">&#x27;123567897123465670&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;2015-05-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;00012&#x27;</span>, <span class="string">&#x27;常遇春&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;123446757152345670&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2004-02-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">13</span>, <span class="string">&#x27;00013&#x27;</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">88</span>, <span class="string">&#x27;123656789012345678&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;2020-11-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">14</span>, <span class="string">&#x27;00014&#x27;</span>, <span class="string">&#x27;灭绝&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">65</span>, <span class="string">&#x27;123456719012345670&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>, <span class="string">&#x27;2019-05-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">&#x27;00015&#x27;</span>, <span class="string">&#x27;胡青牛&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">70</span>, <span class="string">&#x27;12345674971234567X&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>, <span class="string">&#x27;2018-04-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="string">&#x27;00016&#x27;</span>, <span class="string">&#x27;周芷若&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">18</span>, <span class="keyword">null</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="1、select-from"><a href="#1、select-from" class="headerlink" title="1、select from"></a>1、select from</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本查询-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、查询指定字段 name,workno,age返回</span></span><br><span class="line"><span class="keyword">select</span> name, workno, age</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、查询返回所有字段</span></span><br><span class="line"><span class="keyword">select</span> id,</span><br><span class="line"> workno,</span><br><span class="line"> name,</span><br><span class="line"> gender,</span><br><span class="line"> age,</span><br><span class="line"> idcard,</span><br><span class="line"> workaddress,</span><br><span class="line"> entrydate</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可以查询所有字段，但实际使用中不建议，因为不明确</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查询所有员工的工作地址并 起一个别名(as可以省略)</span></span><br><span class="line"><span class="keyword">select</span> workaddress <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、查询所有员工的工作地址并去除重复地址</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> workaddress <span class="string">&#x27;上班地址&#x27;</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h2 id="2、where"><a href="#2、where" class="headerlink" title="2、where"></a>2、where</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 条件查询 where-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、查询年龄为88的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">=</span><span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、查询年龄小于20的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">&lt;</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查询没有身份证号码的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、查询有身份证号码的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5、查询年龄不等于88的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">88</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6、查询年龄在15到20（两端都包含）之间的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">15</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- between and 小的在前面 大的在后面 否则什么都查不到</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">15</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7、查询性别为女且年龄小于25的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8、查询年龄或等于18或20或40的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="operator">||</span>age <span class="operator">=</span> <span class="number">20</span> <span class="operator">||</span> age <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9、查询名字为两个字的员工的信息 模糊匹配：like _对应单个字符 %对应多个字符</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10、查询身份证号最后一位是X的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;%X&#x27;</span>;</span><br><span class="line"># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;_________________X&#x27;</span>; 这样不太好</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11、查询身份证号倒数第九位是0的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;%0________&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="3、count、max、group"><a href="#3、count、max、group" class="headerlink" title="3、count、max、group"></a>3、count、max、group</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数 max min avg:最大最小平均值 sum:整列数据加起来 count:统计整列数据的个数 作用于列 所有聚合函数不参与null的计算--</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、统计企业员工数量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp; <span class="comment">-- 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(idcard) <span class="keyword">from</span> emp; <span class="comment">-- 15因为有一个员工的身份证号码为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、统计所有员工的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查询最大的年龄</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、查询最小的年龄</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(age) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5、统计西安地区员工年龄之和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(age) <span class="keyword">from</span> emp <span class="keyword">where</span> workaddress <span class="operator">=</span> <span class="string">&#x27;西安&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组查询 group by   [having 条件]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、根据性别分组，分别统计男女人数</span></span><br><span class="line"><span class="comment">-- 根据什么字段分组就查询什么字段，查询其他字段无意义</span></span><br><span class="line"><span class="comment">-- count(*)此处表示每组的数量</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、根据性别分组，分别统计男女平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址</span></span><br><span class="line"><span class="comment">-- having后面也接条件，与where不同的是，having对分组后的数据进行操作,having可以对聚合函数进行判断，where不行</span></span><br><span class="line"><span class="comment">-- 执行顺序：where&gt;聚合函数&gt;having 分组后查询字段一般为聚合函数或分组字段，因为查询其他字段无意义</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> address_count,workaddress <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> address_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="4、order-by"><a href="#4、order-by" class="headerlink" title="4、order by"></a>4、order by</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序查询 order by----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、根据年龄对员工进行排序</span></span><br><span class="line"><span class="comment">-- 升序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age; <span class="comment">-- 默认升序排序</span></span><br><span class="line"># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、根据入职时间，对员工进行降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> entrydate <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、根据年龄升序排序，若年龄相同，根据入职时间降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age, entrydate <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页查询(把所有数据一页一页展示出来) limit 起始索引，查询的个数---------&gt;起始索引=（页码数-1）*每页展示数--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 分页查询limit是MySQL的方言，不同的数据库语言有不同的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、查询第1页员工数据，查询个数为10</span></span><br><span class="line"># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line">limit <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 第一页的其实索引可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、查询第2页员工数据，查询个数为10,不足10条则全部显示</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line">limit <span class="number">10</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="5、案例"><a href="#5、案例" class="headerlink" title="5、案例"></a>5、案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- DQL案例--------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.查询年龄为20,21,22,23岁的员工信息。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">=</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">or</span> age <span class="operator">=</span> <span class="number">21</span></span><br><span class="line"><span class="keyword">or</span> age <span class="operator">=</span> <span class="number">22</span></span><br><span class="line"><span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询性别为男，并且年龄在20-40岁（含）以内的姓名为三个字的员工。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。</span></span><br><span class="line"><span class="keyword">select</span> name, age, entrydate</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&lt;=</span> <span class="number">35</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> age, entrydate <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查询性别为男，且年龄在20-40岁（含）以内的员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序,取前5个员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><h1 id="四、-DCL"><a href="#四、-DCL" class="headerlink" title="四、 DCL"></a>四、 DCL</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- DCL---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="comment">-- 创建用户‘tanking’，只能在当前主机localhost访问，密码是123456</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;tanking&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户‘cxk’，能在任意主机访问数据库，密码 ctrljntm,%为通配符</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;cxk&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;ctrljntm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改cxk密码为‘123’</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;cxk&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户‘tanking’</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;tanking&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询权限---------------------------------------------------</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> cxk;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 用户cxk 授予 对clb数据库中所有表操作 的 所有权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> clb.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;cxk&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销 cxk对clb数据库中所有表操作的所有权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> clb.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;cxk&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="五、-函数"><a href="#五、-函数" class="headerlink" title="五、 函数"></a>五、 函数</h1><h2 id="1、字符串函数"><a href="#1、字符串函数" class="headerlink" title="1、字符串函数"></a>1、字符串函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 字符串函数----------------------------------------------</span></span><br><span class="line"><span class="comment">-- concat 拼接字符串</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lower 字符串全部小写</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;HelloWorld&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- upper 字符串全部大写</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;helloworld&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lpad 左填充 中间的参数表示 字符串的长度，最后参数表示 以什么字符填充</span></span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;cxk&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rpad 右填充 参数同上</span></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;cxk&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- trim 去除字符串头尾的空格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;  cxk ctrl &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- substring(str,1,5) 截取字符串 此处表示截取 从索引1开始截取 字符串str 长度为5 的 子串（注意这个索引是从1开始的）</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;hello_mysql&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="2、数值函数"><a href="#2、数值函数" class="headerlink" title="2、数值函数"></a>2、数值函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数值函数----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ceil 向上取整，只要小数位不是0，就加1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor 向下取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod 模 （取余数）</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">mod</span>(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rand 生成 0~1之间 的随机数</span></span><br><span class="line"><span class="keyword">select</span> rand();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- round 四舍五入 保留位数</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="number">2.305</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 对2.305四舍五入，保留2位小数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：生成一个6位数的随机验证码</span></span><br><span class="line"><span class="keyword">select</span> lpad(round(rand(), <span class="number">6</span>) <span class="operator">*</span> <span class="number">1000000</span>, <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="3、日期函数"><a href="#3、日期函数" class="headerlink" title="3、日期函数"></a>3、日期函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 日期函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curdate 返回当前日期</span></span><br><span class="line"><span class="keyword">select</span> curdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curtime 返回当前时间</span></span><br><span class="line"><span class="keyword">select</span> curtime();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- now 返回当前时间和日期</span></span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- year month day 分别获取 年月日</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(now());</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(now());</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(now());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- date_add 指定日期加上一定时间后的日期及时间</span></span><br><span class="line"><span class="keyword">select</span> date_add(now(), <span class="type">interval</span> <span class="number">66</span> <span class="keyword">day</span>);    <span class="comment">-- 从现在往后推66天</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_add(now(), <span class="type">interval</span> <span class="number">-10</span> <span class="keyword">year</span>);  <span class="comment">-- 从现在往前推10年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- datediff 返回两个日期之间相差的天数(前面的日期-后面的日期)</span></span><br><span class="line"><span class="keyword">select</span> datediff(now(), <span class="string">&#x27;2002-10-26&#x27;</span>);   <span class="comment">-- 从我生日到现在多少天了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：查询所有员工入职天数，并按照降序排序</span></span><br><span class="line"><span class="keyword">select</span> name,datediff(curdate(),entrydate) <span class="keyword">as</span> 入职天数 <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> 入职天数 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h2 id="4、流程控制函数"><a href="#4、流程控制函数" class="headerlink" title="4、流程控制函数"></a>4、流程控制函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- if(bool,val1,val2) true返回val1 false返回val2</span></span><br><span class="line"><span class="keyword">select</span> if(<span class="literal">true</span>, <span class="string">&#x27;cxk&#x27;</span>, <span class="string">&#x27;ikun&#x27;</span>);</span><br><span class="line"><span class="comment">-- 类似于三目运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ifnull(v1,v2) 如果v1不为null，返回v1,为null返回v2</span></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>); <span class="comment">-- 注意空字符串不是null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>, <span class="string">&#x27;v2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case when then else end</span></span><br><span class="line"><span class="comment">-- 查询员工姓名和工作地址，条件 北京/上海 ---&gt; 一线城市 其他 ---&gt; 二线城市</span></span><br><span class="line"><span class="keyword">select</span> name,</span><br><span class="line"> (<span class="keyword">case</span> workaddress</span><br><span class="line">      <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> concat(emp.workaddress, <span class="string">&#x27; 一线城市&#x27;</span>)</span><br><span class="line">      <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> concat(emp.workaddress, <span class="string">&#x27; 一线城市&#x27;</span>)</span><br><span class="line">      <span class="keyword">else</span> concat(emp.workaddress, <span class="string">&#x27; 二线城市&#x27;</span>) <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：统计班级各个学生的成绩，展示规则如下</span></span><br><span class="line"><span class="comment">-- &gt;= 85 优秀</span></span><br><span class="line"><span class="comment">-- &gt;= 60 及格</span></span><br><span class="line"><span class="comment">-- 否则 不及格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score</span><br><span class="line">(</span><br><span class="line">    id      <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    name    <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    math    tinyint unsigned comment <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">    English tinyint unsigned comment <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">    Chinese tinyint unsigned comment <span class="string">&#x27;语文&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;成绩表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">67</span>, <span class="number">88</span>, <span class="number">95</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="number">23</span>, <span class="number">66</span>, <span class="number">90</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">76</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,</span><br><span class="line"> (<span class="keyword">case</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line"> (<span class="keyword">case</span> <span class="keyword">when</span> English <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> English <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line"> (<span class="keyword">case</span> <span class="keyword">when</span> Chinese <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> Chinese <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span></span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure><h1 id="六、约束"><a href="#六、约束" class="headerlink" title="六、约束"></a>六、约束</h1><h2 id="1、基础约束"><a href="#1、基础约束" class="headerlink" title="1、基础约束"></a>1、基础约束</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2</span><br><span class="line">(</span><br><span class="line">id     <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,       </span><br><span class="line">    <span class="comment">-- primary key:主键，auto_increment:id随插入的数据自动增加，无需插入</span></span><br><span class="line"></span><br><span class="line"> name   <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,          </span><br><span class="line">    <span class="comment">-- not null:不能为空，unique:唯一的，其他行不能出现重复</span></span><br><span class="line"></span><br><span class="line"> age    <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>, </span><br><span class="line">    <span class="comment">-- check(条件):必须满足check中的条件</span></span><br><span class="line"></span><br><span class="line"> status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;状态&#x27;</span>,                  </span><br><span class="line">    <span class="comment">-- default:没有指定时的默认值</span></span><br><span class="line"></span><br><span class="line"> gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(name, age, status, gender) <span class="comment">-- id为主键，无需插入，插入也没用，会自动更正</span></span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Tom1&#x27;</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Tom2&#x27;</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(name, age, status, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">null</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>); <span class="comment">-- 插入的name不能为null，报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2 (name, age, status, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Tom1&#x27;</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>); <span class="comment">-- 插入的name不能重复，报错,虽然没有成功，但是已经申请到主键，所以会空出一个主键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(name, age, status, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Tom3&#x27;</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(name, age, status, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Tom3&#x27;</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="string">&#x27;男&#x27;</span>); <span class="comment">-- 插入的年龄超出0~120的范围，报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2(name, age, gender)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Tom4&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>); <span class="comment">-- 不插入status，插入数据后status值默认为1</span></span><br></pre></td></tr></table></figure><h2 id="2、外键约束"><a href="#2、外键约束" class="headerlink" title="2、外键约束"></a>2、外键约束</h2><h3 id="1、增、删外键"><a href="#1、增、删外键" class="headerlink" title="1、增、删外键"></a>1、增、删外键</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 外键约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备数据:准备两张表并插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept</span><br><span class="line">(</span><br><span class="line">id   <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;部门名称&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;部门表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(id, name)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;研发部&#x27;</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">&#x27;市场部&#x27;</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">&#x27;财务部&#x27;</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="string">&#x27;销售部&#x27;</span>),</span><br><span class="line"> (<span class="number">5</span>, <span class="string">&#x27;总经办&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp</span><br><span class="line">(</span><br><span class="line">id        <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name      <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age       <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">job       <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工作&#x27;</span>,</span><br><span class="line">salary    <span class="type">int</span> <span class="keyword">check</span> ( salary <span class="operator">&gt;</span> <span class="number">0</span> ) comment <span class="string">&#x27;工资&#x27;</span>,</span><br><span class="line">entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">managerid <span class="type">int</span> comment <span class="string">&#x27;直属领导ID&#x27;</span>,</span><br><span class="line">dept_id   <span class="type">int</span> comment <span class="string">&#x27;部门ID&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;金庸&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;总裁&#x27;</span>, <span class="number">20000</span>, <span class="string">&#x27;2000-01-01&#x27;</span>, <span class="keyword">null</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">&#x27;张无忌&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;项目经理&#x27;</span>, <span class="number">12500</span>, <span class="string">&#x27;2005-12-05&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">&#x27;杨逍 &#x27;</span>, <span class="number">33</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">8400</span>, <span class="string">&#x27;2000-11-03&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="number">48</span>, <span class="string">&#x27;开发 &#x27;</span>, <span class="number">11000</span>, <span class="string">&#x27;2002-02-05&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">5</span>, <span class="string">&#x27;常遇春&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">10500</span>, <span class="string">&#x27;2004-09-07&#x27;</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">6</span>, <span class="string">&#x27;小昭&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;程序员鼓励师&#x27;</span>, <span class="number">6600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span></span><br><span class="line">dept(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给emp表的dept_id添加外键约束，关联dept表的主键id，dept变为emp的主表</span></span><br><span class="line"><span class="comment">-- fk_emp_dept_id:外键名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br></pre></td></tr></table></figure><h3 id="2、删除、更新行为"><a href="#2、删除、更新行为" class="headerlink" title="2、删除、更新行为"></a>2、删除、更新行为</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除、更新行为</span></span><br><span class="line"><span class="comment">-- 添加外键 + on cascade</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept (id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- cascade 在父表中删除/更新外键记录（外键数据）时，检查是否有外键，若有，则子表中的数据也相应的删除/更新</span></span><br><span class="line"><span class="comment">-- 通俗：父表删除或更新外键，子表只要有与父表相关的外键，那么子表也跟着更新或删除</span></span><br><span class="line"><span class="comment">-- 删除研发部的外键id后，emp表中所有dept_id对应研发部的员工都会被删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 + on set null</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept (id) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通俗：父表删除或更新外键，子表只要有与父表相关的外键，那么子表直接设置为null</span></span><br></pre></td></tr></table></figure><h1 id="七、多表查询"><a href="#七、多表查询" class="headerlink" title="七、多表查询"></a>七、多表查询</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建dept表，并插入数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept</span><br><span class="line">(</span><br><span class="line">id   <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;部门名称&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;部门表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (id, name)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;研发部&#x27;</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">&#x27;市场部&#x27;</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">&#x27;财务部&#x27;</span>),</span><br><span class="line"> (<span class="number">4</span>,</span><br><span class="line">  <span class="string">&#x27;销售部&#x27;</span>),</span><br><span class="line"> (<span class="number">5</span>, <span class="string">&#x27;总经办&#x27;</span>),</span><br><span class="line"> (<span class="number">6</span>, <span class="string">&#x27;人事部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 创建emp表，并插入数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp</span><br><span class="line">(</span><br><span class="line">    id        <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name      <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age       <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    job       <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">    salary    <span class="type">int</span> comment <span class="string">&#x27;薪资&#x27;</span>,</span><br><span class="line">    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">    managerid <span class="type">int</span> comment <span class="string">&#x27;直属领导ID&#x27;</span>,</span><br><span class="line">    dept_id   <span class="type">int</span> comment <span class="string">&#x27;部门ID&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span></span><br><span class="line">  dept (id);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;金庸&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;总裁&#x27;</span>, <span class="number">20000</span>, <span class="string">&#x27;2000-01-01&#x27;</span>, <span class="keyword">null</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">&#x27;张无忌&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;项目经理&#x27;</span>, <span class="number">12500</span>, <span class="string">&#x27;2005-12-05&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">&#x27;杨逍&#x27;</span>, <span class="number">33</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">8400</span>, <span class="string">&#x27;2000-11-03&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="number">48</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">11000</span>, <span class="string">&#x27;2002-02-05&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">5</span>, <span class="string">&#x27;常遇春&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">10500</span>, <span class="string">&#x27;2004-09-07&#x27;</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">6</span>, <span class="string">&#x27;小昭&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;程序员鼓励师&#x27;</span>, <span class="number">6600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">7</span>, <span class="string">&#x27;灭绝&#x27;</span>, <span class="number">60</span>, <span class="string">&#x27;财务总监&#x27;</span>, <span class="number">8500</span>, <span class="string">&#x27;2002-09-12&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">8</span>, <span class="string">&#x27;周芷若&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;会计&#x27;</span>, <span class="number">48000</span>, <span class="string">&#x27;2006-06-02&#x27;</span>, <span class="number">7</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">9</span>, <span class="string">&#x27;丁敏君&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;出纳&#x27;</span>, <span class="number">5250</span>, <span class="string">&#x27;2009-05-13&#x27;</span>, <span class="number">7</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">10</span>, <span class="string">&#x27;赵敏&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;市场部总监&#x27;</span>, <span class="number">12500</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">11</span>, <span class="string">&#x27;鹿杖客&#x27;</span>, <span class="number">56</span>, <span class="string">&#x27;职员&#x27;</span>, <span class="number">3750</span>, <span class="string">&#x27;2006-10-03&#x27;</span>, <span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">12</span>, <span class="string">&#x27;鹤笔翁&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;职员&#x27;</span>, <span class="number">3750</span>, <span class="string">&#x27;2007-05-09&#x27;</span>, <span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">13</span>, <span class="string">&#x27;方东白&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;职员&#x27;</span>, <span class="number">5500</span>, <span class="string">&#x27;2009-02-12&#x27;</span>, <span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">14</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="number">88</span>, <span class="string">&#x27;销售总监&#x27;</span>, <span class="number">14000</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">15</span>, <span class="string">&#x27;俞莲舟&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;销售&#x27;</span>, <span class="number">4600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">14</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">16</span>, <span class="string">&#x27;宋远桥&#x27;</span>, <span class="number">40</span>, <span class="string">&#x27;销售&#x27;</span>, <span class="number">4600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">14</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">17</span>, <span class="string">&#x27;陈友谅&#x27;</span>, <span class="number">42</span>, <span class="keyword">null</span>, <span class="number">2000</span>, <span class="string">&#x27;2011-10-12&#x27;</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表查询 -- 笛卡尔积（A集合与B集合所有的组合的情况）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="operator">=</span> dept.id;    <span class="comment">-- 通过条件消除多余的笛卡尔积</span></span><br></pre></td></tr></table></figure><h2 id="2、连接查询"><a href="#2、连接查询" class="headerlink" title="2、连接查询"></a>2、连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><blockquote><p>查询两张表中符合条件的数据，不符合条件的不会返回结果</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 内连接演示</span></span><br><span class="line"><span class="comment">-- 查询员工姓名，并查询关联部门的名称（隐式内连接实现）</span></span><br><span class="line"><span class="comment">-- 表结构：emp，dept</span></span><br><span class="line"><span class="comment">-- 条件：emp.dept_id = dept.id</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">select</span> emp.name, dept.name</span><br><span class="line"># <span class="keyword">from</span> emp,</span><br><span class="line">#      dept</span><br><span class="line"># <span class="keyword">where</span> dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 给表起别名，起了别名后不能用原名</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name</span><br><span class="line"><span class="keyword">from</span> emp e,</span><br><span class="line">dept d</span><br><span class="line"><span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工姓名，并查询关联部门的名称（显式内连接实现） -- inner join...on... inner可以省略，on后面接条件</span></span><br><span class="line"><span class="comment">-- 表结构：emp，dept</span></span><br><span class="line"><span class="comment">-- 条件：emp.dept_id = dept.id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.name, d.name</span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><blockquote><p>左外连接：查询==左表所有数据==和==右表中符合条件的数据==</p><p>右外连接：查询左表所有数据和右表中符合条件的数据</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 外连接演示</span></span><br><span class="line"><span class="comment">-- 表结构：emp,dept</span></span><br><span class="line"><span class="comment">-- 条件：emp.dept_id = dept.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左外连接：查询左表所有数据和右、左表相交的数据 left [outer] join...on... outer可以省略，on后面接条件</span></span><br><span class="line"><span class="comment">-- 查询所有员工信息和对应部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name</span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询右表所有数据和左、右表相交的数据</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">right</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id;</span><br><span class="line"><span class="comment">-- 左外连接和右外连接可以互相转化，表的顺序换一下就行了（习惯上左外连接）</span></span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自连接（自连接时要给表起别名用于区分哪张表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表结构：emp</span></span><br><span class="line"><span class="comment">-- 内自连接</span></span><br><span class="line"><span class="comment">-- 查询员工及其所属领导的名字</span></span><br><span class="line"><span class="keyword">select</span> e1.name, e2.name</span><br><span class="line"><span class="keyword">from</span> emp e1,</span><br><span class="line">emp e2</span><br><span class="line"><span class="keyword">where</span> e1.managerid <span class="operator">=</span> e2.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外自连接</span></span><br><span class="line"><span class="comment">-- 查询员工及其所属领导的名字，没有领导也要查询出来</span></span><br><span class="line"><span class="keyword">select</span> a.name <span class="string">&#x27;员工&#x27;</span>, b.name <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emp a</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.managerid <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><h2 id="union查询"><a href="#union查询" class="headerlink" title="union查询"></a>union查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 联合查询 union ，union all</span></span><br><span class="line"><span class="comment">-- 将薪资低于5000和年龄大于50的员工全部查询出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- union all 相当于把两张表直接加起来，所以有可能有重复的员工</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- union 对union all结果去重</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询的列数必须相同，字段类型也必须相同</span></span><br></pre></td></tr></table></figure><h2 id="3、子查询"><a href="#3、子查询" class="headerlink" title="3、子查询"></a>3、子查询</h2><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 标量子查询:后一个select查询的结果为单个值</span></span><br><span class="line"><span class="comment">-- 常用操作符:&gt; &lt; &lt;&gt; &gt;= = &lt;=</span></span><br><span class="line"><span class="comment">-- 查询 销售部 所有员工信息</span></span><br><span class="line"><span class="comment">-- a.先查询销售部门id</span></span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.根据销售部门id查出员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询在 方东白 入职之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;方东白&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="comment">-- 1、查询 销售部 和 市场部 的所有员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- a.先查询 销售部 和 市场部 的id</span></span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span></span><br><span class="line"><span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.根据id查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、查询工资比财务部所有员工工资都高的员工</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- a.查询财务部所有人的工资</span></span><br><span class="line"><span class="keyword">select</span> salary</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b.根据上述信息查询比财务部所有人工资都高的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"><span class="comment">--  &gt; all :大于后面查询到的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、查询比研发部至少一人工资高的员工 任意一人：研发部至少存在一个人的工资比我低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span></span><br><span class="line">(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span></span><br><span class="line">(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- any和some等同</span></span><br></pre></td></tr></table></figure><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="comment">-- 查询与 张无忌 薪资和直属领导相同的员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- a.查询张无忌的薪资和直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary, managerid</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询与 张无忌 薪资和直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> (salary, managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary, managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 查询和 鹿杖客 宋远桥 职位和薪资相同的员工信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- a.查询鹿杖客 宋远桥 的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job, salary</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;鹿杖客&#x27;</span>, <span class="string">&#x27;宋远桥&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询和 鹿杖客 宋远桥 职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> (job, salary) <span class="keyword">in</span> (<span class="keyword">select</span> job, salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;鹿杖客&#x27;</span>, <span class="string">&#x27;宋远桥&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询入职时间是‘2006-01-01’之后的员工及其部门信息</span></span><br><span class="line"><span class="comment">-- a.查询入职时间是‘2006-01-01’之后的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询这些员工的部门信息</span></span><br><span class="line"><span class="comment">-- 把上述查询的结果当做需要查询的一张表</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h2 id="4、多表查询案例"><a href="#4、多表查询案例" class="headerlink" title="4、多表查询案例"></a>4、多表查询案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ---------------&gt;多表查询案例 &lt;--------------</span></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> salgrade</span><br><span class="line">(</span><br><span class="line">grade <span class="type">int</span>,</span><br><span class="line">losal <span class="type">int</span>,</span><br><span class="line">hisal <span class="type">int</span></span><br><span class="line">) comment <span class="string">&#x27;薪资等级表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">2</span>, <span class="number">3001</span>, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">3</span>, <span class="number">5001</span>, <span class="number">8000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">4</span>, <span class="number">8001</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">5</span>, <span class="number">10001</span>, <span class="number">15000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">6</span>, <span class="number">15001</span>, <span class="number">20000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">7</span>, <span class="number">20001</span>, <span class="number">25000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade</span><br><span class="line"><span class="keyword">values</span> (<span class="number">8</span>, <span class="number">25001</span>, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.查询员工的姓名、年龄、职位、部门信息。</span></span><br><span class="line"><span class="keyword">select</span> e.name, e.age, e.job, d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询年龄小于30岁的员工姓名、年龄、职位、部门信息。</span></span><br><span class="line"><span class="keyword">select</span> e.name, e.age, e.job, d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">where</span> e.age <span class="operator">&lt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询拥有员工的部门ID、部门名称。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> d.id, d.name</span><br><span class="line"><span class="keyword">from</span> dept d,</span><br><span class="line">emp e</span><br><span class="line"><span class="keyword">where</span> d.id <span class="operator">=</span> e.dept_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.查询所有年龄大于40岁的员工，及其归属的部门名称：如果员工没有分配部门，也需要展示出来。</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name</span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">where</span> e.age <span class="operator">&gt;</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查询所有员工的工资等级。</span></span><br><span class="line"><span class="keyword">select</span> e.name, e.salary, s.losal, s.hisal, s.grade</span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> salgrade s <span class="keyword">on</span> e.salary <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6.查询&quot;研发部”所有员工的信息及工资等级。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e,</span><br><span class="line">salgrade s,</span><br><span class="line">dept d</span><br><span class="line"><span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">and</span> e.salary <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal</span><br><span class="line"><span class="keyword">and</span> d.name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, grade</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept d <span class="keyword">where</span> d.name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>)) e</span><br><span class="line">   <span class="keyword">left</span> <span class="keyword">join</span> salgrade s <span class="keyword">on</span> e.salary <span class="operator">&lt;=</span> s.hisal <span class="keyword">and</span> e.salary <span class="operator">&gt;=</span> s.losal;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.查询&quot;研发部”员工的平均工资。</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e.salary)</span><br><span class="line"><span class="keyword">from</span> emp e,</span><br><span class="line">dept d</span><br><span class="line"><span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">and</span> d.name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8.查询工资比&quot;灭绝&quot;高的员工信息。</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;灭绝&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp a,</span><br><span class="line">emp b</span><br><span class="line"><span class="keyword">where</span> a.salary <span class="operator">&gt;</span> b.salary</span><br><span class="line"><span class="keyword">and</span> b.name <span class="operator">=</span> <span class="string">&#x27;灭绝&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9.查询比平均薪资高的员工信息。</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">from</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10.查询低于本部门平均工资的员工信息。</span></span><br><span class="line"><span class="comment">-- 查询某部门平均薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e.salary)</span><br><span class="line"><span class="keyword">from</span> emp e,</span><br><span class="line">dept d</span><br><span class="line"><span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">and</span> d.id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询低于本部门平均工资的员工信息。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> e1.salary <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(e2.salary)</span><br><span class="line">             <span class="keyword">from</span> emp e2,</span><br><span class="line">                  dept d</span><br><span class="line">             <span class="keyword">where</span> e2.dept_id <span class="operator">=</span> d.id</span><br><span class="line">               <span class="keyword">and</span> d.id <span class="operator">=</span> e1.dept_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11.查询所有的部门信息，并统计部门的员工人数。</span></span><br><span class="line"><span class="comment">-- 查询所有部门信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> dept;</span><br><span class="line"><span class="comment">-- 统计1号部门员工数量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询所有的部门信息，并统计部门的员工人数</span></span><br><span class="line"><span class="keyword">select</span> d.id, d.name, (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp e <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id) <span class="string">&#x27;人数&#x27;</span></span><br><span class="line"><span class="keyword">from</span> dept d;</span><br></pre></td></tr></table></figure><h1 id="八、事务"><a href="#八、事务" class="headerlink" title="八、事务"></a>八、事务</h1><h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><blockquote><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><h2 id="2、事务操作"><a href="#2、事务操作" class="headerlink" title="2、事务操作"></a>2、事务操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---&gt; 准备数据 &lt;---------------------</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account</span><br><span class="line">(</span><br><span class="line">id    <span class="type">int</span> <span class="keyword">primary</span> key AUTO_INCREMENT comment <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">name  <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">money <span class="keyword">double</span>(<span class="number">10</span>, <span class="number">2</span>) comment <span class="string">&#x27;余额&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;账户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name, money)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">2000</span>),</span><br><span class="line"> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 恢复数据操作</span></span><br><span class="line"><span class="keyword">update</span> account</span><br><span class="line"><span class="keyword">set</span> money <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>; <span class="comment">-- 查询事务提交方式 0-手动 1-自动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式一</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">-- 设置为手动提交</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账操作（张三转给李四1000元）</span></span><br><span class="line"><span class="comment">-- 查询张三余额</span></span><br><span class="line"><span class="keyword">select</span> money</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 张三余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account</span><br><span class="line"><span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若此处出现异常，则张三-1000元，但李四并没有+1000元</span></span><br><span class="line">异常... <span class="comment">-- 模拟出错场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 李四余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account</span><br><span class="line"><span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 设置为自动提交</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转账操作（张三转给李四1000元）</span></span><br><span class="line"><span class="comment">-- 查询张三余额</span></span><br><span class="line"><span class="keyword">select</span> money</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 张三余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account</span><br><span class="line"><span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若此处出现异常，则张三-1000元，但李四并没有+1000元</span></span><br><span class="line">异常...   <span class="comment">-- 模拟出错场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 李四余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account</span><br><span class="line"><span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="3、事务的四大特性（ACID）"><a href="#3、事务的四大特性（ACID）" class="headerlink" title="3、事务的四大特性（ACID）"></a>3、事务的四大特性（ACID）</h2><blockquote><ol><li><p><strong>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</strong></p></li><li><p><strong>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</strong> </p></li><li><p><strong>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</strong> </p></li><li><p><strong>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</strong> </p></li><li><p><strong>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</strong> </p></li></ol></blockquote><h2 id="4、并发事务问题"><a href="#4、并发事务问题" class="headerlink" title="4、并发事务问题"></a>4、并发事务问题</h2><blockquote><p><strong>脏读：一个事务读取到另外一个事务未提交的数据。</strong></p><p><strong>不可重复读：一个事务先后读取同一条数据，但两次读取到的数据不同。</strong></p><p><strong>幻读：一个事务查询数据时没有对应数据，插入该数据时又发现该数据已经存在，好像出现“幻影”。</strong></p></blockquote><h2 id="5、隔离级别"><a href="#5、隔离级别" class="headerlink" title="5、隔离级别"></a>5、隔离级别</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 并发事务与隔离级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询事务隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别 session-仅当前页面起作用    transaction isolation level-事务隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- repeatable read是默认级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level repeatable read ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 隔离级别越高，数据越安全，但是性能越低</span></span><br></pre></td></tr></table></figure><h1 id="九、JDBC"><a href="#九、JDBC" class="headerlink" title="九、JDBC"></a>九、JDBC</h1><h2 id="1、jdbc7步编程"><a href="#1、jdbc7步编程" class="headerlink" title="1、jdbc7步编程"></a>1、jdbc7步编程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDBC快速入门</span></span><br><span class="line"><span class="comment">//1、注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、定义sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 666 where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、获取执行sql的对象 Statement</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、执行sql</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//受影响的行数</span></span><br><span class="line">count = stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6、处理结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;受影响的行数有&quot;</span> + count + <span class="string">&quot;行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7、释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="2、DriverManager"><a href="#2、DriverManager" class="headerlink" title="2、DriverManager"></a>2、DriverManager</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//1、注册驱动 --&gt;可以省略</span></span><br><span class="line">  <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接 --&gt;如果连接的是本机的数据库且端口是默认的 3306 则可以简写</span></span><br><span class="line">  <span class="comment">// String url = &quot;jdbc:mysql://localhost:3306/clb&quot;;</span></span><br><span class="line">  <span class="comment">//简写：</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、定义sql</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 1000 where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、获取执行sql的对象 Statement</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//5、执行sql</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//受影响的行数</span></span><br><span class="line">  count = stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//6、处理结果</span></span><br><span class="line">  System.out.println(<span class="string">&quot;受影响的行数有&quot;</span> + count + <span class="string">&quot;行&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line"></span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DriverManager有两个作用:</span></span><br><span class="line"><span class="comment">    1、注册驱动</span></span><br><span class="line"><span class="comment">    2、获取数据库连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="3、Connection"><a href="#3、Connection" class="headerlink" title="3、Connection"></a>3、Connection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、管理事务       </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//将自动提交改为手动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">    <span class="comment">//6、处理结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数有&quot;</span> + count + <span class="string">&quot;行&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制造异常</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);</span><br><span class="line">    <span class="comment">//6、处理结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数有&quot;</span> + count2 + <span class="string">&quot;行&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Statement"><a href="#4、Statement" class="headerlink" title="4、Statement"></a>4、Statement</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3Statement</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Statement:</span></span><br><span class="line"><span class="comment">  1、执行SQL语句</span></span><br><span class="line"><span class="comment">  int executeUpdate(sql) -&gt; 执行DML、DDL语句</span></span><br><span class="line"><span class="comment">  执行DML语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDML</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、定义sql</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 666 where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、获取执行sql的对象 Statement</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5、执行sql</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//6、处理结果</span></span><br><span class="line">  System.out.println(count &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功&quot;</span> : <span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  执行DDL语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDDL</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、定义sql</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;drop database cxk&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、获取执行sql的对象 Statement</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5、执行sql</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//6、处理结果</span></span><br><span class="line"><span class="comment">//        System.out.println(count &gt; 0 ? &quot;修改成功&quot; : &quot;修改失败&quot;);</span></span><br><span class="line">  System.out.println(count);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line"></span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、ResultSet"><a href="#5、ResultSet" class="headerlink" title="5、ResultSet"></a>5、ResultSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4ResultSet</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ResultSet:</span></span><br><span class="line"><span class="comment">  执行DQL查询语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ResultSetDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">  <span class="comment">//3、定义sql语句</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line">  <span class="comment">//4、获取statement对象</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">  <span class="comment">//5、执行sql</span></span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//6、处理数据，遍历rs中的所有数据</span></span><br><span class="line">  <span class="comment">//6.1光标向下移动一行，判断当前行是否有数据</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  while (rs.next()) &#123;</span></span><br><span class="line"><span class="comment">      //6.2 获取数据getXxx()</span></span><br><span class="line"><span class="comment">      int id = rs.getInt(1);</span></span><br><span class="line"><span class="comment">      String name = rs.getString(2);</span></span><br><span class="line"><span class="comment">      double money = rs.getDouble(3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      System.out.println(id);</span></span><br><span class="line"><span class="comment">      System.out.println(name);</span></span><br><span class="line"><span class="comment">      System.out.println(money);</span></span><br><span class="line"><span class="comment">      System.out.println(&quot;-------------------&quot;);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">      <span class="comment">//6.2 获取数据getXxx()</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(id);</span><br><span class="line">      System.out.println(name);</span><br><span class="line">      System.out.println(money);</span><br><span class="line">      System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line">  rs.close();</span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  查询数据库中account表的数据，封装成Account对象，并存储到ArrayList表中</span></span><br><span class="line"><span class="comment">  1、定义实体类Account</span></span><br><span class="line"><span class="comment">  2、查询数据</span></span><br><span class="line"><span class="comment">  3、封装数据到ArrayList表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ResultSetDemo2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">  <span class="comment">//3、定义sql语句</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line">  <span class="comment">//4、获取statement对象</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">  <span class="comment">//5、执行sql</span></span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;Account&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">      <span class="comment">//6.2 获取数据getXxx()</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">      lst.add(<span class="keyword">new</span> <span class="title class_">Account</span>(id, name, money));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(lst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line">  rs.close();</span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、用户登陆"><a href="#6、用户登陆" class="headerlink" title="6、用户登陆"></a>6、用户登陆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用户登陆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginDemo5</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UserLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收用户名和密码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;cxk&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;jntm&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where name = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取Statement对象</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行sql语句</span></span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否登陆成功</span></span><br><span class="line">  System.out.println(rs.next() ? <span class="string">&quot;登陆成功&quot;</span> : <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line">  rs.close();</span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  sql注入问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UserLogin_Inject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//1、注册驱动</span></span><br><span class="line">  Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、获取连接</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/clb&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收用户名和密码 sql注入-&gt;此处密码错误却还能成功登陆</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ikunngmngmngm&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27;or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where name = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取Statement对象</span></span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行sql语句</span></span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">  System.out.println(<span class="string">&quot;sql = &quot;</span> + sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否登陆成功</span></span><br><span class="line">  System.out.println(rs.next() ? <span class="string">&quot;登陆成功&quot;</span> : <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//7、释放资源</span></span><br><span class="line">  rs.close();</span><br><span class="line">  stmt.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、PrepareStatement"><a href="#7、PrepareStatement" class="headerlink" title="7、PrepareStatement"></a>7、PrepareStatement</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    PrepareStatement解决sql注入问题</span></span><br><span class="line"><span class="comment">    将sql语句中的敏感符号加\ 进行转义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrepareStatementDemo6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrepareStatement</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1、注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取连接</span></span><br><span class="line">        <span class="comment">//useSeverPrepStmts=true 开启预编译功能 ：性能更高</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:/clb?useSSL=false&amp;useSeverPrepStmts=true&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收用户名和密码 sql注入-&gt;此处密码错误却还能成功登陆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ikunngmngmngm&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27;or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where name = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Statement对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置？的值</span></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行sql语句</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否登陆成功</span></span><br><span class="line">        System.out.println(rs.next() ? <span class="string">&quot;登陆成功&quot;</span> : <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        pstmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、Druid数据库连接池"><a href="#8、Druid数据库连接池" class="headerlink" title="8、Druid数据库连接池"></a>8、Druid数据库连接池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Druid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Druid数据库连接池</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1、导入jar包</span></span><br><span class="line">        <span class="comment">//2、定义配置文件</span></span><br><span class="line">        <span class="comment">//3、加载配置文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取连接池对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbcDemo/src/druid.properties&quot;</span>));</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置文件（根据具体情况配置）</span></span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:/clb?useSSL=<span class="literal">false</span>&amp;useServerPrepStmts=<span class="literal">true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line"># 初始化连接数量</span><br><span class="line">initialSize=<span class="number">5</span></span><br><span class="line"># 最大连接数量</span><br><span class="line">maxActive=<span class="number">10</span></span><br><span class="line"># 最大等待时间-&gt;<span class="number">3</span>秒</span><br><span class="line">maxWait=<span class="number">30000</span></span><br></pre></td></tr></table></figure><h1 id="十、进阶"><a href="#十、进阶" class="headerlink" title="十、进阶"></a>十、进阶</h1><h2 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 索引</span><br><span class="line"></span><br><span class="line">-- 查询表中所有索引</span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 创建索引:  create index 索引名 on 表名(字段名);</span><br><span class="line">-- 给表中name字段创建常规索引</span><br><span class="line">create index idx_user_name on tb_user (name);</span><br><span class="line"></span><br><span class="line">-- 给表中phone字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line"></span><br><span class="line">-- 给表中profession,age,status创建联合索引,字段的顺序是有讲究的</span><br><span class="line">create index idx_user_pro_age_sta on tb_user (profession, age, status);</span><br><span class="line"></span><br><span class="line">-- 给表中email字段创建常规索引</span><br><span class="line">create index idx_user_email on tb_user (email);</span><br><span class="line"></span><br><span class="line">-- 删除索引:  drop index 索引名 on 表名;</span><br><span class="line">drop index idx_user_email on tb_user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- SQL性能分析</span><br><span class="line">-- 1、查看各种sql语句的执行频率</span><br><span class="line">show global status like &#x27;Com_______&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2、慢查询日志,查询语句执行时间超过指定时间（默认10秒）就会记录到慢查询日志</span><br><span class="line">show variables like &#x27;slow_query_log&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 3、profile 详情</span><br><span class="line">-- 查看是否支持profiling</span><br><span class="line">select @@have_profiling;</span><br><span class="line"></span><br><span class="line">-- 查看profiling是否开启 0-未开启 1-开启</span><br><span class="line">select @@profiling;</span><br><span class="line"></span><br><span class="line">-- 开启profiling</span><br><span class="line">set profiling = 1;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from tb_user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查看所有查询语句耗时情况</span><br><span class="line">show profiles;</span><br><span class="line"></span><br><span class="line">-- 查看指定查询语句的各个阶段的耗时</span><br><span class="line">-- show profile for query 10;</span><br><span class="line"></span><br><span class="line">-- 额外查看sql语句cpu消耗</span><br><span class="line">-- show profile cpu for query 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 4、explain 执行计划</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where id = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 索引的使用</span><br><span class="line">/**</span><br><span class="line">1-最左前缀法则：</span><br><span class="line">最左边的索引必须存在，否则索引全部失效</span><br><span class="line"> 如果跳过了某个索引，那么从该索引开始的后面字段的索引失效</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 没有跳过索引，索引全部生效</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;</span><br><span class="line">and age = 31</span><br><span class="line">and status = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;</span><br><span class="line">and age = 31;</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">-- 跳过最左边的索引，索引全部失效</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where age = 31</span><br><span class="line">and status = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">-- 跳过age索引，后面的status索引失效，前面的profession索引正常</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;</span><br><span class="line">and status = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询语句的条件的位置不影响索引是否生效</span><br><span class="line">-- 没有跳过任何索引，索引全部生效</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where status = &#x27;0&#x27;</span><br><span class="line">and age = 31</span><br><span class="line">and profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">2-出现范围查询(&gt;,&lt;)时，后面的索引失效,使用&gt;=,&lt;=不会</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;</span><br><span class="line">and age &gt; 30</span><br><span class="line">and status = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">3-索引运算</span><br><span class="line">    ·不要在索引上进行运算，否则索引失效</span><br><span class="line">    ·字符串字段查询时不加单引号，索引失效</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where substring(phone, 10, 2) = &#x27;15&#x27;;</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where phone = 17799990004;</span><br><span class="line">-- 没用单引号，索引失效</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">4-模糊匹配</span><br><span class="line">    ·后面加%/_模糊匹配，索引正常</span><br><span class="line">    ·前面模糊，索引失效</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession like &#x27;软件%&#x27;; -- 索引有效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession like &#x27;%工程&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">5-or连接的条件</span><br><span class="line">    ·只有两个条件都有索引，索引才会生效，否则失效</span><br><span class="line">    ·解决方法：建立相关字段的索引</span><br><span class="line">*/</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where phone = &#x27;17799990004&#x27;</span><br><span class="line">or age = 31; -- phone有索引，但是age没有索引，索引失效</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where phone = &#x27;17799990004&#x27;</span><br><span class="line">or id = 1;</span><br><span class="line">-- phone 和 id都有索引，索引生效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">6-数据分布影响</span><br><span class="line">·如果MySQL评估使用索引比全表更慢，则放弃索引，大部分数据都符合条件时会出现这种情况</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where phone &gt; &#x27;0&#x27;;</span><br><span class="line">-- 所有电话号码都大于0，使用全表扫描</span><br><span class="line"></span><br><span class="line">-- 使用了索引，具体使用索引还是不使用索引取决表中的数据，符合条件的数据多-&gt;不用，少-&gt;用</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession is null;</span><br><span class="line"></span><br><span class="line">-- 未使用索引</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession is not null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- SQL提示:是优化数据库的一个重要手段，就是在sql语句中加入一些人为的提示达到优化操作的目的</span><br><span class="line">-- 查询一个字段时，如果同时存在单列索引和联合索引，默认使用联合索引</span><br><span class="line"></span><br><span class="line">-- profession有两个索引，默认使用的是联合索引</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">-- use index 建议MySQL使用这个索引，至于用不用，取决于MySQL</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user use index (idx_user_pro)</span><br><span class="line">where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">-- ignore index 忽略索引，指定不会使用该索引</span><br><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from tb_user ignore index (idx_user_pro)</span><br><span class="line">where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">-- force index 强制使用，指定必须使用该索引,use可能MySQL并不接受，force强制MySQL使用</span><br><span class="line"></span><br><span class="line">-- ---------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、SQL优化"><a href="#2、SQL优化" class="headerlink" title="2、SQL优化"></a>2、SQL优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- SQL优化</span><br><span class="line"></span><br><span class="line">-- 1、插入优化:</span><br><span class="line">-- 批量插入</span><br><span class="line">-- 手动控制事务</span><br><span class="line">-- 主键顺序插入</span><br><span class="line">-- load指令</span><br><span class="line"></span><br><span class="line">select @@local_infile;</span><br><span class="line">set global local_infile = 1;</span><br><span class="line"></span><br><span class="line">load data local infile &#x27;D:/Edge下载/进阶篇/相关SQL脚本/load_user_100w_sort.sql&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2、主键优化：</span><br><span class="line">-- 尽量降低主键的长度</span><br><span class="line">-- 插入数据时，尽量使用顺序插入</span><br><span class="line">-- 尽量不要使用UUID或者其他自然主键</span><br><span class="line">-- 尽量不对主键进行修改</span><br><span class="line"></span><br><span class="line">-- 3、order by 优化：</span><br><span class="line">-- using filesort:效率低</span><br><span class="line">-- using index:效率高</span><br><span class="line">show index from  tb_user; -- Collation:索引的顺序，A-&gt;升序，D-&gt;降序</span><br><span class="line"></span><br><span class="line">explain select age,phone from tb_user order by age,phone;</span><br><span class="line"></span><br><span class="line">-- 创建age和phone字段的一个联合索引,根据索引查询，结果不需要再进行排序</span><br><span class="line">create index idx_user_age_phone on tb_user(age,phone);</span><br><span class="line"></span><br><span class="line">-- 两个条件都是倒序，使用index倒序扫描 Backward index scan; Using index</span><br><span class="line">explain select age,phone from tb_user order by age desc,phone desc ;</span><br><span class="line"></span><br><span class="line">-- 先对phone排序，再根据age排序,不符合最左前缀法则，Using index; Using filesort</span><br><span class="line">explain select age,phone from tb_user order by phone,age;</span><br><span class="line"></span><br><span class="line">-- 先对age升序，再对phone降序排序</span><br><span class="line">explain select age,phone from tb_user order by age,phone desc;</span><br><span class="line"></span><br><span class="line">-- 优化：创建age升序phone降序的索引(默认是升序)</span><br><span class="line">create index idx_user_age_phone_ad on tb_user(age,phone desc);</span><br><span class="line"></span><br><span class="line">-- 尽量避免使用select*,否则需要所有字段都建立了联合索引才能走索引，否则就是filesort</span><br><span class="line">-- 不可避免使用filesort时，可以适当增大排序文件缓冲区大小</span><br><span class="line"></span><br><span class="line">-- limit 优化</span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line">limit 900000,10;</span><br><span class="line"></span><br><span class="line">-- 覆盖索引加子查询的形式</span><br><span class="line">select t.*</span><br><span class="line">from tb_user t,</span><br><span class="line">(select id from tb_user order by id limit 900000,10) e</span><br><span class="line">where t.id = e.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- count()优化</span><br><span class="line">-- 效率 count(*) ≈ count(1) &gt; count(主键) &gt; count(字段)</span><br><span class="line">select count(*)from tb_user;</span><br><span class="line">select count(id)from tb_user;</span><br><span class="line">select count(1)from tb_user;</span><br><span class="line">select count(username) from tb_user;</span><br><span class="line"></span><br><span class="line">-- update 优化</span><br><span class="line">-- update更新的数据最好有索引，否则执行update语句时行锁会升级为表锁，并发性能降低</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/07/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="操作系统的定义："><a href="#操作系统的定义：" class="headerlink" title="操作系统的定义："></a>操作系统的定义：</h3><blockquote><p><strong>==操作系统是直接控制和管理计算机软硬件资源，合理地组织计算机工作流程，便于用户使用的程序的集合==</strong></p></blockquote><hr><h3 id="操作系统的功能：（操作系统的主要功能是管理系统中的资源）"><a href="#操作系统的功能：（操作系统的主要功能是管理系统中的资源）" class="headerlink" title="操作系统的功能：（操作系统的主要功能是管理系统中的资源）"></a>操作系统的功能：（操作系统的主要功能是管理系统中的资源）</h3><blockquote><ul><li><strong>==处理器管理==</strong></li><li><strong>==存储器管理==</strong></li><li><strong>==I/O设备管理==</strong></li><li><strong>==文件管理==</strong></li><li><strong>==用户接口==</strong></li></ul></blockquote><hr><h3 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h3><ul><li><strong>并发性：操作系统最重要的特性</strong></li><li><strong>共享性</strong></li><li><strong>虚拟性</strong></li><li><strong>异步性</strong></li></ul><hr><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ol><li><p><strong>批处理系统：具有批处理功能但不具有交互能力，设计时应优先考虑 周转时间和吞吐量</strong></p></li><li><p><strong>分时系统（重要指标-响应时间）</strong></p><blockquote><p><strong>特点：交互性、同时性、独立性、及时性</strong></p></blockquote></li><li><p><strong>实时操作系统</strong></p><blockquote><p><strong>特点：实时性、高可靠性、安全性</strong></p></blockquote></li><li><p><strong>微机操作系统</strong></p></li><li><p><strong>网络操作系统</strong></p><blockquote><p><strong>两种主要的工作模式：客户/服务器模式、对等模式</strong></p></blockquote></li><li><p><strong>分布式操作系统</strong></p><blockquote><p><strong>特点：分布性、透明性、统一性、健壮性</strong></p></blockquote></li><li><p><strong>嵌入式操作系统</strong></p></li></ol><hr><h3 id="操作系统的结构模型"><a href="#操作系统的结构模型" class="headerlink" title="操作系统的结构模型"></a>操作系统的结构模型</h3><ol><li><p><strong>整体式模型：容易使系统陷于死锁</strong></p></li><li><p><strong>层次式模型</strong></p></li><li><p><strong>微内核和客户/服务器模型</strong></p><blockquote><p><strong>微内核优点：可扩展性强、可靠性高、可移植性好</strong></p></blockquote></li><li><p><strong>面向对象模型</strong></p></li></ol><hr><h2 id="第二章-用户与操作系统的接口"><a href="#第二章-用户与操作系统的接口" class="headerlink" title="第二章 用户与操作系统的接口"></a>第二章 用户与操作系统的接口</h2><h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><blockquote><p><strong>==用户一次请求计算机系统为其完成任务所进行的工作的总和==</strong></p></blockquote><hr><h3 id="程序级接口"><a href="#程序级接口" class="headerlink" title="程序级接口"></a>程序级接口</h3><ol><li><p><strong>用户态和核心态</strong></p></li><li><p><strong>特权指令和访管指令</strong></p><blockquote><p><strong>特权指令：只允许在核心态下使用的指令</strong></p><p><strong>访管指令功能</strong></p><ol><li><strong>实现从用户态到核心态的转变</strong></li><li><strong>在核心态下由操作系统代替用户完成其要求</strong></li><li><strong>工作完成后有核心态返回到用户态</strong></li></ol></blockquote></li></ol><hr><h2 id="第三章-进程的描述与控制"><a href="#第三章-进程的描述与控制" class="headerlink" title="第三章 进程的描述与控制"></a>第三章 进程的描述与控制</h2><h3 id="1-程序顺序执行"><a href="#1-程序顺序执行" class="headerlink" title="1. 程序顺序执行"></a>1. 程序顺序执行</h3><blockquote><ol><li><strong>顺序性</strong></li><li><strong>封闭性</strong></li><li><strong>可再现性</strong></li></ol></blockquote><hr><h3 id="2-进程描述"><a href="#2-进程描述" class="headerlink" title="2. 进程描述"></a>2. 进程描述</h3><blockquote><p><strong>==定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，进程是系统进行资源分配和调度的的一个独立单位。==</strong></p></blockquote><hr><h3 id="3-进程的特性"><a href="#3-进程的特性" class="headerlink" title="3. 进程的特性"></a>3. 进程的特性</h3><blockquote><ol><li><strong>动态性：进程最基本的特征，与静态的程序不同</strong></li><li><strong>并发性：多个进程可以同时存在于内存中，在一段时间内并发运行，不是同时执行</strong></li><li><strong>独立性</strong></li><li><strong>异步性</strong></li><li><strong>结构性</strong></li></ol></blockquote><hr><h3 id="4-进程与程序的区别"><a href="#4-进程与程序的区别" class="headerlink" title="4. 进程与程序的区别"></a>4. 进程与程序的区别</h3><blockquote><ol><li><strong>进程的动态性</strong></li><li><strong>进程的暂时性</strong></li><li><strong>进程的结构性</strong></li></ol></blockquote><hr><h3 id="5-进程控制块（PCB）"><a href="#5-进程控制块（PCB）" class="headerlink" title="5.进程控制块（PCB）"></a>5.进程控制块（PCB）</h3><hr><h3 id="6-进程状态"><a href="#6-进程状态" class="headerlink" title="6. 进程状态"></a>6. 进程状态</h3><blockquote><p><strong>==基本状态：==</strong></p><ol><li><strong>==就绪态==</strong></li><li><strong>==执行态==</strong></li><li><strong>==阻塞态==</strong></li></ol><p><strong>==状态的转换：==</strong></p><ol><li><strong>==就绪态 -&gt; 执行态：进程调度==</strong></li><li><strong>==执行态 -&gt; 就绪态：时间片到或被强占==</strong></li><li><strong>==执行态 -&gt; 阻塞态：I/O请求或等待某个事件==</strong></li><li><strong>==阻塞态 -&gt; 就绪态：I/O完成或事件发生==</strong></li></ol><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/235745ea5cba25b7d8e9ca234a923ce4.png" alt="screen-capture"></p></blockquote><hr><h3 id="7-原语操作"><a href="#7-原语操作" class="headerlink" title="7. 原语操作"></a>7. 原语操作</h3><blockquote><ol><li><strong>原语：原子操作，原语中的所有动作要么全做要么全不做，具有不可分割性</strong></li><li><strong>进程控制原语：</strong><ol><li>==<strong>创建原语：进程可以创建子进程，进程只能由其父进程创建</strong>==</li><li>==<strong>撤销原语：进程完成任务后应将其撤销，撤销原语由其父进程发出，一个进程不会撤销自己</strong>==</li><li>==<strong>阻塞原语：进程阻塞是进程的自身行为</strong>==</li><li>==<strong>唤醒原语：由相关进程唤醒，从阻塞态转换为就绪态</strong>==</li><li>==<strong>挂起原语：只能挂起该进程的子孙进程</strong>==</li><li>==<strong>激活原语：只能激活自己的子孙进程</strong>==</li></ol></li></ol></blockquote><hr><h3 id="8-线程（调度和执行的基本的单位）"><a href="#8-线程（调度和执行的基本的单位）" class="headerlink" title="8. 线程（调度和执行的基本的单位）"></a>8. 线程（调度和执行的基本的单位）</h3><blockquote><ol><li>线程引入：==减少时空开销，提高并发性==</li><li>线程的定义：==线程是进程内一个相对独立、可调度的执行单位，是进程中一个单一的控制线索==</li><li>线程可以共享进程的所拥有的全部资源，同一个进程中的所有线程可以并发执行</li></ol></blockquote><hr><h2 id="第四章-进程通信"><a href="#第四章-进程通信" class="headerlink" title="第四章 进程通信"></a>第四章 进程通信</h2><h3 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h3><blockquote><ol><li><strong>==临界资源：一次仅允许一个进程使用的资源称为临界资源==</strong></li><li><strong>==临界区：每个进程中访问临界资源的那段程序代码称为临界区==</strong></li></ol></blockquote><hr><h3 id="同步机构设计准则"><a href="#同步机构设计准则" class="headerlink" title="同步机构设计准则"></a>同步机构设计准则</h3><blockquote><ol><li>==<strong>空闲让进</strong>==</li><li>==<strong>忙则等待</strong>==</li><li>==<strong>有限等待</strong>==</li><li>==<strong>让权等待</strong>==</li></ol></blockquote><hr><h3 id="信号量机制实现互斥和同步（低级方法，只能传递少量信息）"><a href="#信号量机制实现互斥和同步（低级方法，只能传递少量信息）" class="headerlink" title="信号量机制实现互斥和同步（低级方法，只能传递少量信息）"></a>信号量机制实现互斥和同步（低级方法，只能传递少量信息）</h3><hr><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><blockquote><p><strong>目标：</strong></p><ol><li><strong>面向系统：</strong><ol><li><strong>吞吐量大：评价批处理系统的重要指标（吞吐量是指单位时间内完成的作业数）</strong></li><li><strong>CPU利用率高</strong></li><li><strong>各类资源的平衡利用</strong></li></ol></li><li><strong>面向用户准则：</strong><ol><li><strong>周转时间短：周转时间=完成时间-创建时间</strong></li><li>==<strong>平均周转时间：周转时间的平均值</strong>==</li><li><strong>平均带权周转时间：带权周转时间=完成时间-创建时间）/运行时间</strong></li><li><strong>省略三点</strong></li></ol></li></ol></blockquote><hr><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><blockquote><ol><li>时机：<ol><li>==执行完毕或异常终止==</li><li>==自己调用阻塞原语而进入等待状态==</li><li>==时间片用完==</li><li>==执行完系统调用后返回用户进程时==</li><li>==就绪队列某个进程的优先级高于当前的进程==</li></ol></li></ol></blockquote><h3 id="常用的调度算法"><a href="#常用的调度算法" class="headerlink" title="常用的调度算法"></a>常用的调度算法</h3><blockquote><ol><li>==先来先服务（FCFS）==</li><li>==短作业（进程）优先==</li><li>==时间片轮转调度算法：（时间片用完的进程和新进入的进程同时进入就绪队列时，新来的优先）==</li><li>==高优先权优先调度算法==</li><li>==最高响应比优先调度算法：响应比：（等待时间+需要执行的时间）/需要执行的时间==</li></ol></blockquote><hr><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h3><blockquote><p><strong>==死锁 是一种状态：在系统中，两个或两个以上的进程无限期地等待永远不可能发生的事件，则称这些进程处于死锁状态==</strong></p></blockquote><h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><blockquote><ol><li><strong>==竞争资源==</strong></li><li><strong>==进程推进顺序不合理==</strong></li></ol></blockquote><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><blockquote><ol><li><strong>==互斥条件：一个进程得到的资源其他进程不能使用==</strong></li><li><strong>==请求和保持条件：进程手上拿着资源不释放的前提下还请求其他资源==</strong></li><li><strong>==环路条件：发生死锁时，必然存在一个进程-资源的环形链==</strong></li></ol></blockquote><h3 id="处理死锁的策略"><a href="#处理死锁的策略" class="headerlink" title="处理死锁的策略"></a>处理死锁的策略</h3><blockquote><ol><li><strong>预防策略</strong>：==<strong>破坏死锁的四个必要条件中的一个或多个</strong>==从而预防死锁的发生<ol><li>破坏互斥条件</li><li>破坏不剥夺条件</li><li>破坏请求与保持条件：==<strong>静态资源分配法-&gt;必须一次性申请在运行过程中需要的所有资源</strong>==</li><li>破坏环路条件：==<strong>有序资源使用法-&gt;将系统所有资源按类型进行线性排队，并赋予不同序号</strong>==</li></ol></li><li><strong>避免策略</strong>：资源动态分配时<strong>==采用某些办法（银行家算法）防止系统进入不安全状态==</strong>，从而避免死锁<ol><li>==<strong>银行家算法：当系统的资源满足不了任何进程时，就是不安全状态</strong>==</li></ol></li><li><strong>死锁检测</strong>：==<strong>允许系统发生死锁，发生后及时检测出死锁然后解除死锁</strong>==</li><li><strong>解除策略</strong>：==<strong>和死锁检测相配套，发生死锁时，将死锁解除</strong>==</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/07/28/git/"/>
      <url>/2023/07/28/git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><h2 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h2><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><h2 id="-7"><a href="#-7" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="-8"><a href="#-8" class="headerlink" title=" "></a> </h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h2 id="-9"><a href="#-9" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="-10"><a href="#-10" class="headerlink" title=" "></a> </h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h2 id="-11"><a href="#-11" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="-12"><a href="#-12" class="headerlink" title=" "></a> </h2><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h2 id="-13"><a href="#-13" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h2 id="-14"><a href="#-14" class="headerlink" title=" "></a> </h2><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><h2 id="-15"><a href="#-15" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="-16"><a href="#-16" class="headerlink" title=" "></a> </h2><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><h2 id="-17"><a href="#-17" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="-18"><a href="#-18" class="headerlink" title=" "></a> </h2><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="-19"><a href="#-19" class="headerlink" title=" "></a> </h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><h1 id="git-教程"><a href="#git-教程" class="headerlink" title="git 教程"></a>git 教程</h1><p>git 教程1.版本管理工具概念2. 版本管理工具介绍2.1版本管理发展简史(维基百科)2.1.1 SVN(SubVersion)2.1.2 Git3. Git 发展简史4. Git 的安装4.1 git 的下载4.2 安装5. Git 工作流程5.1 Git 初始化5.2  git 流程5.2.1 流程图5.2.2概念即详解6.Git 的基本使用01-TortoiseGit 操作本地仓库6.1  初始化仓库6.2 添加文件6.3 提交文件至本地仓库6.4 修改文件,与再次提交文件6.5 文件状态讲解6.6 修改文件,不提交和上一个版本比较差异(diff)6.7 查看提交历史记录6.9 文件删除6.9.2从版本库删除6.9.3从版本库删除,但是不删除本地6.10 忽略提交7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)7.1 分支的概念7.2 为何要使用分支7.3 创建分支7.4 分支的查看切换7.4.1查看分支7.4.2切换分支7.5.1合并7.5.2删除分支8.tag  标签 8.1 标签的概念8.2  标签的创建(tag)8.3 标签的切换与删除9. 远程仓库9.0 局域网仓库9.0.1本地相对路径,多个文件夹之间共享代码9.0.2开启局域网共享代码9.1 常用远程仓库托管服务9.2  码云账号注册9.3 创建远程仓库9.4  把本地代码推送到远端9.5  从远程仓库克隆代码9.6  代码的修改与提交,查看历史9.7 ssh 连接概述9.8 ssh 密钥的生成9.9 ssh 密钥配置9.10 ssh 方式克隆/提交代码:9.11. 远程仓库的其他操作9.12 利用 gitee 搭建个人主页10.命令行— git基本操作10.1  介绍11. 命令行—git 远程仓库操作11.1    查看远程 11.2 添加/移除远测仓库11.3 从远程仓库获取代码12.  命令行— 分支13 . 命令行 —tag14. 案例</p><h1 id="1-版本管理工具概念"><a href="#1-版本管理工具概念" class="headerlink" title="1.版本管理工具概念"></a>1.版本管理工具概念</h1><p>我在大学毕业写论文的时候的时候碰到过如下的现象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;毕业论文第一版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文第二版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文第三版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文最终版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文最终版2.doc&gt;&gt;</span><br></pre></td></tr></table></figure><p>类似的问题我曾经也碰到过很多,例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">领导让写文档,写好了,领导让修改,改好了,领导觉得第一版不错,改回来吧,此时内心一脸懵,第一版长啥样没存档啊</span><br></pre></td></tr></table></figure><p>实际上,代码开发中也需要这样的软件来管理我们的代码. 例如我们经常会碰到如下的现象:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改之前好好的,改完就报错了,也没怎么修改啊</span><br></pre></td></tr></table></figure><p>在这种情况下如果不能查看修改之前的代码,查找问题是非常困难的.</p><p>如果有一个软件能记录我们对文档的所有修改,所有版本,那么上面的问题讲迎刃而解.而这类软件我们一般叫做版本控制工具</p><p>版本管理工具一般具有如下特性:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 能够记录历史版本,回退历史版本</span><br><span class="line">2) 团队开发,方便代码合并</span><br></pre></td></tr></table></figure><h1 id="2-版本管理工具介绍"><a href="#2-版本管理工具介绍" class="headerlink" title="2. 版本管理工具介绍"></a>2. 版本管理工具介绍</h1><p>现在比较流行的版本管理工具是git ,但是实际上git 是近几年才发展起来的,可能有一些老的项目,还在用一些老的软件,比如svn</p><h2 id="2-1版本管理发展简史-维基百科"><a href="#2-1版本管理发展简史-维基百科" class="headerlink" title="2.1版本管理发展简史(维基百科)"></a>2.1版本管理发展简史(维基百科)</h2><h3 id="2-1-1-SVN-SubVersion"><a href="#2-1-1-SVN-SubVersion" class="headerlink" title="2.1.1 SVN(SubVersion)"></a>2.1.1 SVN(SubVersion)</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SVN是集中式版本控制系统，版本库是集中放在中央服务器的.</span><br><span class="line">工作流程如下:</span><br><span class="line">    1.从中央服务器远程仓库下载代码</span><br><span class="line">    2.修改后将代码提交到中央服务器远程仓库</span><br></pre></td></tr></table></figure><p>优缺点:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点: 简单,易操作</span><br><span class="line">缺点:所有代码必须放在中央服务器  </span><br><span class="line">      1.服务器一旦宕机无法提交代码,即容错性较差</span><br><span class="line">      2.离线无法提交代码,无法及时记录我们的提交行为</span><br></pre></td></tr></table></figure><p>svn流程图</p><h3 id="2-1-2-Git"><a href="#2-1-2-Git" class="headerlink" title="2.1.2 Git"></a>2.1.2 Git</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS），分为两种类型的仓库：</span><br><span class="line">本地仓库和远程仓库</span><br><span class="line">工作流程如下</span><br><span class="line">    1．从远程仓库中克隆或拉取代码到本地仓库(clone/pull)</span><br><span class="line">    2．从本地进行代码修改</span><br><span class="line">    3．在提交前先将代码提交到暂存区</span><br><span class="line">    4．提交到本地仓库。本地仓库中保存修改的各个历史版本</span><br><span class="line">    5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</span><br></pre></td></tr></table></figure><p>总结:git和svn的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. svn 是集中式版本控制工具,git 是分布式版本控制工具</span><br><span class="line">2. svn 不支持离线提交,git 支持离线提交代码</span><br></pre></td></tr></table></figure><h1 id="3-Git-发展简史"><a href="#3-Git-发展简史" class="headerlink" title="3. Git 发展简史"></a>3. Git 发展简史</h1><p> 林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds, 1969年~ ） </p><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过<strong>手工方式合并代码！</strong></p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？那个年代不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，<strong>而且必须联网才能使用</strong>。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是<strong>付费</strong>的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。而授权的前提是:Linux 社区的人不能开发具有相同功能的竞争产品! </p><p>另一方面,BitKeeper不是开源的. 显然与Linux 的开源精神不相符,所以linux 社区的很多人抱怨,不愿意使用.</p><p>典型的就是  Andrew Tridgell  (Samba 开发服务的创造者) 非常不满.偷偷违反了和 BitKeeper 的协议,反编译 BitKeeper 的源代码,开发了个爬虫,然后爬取信息被人发现了. BitKeeper 公司的领导非常不满意,然后开始发布消息说,(下个版本)不再为Linux 提供免费的服务. </p><p>Linus  本人就出面协调(几周或者几个月),但是不管用, 没办法. 估计谈判的过程感觉到了憋屈—“吃人嘴短,拿人手软”</p><p>Linus  本人 花了10天的时间Git 出来了,一个月之内，Linux系统的源码已经由Git管理了！</p><p>Git 出来以后毕竟是一个人做的,开始并不好用(刚开始只能用勉强可以用来形容), 还是很多人抱怨,发展了很多年都没有干过其他软件.</p><p>直到 2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,从此git 迎来了飞速发展,当下git 已经成为了最流行的版本控制工具</p><h1 id="4-Git-的安装"><a href="#4-Git-的安装" class="headerlink" title="4. Git 的安装"></a>4. Git 的安装</h1><h2 id="4-1-git-的下载"><a href="#4-1-git-的下载" class="headerlink" title="4.1 git 的下载"></a>4.1 git 的下载</h2><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p>附件</p><h2 id="4-2-安装"><a href="#4-2-安装" class="headerlink" title="4.2 安装"></a>4.2 安装</h2><ol><li>按照附件的 顺序直接下一步傻瓜式安装即可</li><li>其中安装的过程中需要填写一个邮箱和用户名(任意即可)</li></ol><ol><li>$\color{red}{注意: 安装完毕请重启资源管理器,或者重启电脑!!!}$ </li><li>更改语言</li></ol><h1 id="5-Git-工作流程"><a href="#5-Git-工作流程" class="headerlink" title="5. Git 工作流程"></a>5. Git 工作流程</h1><h2 id="5-1-Git-初始化"><a href="#5-1-Git-初始化" class="headerlink" title="5.1 Git 初始化"></a>5.1 Git 初始化</h2><p>我们先初始化一个本地仓</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 新建测试文件夹</span><br><span class="line">2) 进入文件夹,然后右键创建版本库</span><br></pre></td></tr></table></figure><p>此时 我们看到 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 文件夹上多了一个绿色图标(如果没有请看本章节 5.3小节说明)</span><br><span class="line">2) 文件夹内部生成了一个.git 隐藏文件夹(需要设置隐藏文件夹可见)</span><br></pre></td></tr></table></figure><h2 id="5-2-git-流程"><a href="#5-2-git-流程" class="headerlink" title="5.2  git 流程"></a>5.2  git 流程</h2><h3 id="5-2-1-流程图"><a href="#5-2-1-流程图" class="headerlink" title="5.2.1 流程图"></a>5.2.1 流程图</h3><h3 id="5-2-2概念即详解"><a href="#5-2-2概念即详解" class="headerlink" title="5.2.2概念即详解"></a>5.2.2概念即详解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地仓库：是在开发人员自己电脑上的Git仓库,存放我们的代码(.git 隐藏文件夹就是我们的本地仓库)</span><br><span class="line">远程仓库：是在远程服务器上的Git仓库,存放代码(可以是github.com或者gitee.com 上的仓库,或者自己该公司的服务器)</span><br><span class="line">工作区: 我们自己写代码(文档)的地方</span><br><span class="line">暂存区: 在 本地仓库中的一个特殊的文件(index) 叫做暂存区,临时存储我们即将要提交的文件</span><br><span class="line">------------</span><br><span class="line">Clone：克隆，就是将远程仓库复制到本地仓库</span><br><span class="line">Push：推送，就是将本地仓库代码上传到远程仓库</span><br><span class="line">Pull：拉取，就是将远程仓库代码下载到本地仓库,并将代码 克隆到本地工作区</span><br></pre></td></tr></table></figure><h1 id="6-Git-的基本使用01-TortoiseGit-操作本地仓库"><a href="#6-Git-的基本使用01-TortoiseGit-操作本地仓库" class="headerlink" title="6.Git 的基本使用01-TortoiseGit 操作本地仓库"></a>6.Git 的基本使用01-TortoiseGit 操作本地仓库</h1><h2 id="6-1-初始化仓库"><a href="#6-1-初始化仓库" class="headerlink" title="6.1  初始化仓库"></a>6.1  初始化仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一: </span><br><span class="line">新建一个文件夹,进入文件夹内部操作</span><br><span class="line">1)右键--&gt; 在这里创建Git 版本库 </span><br></pre></td></tr></table></figure><p>  注意: 不要直接在桌面上操作,否则桌面就是一个仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法二:</span><br><span class="line">2) 右键--&gt;Git GUI here</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法三: 命令行模式</span><br><span class="line">2) git init </span><br></pre></td></tr></table></figure><p>创建完毕仓库,我们发现,此时我们创建的文件夹下有一个.git 文件已经生成了</p><p>并且仓库文件夹上多了一个 绿色图标</p><h2 id="6-2-添加文件"><a href="#6-2-添加文件" class="headerlink" title="6.2 添加文件"></a>6.2 添加文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)在仓库中新建一个文件</span><br><span class="line">2)选中新建的文件--&gt;右键--&gt; TortoiseGit--&gt; 添加</span><br><span class="line">3)此时我们看到文件夹上多了一个 &quot;加号&quot;</span><br></pre></td></tr></table></figure><h2 id="6-3-提交文件至本地仓库"><a href="#6-3-提交文件至本地仓库" class="headerlink" title="6.3 提交文件至本地仓库"></a>6.3 提交文件至本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)选中文件</span><br><span class="line">2) 右键--git提交</span><br></pre></td></tr></table></figure><h2 id="6-4-修改文件-与再次提交文件"><a href="#6-4-修改文件-与再次提交文件" class="headerlink" title="6.4 修改文件,与再次提交文件"></a>6.4 修改文件,与再次提交文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当我们修改文件以后,文件上多了一个红色感叹号,表示我们上次提交后该文件被修改过</span><br><span class="line">提交后文件图标又变成绿色</span><br></pre></td></tr></table></figure><h2 id="6-5-文件状态讲解"><a href="#6-5-文件状态讲解" class="headerlink" title="6.5 文件状态讲解"></a>6.5 文件状态讲解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git工作目录下的文件存在两种状态：</span><br><span class="line">1 untracked 未跟踪（未被纳入版本控制） :  比如新建的文件(此时文件夹上没有图标或者有一个&quot;问号&quot;)</span><br><span class="line">2 tracked 已跟踪（被纳入版本控制）     </span><br><span class="line">    2.1 Staged 已暂存状态            : 添加 但未提交状态(此时文件夹上有一个&quot;加号&quot;)</span><br><span class="line">2.2 Unmodified 未修改状态        : 已提交(此时文件夹上有一个&quot;对号&quot;)</span><br><span class="line">2.3 Modified 已修改状态          : 修改了,但是还没有提交 (此时文件夹上有一个&quot;红色感叹号&quot;)</span><br></pre></td></tr></table></figure><p>这些文件的状态会随着我们执行Git的命令发生变化</p><h2 id="6-6-修改文件-不提交和上一个版本比较差异-diff"><a href="#6-6-修改文件-不提交和上一个版本比较差异-diff" class="headerlink" title="6.6 修改文件,不提交和上一个版本比较差异(diff)"></a>6.6 修改文件,不提交和上一个版本比较差异(diff)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改文件,此时不要提交</span><br><span class="line">选中文件--&gt;右键--&gt; TortoiseGit--&gt; 比较差异</span><br></pre></td></tr></table></figure><h2 id="6-7-查看提交历史记录"><a href="#6-7-查看提交历史记录" class="headerlink" title="6.7 查看提交历史记录"></a>6.7 查看提交历史记录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选中文件</span><br><span class="line">右键--&gt; TortoiseGit--&gt; 显示日志</span><br><span class="line">此时我们可以看到所有的历史提交记录</span><br></pre></td></tr></table></figure><p>##6.8 回退至历史版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右键--&gt; TortoiseGit--&gt; 显示日志</span><br><span class="line">选中某个版本--&gt; 进行如下操作</span><br></pre></td></tr></table></figure><h2 id="6-9-文件删除"><a href="#6-9-文件删除" class="headerlink" title="6.9 文件删除"></a>6.9 文件删除</h2><p>###6.9.1本地删除与恢复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 直接选中文件删除的话,其实只是删除了本地工作区的文件,并没有删除 仓库中的文件</span><br><span class="line">   此时时可以回退的, 比如我们进行如下操作</span><br><span class="line">   1)文件删除</span><br><span class="line">   2)右键--&gt; TortoiseGit--&gt; 还原</span><br><span class="line">   此时我们发现文件又被恢复了</span><br></pre></td></tr></table></figure><h3 id="6-9-2从版本库删除"><a href="#6-9-2从版本库删除" class="headerlink" title="6.9.2从版本库删除"></a>6.9.2从版本库删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2) 我们如果真的想要将某个文件从服务器删除,需要进行如下操作</span><br><span class="line">   1) 删除文件,和上面的操作一样</span><br><span class="line">   2) 提交,此时服务文件已经删除了(历史版本还在,还是可以恢复)</span><br></pre></td></tr></table></figure><h3 id="6-9-3从版本库删除-但是不删除本地"><a href="#6-9-3从版本库删除-但是不删除本地" class="headerlink" title="6.9.3从版本库删除,但是不删除本地"></a>6.9.3从版本库删除,但是不删除本地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们可以如下操作,只删除服务器上的文件,但是本地文件并不删除</span><br><span class="line">备注: 删除之后需要提交,才会真正的从服务器删除</span><br></pre></td></tr></table></figure><h2 id="6-10-忽略提交"><a href="#6-10-忽略提交" class="headerlink" title="6.10 忽略提交"></a>6.10 忽略提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候我们一些文件是不需要提交的比如说idea/eclipse 开发的代码自动生成的配置文件</span><br><span class="line">如何配置不提交呢</span><br></pre></td></tr></table></figure><p>此时我们的根目录下会生成一个.gitignore 文件</p><p>忽略文件如何阅读,常见格式</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有以.a 结尾的文件讲被忽略(递归)</span></span><br><span class="line"><span class="string">*.a</span></span><br><span class="line"><span class="comment"># 不管其他规则怎样,强制不忽略  lib.a</span></span><br><span class="line"><span class="type">!lib.a</span></span><br><span class="line"><span class="comment"># 只忽略 文件 TODO (注意这里是文件)</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build文件夹下所有内容(递归) 这里是文件夹</span></span><br><span class="line"><span class="string">build/</span></span><br><span class="line"><span class="comment"># 忽略 doc 目录下以 *.txt 结尾的文件 (不递归)</span></span><br><span class="line"><span class="string">doc/*.txt</span></span><br><span class="line"><span class="comment"># 忽略 doc 目录下以 *.pdf 结尾的文件 (递归)</span></span><br><span class="line"><span class="string">doc/**/*.pdf</span></span><br></pre></td></tr></table></figure><p>当然理解了上述规则,我们也可以手动编辑该文件,而不用通过窗口化操作(如果不嫌麻烦)</p><h1 id="7-Git-的基本使用02-TortoiseGit-操作本地仓库-分支"><a href="#7-Git-的基本使用02-TortoiseGit-操作本地仓库-分支" class="headerlink" title="7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)"></a>7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)</h1><h2 id="7-1-分支的概念"><a href="#7-1-分支的概念" class="headerlink" title="7.1 分支的概念"></a>7.1 分支的概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，避免影响开发主线。多线程开发,可以同时开启多个任务的开发,多个任务之间互不影响.</span><br></pre></td></tr></table></figure><h2 id="7-2-为何要使用分支"><a href="#7-2-为何要使用分支" class="headerlink" title="7.2 为何要使用分支"></a>7.2 为何要使用分支</h2><p>先看单线程开发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思考如下现象</span><br><span class="line">    10.1 日 业务部门提出需求 : 明年 元旦3天做2个促销活动</span><br><span class="line">1) 12.31 号上线活动1, </span><br><span class="line">2) 1.4 号上线活动2 ,同时 要求撤销 活动1</span><br><span class="line">    你所在 部门领导 为了保证能顺利完成,要求 11.15 号完成 上述连个功能的开发工作</span><br><span class="line">此时作为开发人员:我要面临两个文件, 活动1 的代码,即要存在(12.31 要用)又要不存在(1.4 号要求删除) ,我们怎么做?</span><br><span class="line">显然比较棘手,如果使用分支(可以理解为将代码复制一份)将很好解决</span><br></pre></td></tr></table></figure><h2 id="7-3-创建分支"><a href="#7-3-创建分支" class="headerlink" title="7.3 创建分支"></a>7.3 创建分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">到现在为止,我们一直使用的时主分支(master)</span><br><span class="line">在主分支上操作创建分支</span><br></pre></td></tr></table></figure><h2 id="7-4-分支的查看切换"><a href="#7-4-分支的查看切换" class="headerlink" title="7.4 分支的查看切换"></a>7.4 分支的查看切换</h2><h3 id="7-4-1查看分支"><a href="#7-4-1查看分支" class="headerlink" title="7.4.1查看分支"></a>7.4.1查看分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看版本分支图,此时我们看到有两个分支</span><br><span class="line">当然,我们可以创建多个分支</span><br><span class="line">可以看到多个分支的图形</span><br></pre></td></tr></table></figure><h3 id="7-4-2切换分支"><a href="#7-4-2切换分支" class="headerlink" title="7.4.2切换分支"></a>7.4.2切换分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右键--&gt; 检出</span><br></pre></td></tr></table></figure><p>##7.5 分支的合并与删除</p><h3 id="7-5-1合并"><a href="#7-5-1合并" class="headerlink" title="7.5.1合并"></a>7.5.1合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们将代码切换到分支1,然后写属于需求1 的代码并提交</span><br><span class="line">当我们把需求1 开发完毕如何把需求1 的代码合并到主分支呢?</span><br><span class="line">--&gt;1 切换到 主版本</span><br><span class="line">--&gt;2 右键 合并即可将需求1 写的代码合并至主分支</span><br><span class="line">-----此时我们看到代码自动合并到了master分支</span><br></pre></td></tr></table></figure><h3 id="7-5-2删除分支"><a href="#7-5-2删除分支" class="headerlink" title="7.5.2删除分支"></a>7.5.2删除分支</h3><p>5,冲突的处理     5.1)冲突的概念</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现象演示</span><br><span class="line">开发人员A 开发需求1,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int [] args)</span><br><span class="line"> 同时开发人员B 开发需求2,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int a int b)</span><br><span class="line">他们在互相不知道对方需求的情况下同时提交了代码到自己的分支</span><br><span class="line">   思考此时如果我们把需求1 和需求2 同时都合并到主分支上, 主分支的 工具类 MathUtil 的第一行应该使用谁的代码? </span><br><span class="line">   此时主分支是不能智能判断第一行使用谁的代码,合并时会报错,我们叫做冲突.</span><br></pre></td></tr></table></figure><p>​    5.2) 如何处理冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析一下冲突的原因:</span><br><span class="line">开发人员之间彼此没有沟通导致的同一个时间节点修改了同一个地方的代码,合并是冲突</span><br><span class="line">思考:</span><br><span class="line">我们能直接把某个开发人员开发的代码删除吗?</span><br><span class="line">显然不能</span><br><span class="line">所以在处理冲突时,第一步应该时找开发另一个需求的人员沟通,之后才是处理冲突</span><br><span class="line">-----</span><br><span class="line">--&gt; 选中冲突的文件(带黄色感叹号的文件都是冲突的文件,如果有多个需要逐一处理)</span><br><span class="line">--&gt; 右键--&gt; 编辑冲突,</span><br><span class="line">--&gt;处理完毕后.标记已解决</span><br></pre></td></tr></table></figure><h1 id="8-tag-标签"><a href="#8-tag-标签" class="headerlink" title="8.tag  标签"></a>8.tag  标签</h1><h2 id="8-1-标签的概念"><a href="#8-1-标签的概念" class="headerlink" title="8.1 标签的概念"></a>8.1 标签的概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你的项目达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以给它打上标签(tag)</span><br><span class="line">比如说，我们想为我们的项目发布一个&quot;1.0&quot;版本。 我们给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。</span><br><span class="line">标签可以理解为项目里程碑的一个标记,一旦打上了这个标记则,表示当前的代码将不允许提交</span><br></pre></td></tr></table></figure><h2 id="8-2-标签的创建-tag"><a href="#8-2-标签的创建-tag" class="headerlink" title="8.2  标签的创建(tag)"></a>8.2  标签的创建(tag)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签的创建和分支的创建操作几乎一样</span><br></pre></td></tr></table></figure><h2 id="8-3-标签的切换与删除"><a href="#8-3-标签的切换与删除" class="headerlink" title="8.3 标签的切换与删除"></a>8.3 标签的切换与删除</h2><h1 id="9-远程仓库"><a href="#9-远程仓库" class="headerlink" title="9. 远程仓库"></a>9. 远程仓库</h1><p>我们的代码不能总是放在本地,因为总是放在本地,一旦电脑出现故障,数据将丢失,怎么共享呢,这里我们需要一个服务器, 我们可以把代码放到服务器上,然后让别人下载,这样我峨嵋你既可以备份代码,也可以进行团队协作开发</p><h2 id="9-0-局域网仓库"><a href="#9-0-局域网仓库" class="headerlink" title="9.0 局域网仓库"></a>9.0 局域网仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上我们可以搭建一个单间的局域网服务器共享我们的代码</span><br></pre></td></tr></table></figure><h3 id="9-0-1本地相对路径-多个文件夹之间共享代码"><a href="#9-0-1本地相对路径-多个文件夹之间共享代码" class="headerlink" title="9.0.1本地相对路径,多个文件夹之间共享代码"></a>9.0.1本地相对路径,多个文件夹之间共享代码</h3><h3 id="9-0-2开启局域网共享代码"><a href="#9-0-2开启局域网共享代码" class="headerlink" title="9.0.2开启局域网共享代码"></a>9.0.2开启局域网共享代码</h3><p>局域网这种共享是没有安全控制的,都可以访问,如果想要搭建一个可以控制权限的服务器需要借助第三方软件</p><p>gitblit,可以自行搜索搭建</p><h2 id="9-1-常用远程仓库托管服务"><a href="#9-1-常用远程仓库托管服务" class="headerlink" title="9.1 常用远程仓库托管服务"></a>9.1 常用远程仓库托管服务</h2><p>除了自己搭建服务器,其实我们可以使用一些免费的远程仓库,远程仓库有很多,常见的免费互联网远程仓库托管服务如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.github.com</span><br><span class="line">www.gitee.com</span><br><span class="line">www.gitlab.com</span><br><span class="line"></span><br><span class="line">github  是一个基于git实现在线代码托管的仓库，向互联网开放，企业版要收钱。</span><br><span class="line">gitee    即码云，是 oschina 免费给企业用的，不用自己搭建环境。</span><br><span class="line">gitlab   类似 github，一般用于在企业内搭建git私服，要自己搭环境。</span><br><span class="line"></span><br><span class="line">GitHub(gitee)、GitLab 不同点：</span><br><span class="line">1、GitHub如果使用私有仓库是需要付费的，(2019年开始私有仓库也是免费的但是只能3个人协同开发,想要更多需要收费)，GitLab可以在上面搭建私人的免费仓库。</span><br><span class="line">2、GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色：</span><br><span class="line">    (1)允许免费设置仓库权限</span><br><span class="line">    (2)允许用户选择分享一个project的部分代码</span><br><span class="line">    (3)允许用户设置project的获取权限，进一步提升安全性</span><br><span class="line">    (4)可以设置获取到团队整体的改进进度</span><br><span class="line">    (5)通过innersourcing让不在权限范围内的人访问不到该资源</span><br></pre></td></tr></table></figure><p>鉴于国内用户可能网络不好,这里我们使用gitee(码云) 来讲解我们的课程,其他可自行找资料学习非常类似</p><h2 id="9-2-码云账号注册"><a href="#9-2-码云账号注册" class="headerlink" title="9.2  码云账号注册"></a>9.2  码云账号注册</h2><p>填写邮箱发送验证码,然后可以注册账号,主页如下</p><h2 id="9-3-创建远程仓库"><a href="#9-3-创建远程仓库" class="headerlink" title="9.3 创建远程仓库"></a>9.3 创建远程仓库</h2><p>各个类型仓库之间的区别</p><h2 id="9-4-把本地代码推送到远端"><a href="#9-4-把本地代码推送到远端" class="headerlink" title="9.4  把本地代码推送到远端"></a>9.4  把本地代码推送到远端</h2><p>此时我们刷新仓库发现代码已经存在了</p><p>我们填写的用户信息,会被保存在本地,下次提交无需填写用户名和密码</p><h2 id="9-5-从远程仓库克隆代码"><a href="#9-5-从远程仓库克隆代码" class="headerlink" title="9.5  从远程仓库克隆代码"></a>9.5  从远程仓库克隆代码</h2><p>我们同样可以从库下载代码,</p><p>新建一个文件夹 repo2 ,进入然后进行如下操作</p><p>此时我们发现我们的代码已经被下载下来了</p><h2 id="9-6-代码的修改与提交-查看历史"><a href="#9-6-代码的修改与提交-查看历史" class="headerlink" title="9.6  代码的修改与提交,查看历史"></a>9.6  代码的修改与提交,查看历史</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)此时我们修改代码就不能仅仅是提交到本地了,提交完毕应该推送到远端服务器</span><br><span class="line">2)此时如果别人从远端仓库下载最新的代码其实是可以看到我们的代码修改记录的</span><br><span class="line">   git --&gt;显示日志</span><br></pre></td></tr></table></figure><h2 id="9-7-ssh-连接概述"><a href="#9-7-ssh-连接概述" class="headerlink" title="9.7 ssh 连接概述"></a>9.7 ssh 连接概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上git 不仅仅支持用户名密码方式的配置,可以有另外一种相对更加安全的配置即ssh 方式配置</span><br></pre></td></tr></table></figure><p> ssh 方式的底层原理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh连接地城是RAS加密算法,又称非对称加密,是一种现在公认的最安全的加密方式</span><br><span class="line">数学基础好的同学可以研究一下</span><br><span class="line">https://www.cnblogs.com/cjm123/p/8243424.html</span><br><span class="line"></span><br><span class="line">公钥私钥加密可以看作古代 的&quot;虎符&quot; , 我们本地电脑有一份,远程服务器有一份, 只要 &quot;虎符&quot; 核对通过 表示身份无误,可以执行提交等操作,无需输入用户名密码</span><br></pre></td></tr></table></figure><h2 id="9-8-ssh-密钥的生成"><a href="#9-8-ssh-密钥的生成" class="headerlink" title="9.8 ssh 密钥的生成"></a>9.8 ssh 密钥的生成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成公钥私钥</span><br><span class="line"> ssh-keygen -t rsa</span><br><span class="line"> 一直回车即可</span><br><span class="line"> 会默认用户目录 .ssh 目录生成一个默认的id_rsa文件 和id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="9-9-ssh-密钥配置"><a href="#9-9-ssh-密钥配置" class="headerlink" title="9.9 ssh 密钥配置"></a>9.9 ssh 密钥配置</h2><h2 id="9-10-ssh-方式克隆-提交代码"><a href="#9-10-ssh-方式克隆-提交代码" class="headerlink" title="9.10 ssh 方式克隆/提交代码:"></a>9.10 ssh 方式克隆/提交代码:</h2><p>  配置完成之后我们克隆我们之前的项目</p><p>修改后直接提交推送即可成功,,git 会自动去.ssh 目录找我们的私钥进行匹配</p><h2 id="9-11-远程仓库的其他操作"><a href="#9-11-远程仓库的其他操作" class="headerlink" title="9.11. 远程仓库的其他操作"></a>9.11. 远程仓库的其他操作</h2><p>概念</p><p>当我们从 gitee 上查看别人的项目的时候我们可能会看到上图中的按钮</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指数:</span><br><span class="line">是gitee 网站根据当前项目的各项指标计算出来的一个值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Star:</span><br><span class="line">点赞, 注意这里的并不像朋友圈那样容易获得点赞,圈内人还是很克制的</span><br><span class="line">Watch:</span><br><span class="line">   如果你watch 了某个开源项目,那么这个项目后续所有的改动你将收到通知</span><br><span class="line">Fork :</span><br><span class="line">将别人的代码克隆到你自己的仓库</span><br><span class="line">作用一: 如果担心某个优秀的项目别人突然有一天不开源了,你可以fork到自己的仓库</span><br><span class="line">    作用二: 修改别人的代码</span><br><span class="line">  以linux 为例,你其实不是linux 社区的开发人员,但是你 又想为linux 开发做贡献(维护代码)</span><br><span class="line">   你并没有权限,怎们办?</span><br><span class="line">   你可以先把linux 开源的代码 fork 到你自己的仓库,此时你就可以操作自己的仓库进行修改代码了</span><br><span class="line">   如何让别人合并你修改好的代码呢? </span><br><span class="line">    我们注意项目的上方有一个 &quot; Pull Request&quot; 这个按钮的意思是 &quot;请求求别人合并你修改的代码&quot;</span><br><span class="line">    当我们发起一个 Pull Request 时 , 项目的拥有者将收到 Pull Request请求,然后将根据你提交代码的质量决定是否合并</span><br></pre></td></tr></table></figure><p>项目操作</p><p>1)我们可以删除修改我们自己仓库的基本信息</p><ol><li>我们可以邀请其他人成为项目的开发人员或者管理人员</li></ol><p>我们可以删除修改我们自己仓库的基本信息</p><h2 id="9-12-利用-gitee-搭建个人主页"><a href="#9-12-利用-gitee-搭建个人主页" class="headerlink" title="9.12 利用 gitee 搭建个人主页"></a>9.12 利用 gitee 搭建个人主页</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)将静态资源上传至仓库</span><br><span class="line">2) 选择服务 pages 即可部署</span><br><span class="line">注意 1)必须有个index.html 文件</span><br><span class="line">注意 2) 只能搭建静态网站,动态网站请租赁服务器搭建提供服务</span><br><span class="line">注意 3) gitee 要求必须绑定手机号</span><br></pre></td></tr></table></figure><p>点击开启后gitee 会自动生成一个域名</p><p>直接访问即可</p><p>此时我们已经在git 上部署了一个静态的网站</p><h1 id="10-命令行—-git基本操作"><a href="#10-命令行—-git基本操作" class="headerlink" title="10.命令行— git基本操作"></a>10.命令行— git基本操作</h1><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1  介绍"></a>10.1  介绍</h2><p>​    上述我们的操作 使用的 是客户端TortoiseGit 操作的git ,实际上底层依旧是使用的命令行帮我们执行, 在早期 git 并没有窗口化工具,开发人员只能使用命令行模式</p><p>  实际上,如果你掌握并熟练使用了命令行模式操作git 的话,你会发现某些操作命令行比窗口化操作要简单</p><p>所有你在工作中会发现高深的技术人员可能会喜欢命令行模式提交git</p><p>##10.2 环境配置</p><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户信息</span> </span><br><span class="line">   git config --global user.name “itcast”</span><br><span class="line">   git config --global user.email “itcast@itcast.cn”</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看配置信息</span></span><br><span class="line">   git config --list</span><br><span class="line">   git config user.name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过上面的命令设置的信息会保存在~/.gitconfig文件中</span></span><br></pre></td></tr></table></figure><p>##10.3  初始化本地仓库 init</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库带工作区</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库不带工作区</span></span><br><span class="line">git init --bare  </span><br></pre></td></tr></table></figure><p>##10.4 克隆 clone</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库克隆</span></span><br><span class="line">git clone 远程Git仓库地址 </span><br><span class="line">例如: git clone https://gitee.com/itcast/gittest.git</span><br></pre></td></tr></table></figure><p>##10.5  查看状态 status</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">git status </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看状态 使输出信息更加简洁</span></span><br><span class="line">git status –s </span><br></pre></td></tr></table></figure><p>##10.6 add </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将未跟踪的文件加入暂存区</span></span><br><span class="line">git add  &lt;文件名&gt;  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂存区的文件取消暂存 (取消 add )</span></span><br><span class="line">git reset  &lt;文件名&gt;  </span><br></pre></td></tr></table></figure><p>##10.7 commit</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git commit 将暂存区的文件修改提交到本地仓库</span></span><br><span class="line">git commit -m &quot;日志信息&quot;  &lt;文件名&gt;  </span><br></pre></td></tr></table></figure><p>##10.8 删除 rm</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从本地工作区 删除文件</span></span><br><span class="line">git rm &lt;文件名&gt;  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果本工作区库误删, 想要回退</span></span><br><span class="line">git checkout head &lt;文件名&gt;  </span><br></pre></td></tr></table></figure><h1 id="11-命令行—git-远程仓库操作"><a href="#11-命令行—git-远程仓库操作" class="headerlink" title="11. 命令行—git 远程仓库操作"></a>11. 命令行—git 远程仓库操作</h1><h2 id="11-1-查看远程"><a href="#11-1-查看远程" class="headerlink" title="11.1    查看远程"></a>11.1    查看远程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程  列出指定的每一个远程服务器的简写</span></span><br><span class="line">git remote </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程 , 列出 简称和地址</span></span><br><span class="line">git remote  -v  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库详细地址</span></span><br><span class="line">git remote show  &lt;仓库简称&gt;</span><br></pre></td></tr></table></figure><h2 id="11-2-添加-移除远测仓库"><a href="#11-2-添加-移除远测仓库" class="headerlink" title="11.2 添加/移除远测仓库"></a>11.2 添加/移除远测仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程仓库</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除远程仓库和本地仓库的关系(只是从本地移除远程仓库的关联关系，并不会真正影响到远程仓库)</span></span><br><span class="line">git remote rm &lt;shortname&gt; </span><br></pre></td></tr></table></figure><h2 id="11-3-从远程仓库获取代码"><a href="#11-3-从远程仓库获取代码" class="headerlink" title="11.3 从远程仓库获取代码"></a>11.3 从远程仓库获取代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库克隆</span></span><br><span class="line">git clone &lt;url&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库拉取 (拉取到.git 目录,不会合并到工作区,工作区发生变化)</span></span><br><span class="line">git fetch  &lt;shortname&gt;  &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动合并  把某个版本的某个分支合并到当前工作区</span></span><br><span class="line">git merge &lt;shortname&gt;/&lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库拉取 (拉取到.git 目录,合并到工作区,工作区不发生变化) = fetch+merge</span></span><br><span class="line">git pull  &lt;shortname&gt;  &lt;分支名称&gt;</span><br><span class="line">git pull  &lt;shortname&gt;  &lt;分支名称&gt;  --allow-unrelated-histories  #  强制拉取合并</span><br></pre></td></tr></table></figure><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数—allow-unrelated-histories (如上 命令)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地仓库推送至远程仓库的某个分支</span></span><br><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure><h1 id="12-命令行—-分支"><a href="#12-命令行—-分支" class="headerlink" title="12.  命令行— 分支"></a>12.  命令行— 分支</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认 分支名称为 master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分支</span></span><br><span class="line">git branch &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span> </span><br><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支(如果分支已经修改过,则不允许删除)</span></span><br><span class="line">git branch -d  &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除分支</span></span><br><span class="line">git branch -D  &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交分支至远程仓库</span></span><br><span class="line">git push &lt;仓库简称&gt; &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并分支 将其他分支合并至当前工作区</span></span><br><span class="line">git merge &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库分支</span></span><br><span class="line">git push origin –d branchName</span><br></pre></td></tr></table></figure><h1 id="13-命令行-—tag"><a href="#13-命令行-—tag" class="headerlink" title="13 . 命令行 —tag"></a>13 . 命令行 —tag</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看tag详细信息</span> </span><br><span class="line">git show [tagName]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个tag</span></span><br><span class="line">git tag [tagName]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交指定tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push [仓库简称] [tagName]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b [branch] [tag]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d [tag]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程tag (注意 空格)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/[tag]</span></span><br></pre></td></tr></table></figure><h1 id="14-案例"><a href="#14-案例" class="headerlink" title="14. 案例"></a>14. 案例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">企业中我们是如何开发的</span><br><span class="line">1) 入职第一天,管理人员分配/git账号密码 </span><br><span class="line">2) 开发人员下载代码即文档/ 根据文档将环境搭建成功</span><br><span class="line">3) 团队一般会给你讲讲项目相关的支持</span><br><span class="line">----</span><br><span class="line">4) 你接到第一个需求(或者某个功能,一般要经过沟通,分析,设计...等过程)</span><br><span class="line">5) 创建feature分支(一般一个需求对应一个feature,命名格式上标注该需求的id)</span><br><span class="line">6) 开发需求,本地测试,提交代码到当前需求对应的feature分支,</span><br><span class="line">一般来讲为了避免将测试代码提交,需要提交前,检查如下步骤</span><br><span class="line">6.1) 是否多提交了某个文件,比如测试文件</span><br><span class="line">6.2) 是否漏提交文件</span><br><span class="line">6.3) 打开每一个应该提交的文件,判断是否多提交了一行代码,是否少提交了一行代码,是否删除了本应该存在的代码 </span><br><span class="line">检查完毕提交代码</span><br><span class="line">7) 合并分支至test分支-- 测试人员会在test分支中测试</span><br><span class="line">8) 测试人员测试bug ,开发者在feature分支上继续修改,提交</span><br><span class="line">9) 测试人员测试通过 ,test分支会被测试人员合并到develop开发分支,再次测试</span><br><span class="line">10)develop分支最终会被合并到master主分支</span><br></pre></td></tr></table></figure><p>`</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2023/07/28/C/"/>
      <url>/2023/07/28/C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code>new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用： </strong>给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">    <span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">    c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">    <span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">    ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = a; </span><br><span class="line">    ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//v += 10;</span></span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">    <span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code>返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//获取到圆的周长</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//2 * pi  * r</span></span><br><span class="line">        <span class="comment">//获取圆的周长</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">    <span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        m_id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">    stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_Car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">    <span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    C1 c1;</span><br><span class="line">    c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">    C2 c2;</span><br><span class="line">    c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名设置可读可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置为只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//姓名设置</span></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄设置</span></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置</span></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1  括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 显式法</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">    <span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = p.mAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person newman3;</span></span><br><span class="line">    <span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">    Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">    Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">////传统方式初始化</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">//    m_A = a;</span></span><br><span class="line">    <span class="comment">//    m_B = b;</span></span><br><span class="line">    <span class="comment">//    m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Phone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">    <span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">    <span class="comment">//析构顺序与构造相反</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员变量特点：</span></span><br><span class="line">    <span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">    <span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">    <span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数特点：</span></span><br><span class="line">    <span class="comment">//1 程序共享一个函数</span></span><br><span class="line">    <span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        mA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line">    <span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">    <span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person * p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">    p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        m_A = <span class="number">0</span>;</span><br><span class="line">        m_B = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">    <span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//const Type* const pointer;</span></span><br><span class="line">        <span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">        <span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mA = 10000;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">    cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">    person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常对象访问成员函数</span></span><br><span class="line">    person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Building b;</span><br><span class="line">    <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodGay  gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//    Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//    temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//    temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//    return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p2.m_A + val;</span><br><span class="line">    temp.m_B = p2.m_B + val;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数方式</span></span><br><span class="line">    Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前置++</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">//先++</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//再返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置++</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">//先返回</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">    out &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载赋值运算符 </span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">        <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回自身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄的指针</span></span><br><span class="line">    <span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int a = 10;</span></span><br><span class="line">    <span class="comment">//int b = 20;</span></span><br><span class="line">    <span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//c = b = a;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int a = 0;</span></span><br><span class="line">    <span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">    MyPrint myFunc;</span><br><span class="line">    <span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd add;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匿名对象调用  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP cp;</span><br><span class="line">    cp.<span class="built_in">header</span>();</span><br><span class="line">    cp.<span class="built_in">footer</span>();</span><br><span class="line">    cp.<span class="built_in">left</span>();</span><br><span class="line">    cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Java页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Python页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    CPP cp;</span><br><span class="line">    cp.<span class="built_in">header</span>();</span><br><span class="line">    cp.<span class="built_in">footer</span>();</span><br><span class="line">    cp.<span class="built_in">left</span>();</span><br><span class="line">    cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son2 s;</span><br><span class="line">    <span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">        m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">        <span class="comment">//m_C; //不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">        <span class="comment">//m_A;</span></span><br><span class="line">        <span class="comment">//m_B;</span></span><br><span class="line">        <span class="comment">//m_C;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">    Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">    <span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li>```<br>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</span><br><span class="line"></span><br><span class="line">**示例：**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//继承前加virtual关键字后，变为虚继承</span><br><span class="line">//此时公共的父类Animal称为虚基类</span><br><span class="line">class Sheep : virtual public Animal &#123;&#125;;</span><br><span class="line">class Tuo   : virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep, public Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = 100;</span><br><span class="line">    st.Tuo::m_Age = 200;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">    <span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通实现测试</span></span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">    c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建加法计算器</span></span><br><span class="line">    AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建减法计算器</span></span><br><span class="line">    abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建乘法计算器</span></span><br><span class="line">    abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">    <span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base * base = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">    base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="C:/Users/12655/Desktop/%25E5%2590%2584%25E7%25A7%258D%25E7%25AC%2594%25E8%25AE%25B0/assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//规定流程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Boil</span>();</span><br><span class="line">        <span class="built_in">Brew</span>();</span><br><span class="line">        <span class="built_in">PourInCup</span>();</span><br><span class="line">        <span class="built_in">PutSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//烧水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">    drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">    <span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code>virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">    <span class="comment">//virtual ~Animal()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">    <span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">    <span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的计算函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的显示函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的存储函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cpu = cpu;</span><br><span class="line">        m_vc = vc;</span><br><span class="line">        m_mem = mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供工作的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">        m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">        m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">        m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">    ~<span class="built_in">Computer</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放CPU零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_cpu;</span><br><span class="line">            m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放显卡零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_vc;</span><br><span class="line">            m_vc = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存条零件</span></span><br><span class="line">        <span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_mem;</span><br><span class="line">            m_mem = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">    VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">    Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一台电脑零件</span></span><br><span class="line">    CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">    VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">    Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建第一台电脑</span></span><br><span class="line">    Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">    computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第二台电脑组装</span></span><br><span class="line">    Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">    computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第三台电脑组装</span></span><br><span class="line">    Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">    computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include <fstream\></p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><div class="table-container"><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table></div><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include <fstream\></p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    <span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    <span class="comment">//string buf;</span></span><br><span class="line">    <span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建输出流对象</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打开文件</span></span><br><span class="line">    <span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、写文件</span></span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
